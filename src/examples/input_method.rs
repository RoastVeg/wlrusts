use libc;
extern "C" {
    pub type _IO_wide_data;
    pub type _IO_codecvt;
    pub type _IO_marker;
    pub type wl_proxy;
    pub type wl_display;
    pub type wl_compositor;
    pub type wl_registry;
    /* Generated by wayland-scanner 1.17.0 */
    /* *
 * @page page_input_method_unstable_v2 The input_method_unstable_v2 protocol
 * Protocol for creating input methods
 *
 * @section page_desc_input_method_unstable_v2 Description
 *
 * This protocol allows applications to act as input methods for compositors.
 *
 * An input method context is used to manage the state of the input method.
 *
 * Text strings are UTF-8 encoded, their indices and lengths are in bytes.
 *
 * This document adheres to the RFC 2119 when using words like "must",
 * "should", "may", etc.
 *
 * Warning! The protocol described in this file is experimental and
 * backward incompatible changes may be made. Backward compatible changes
 * may be added together with the corresponding interface version bump.
 * Backward incompatible changes are done by bumping the version number in
 * the protocol and interface names and resetting the interface version.
 * Once the protocol is to be declared stable, the 'z' prefix and the
 * version number in the protocol and interface names are removed and the
 * interface version number is reset.
 *
 * @section page_ifaces_input_method_unstable_v2 Interfaces
 * - @subpage page_iface_zwp_input_method_v2 - input method
 * - @subpage page_iface_zwp_input_popup_surface_v2 - popup surface
 * - @subpage page_iface_zwp_input_method_keyboard_grab_v2 - keyboard grab
 * - @subpage page_iface_zwp_input_method_manager_v2 - input method manager
 * @section page_copyright_input_method_unstable_v2 Copyright
 * <pre>
 *
 * Copyright © 2008-2011 Kristian Høgsberg
 * Copyright © 2010-2011 Intel Corporation
 * Copyright © 2012-2013 Collabora, Ltd.
 * Copyright © 2012, 2013 Intel Corporation
 * Copyright © 2015, 2016 Jan Arne Petersen
 * Copyright © 2017, 2018 Red Hat, Inc.
 * Copyright © 2018       Purism SPC
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 * </pre>
 */
    /* Generated by wayland-scanner 1.17.0 */
    /* *
 * @page page_text_input_unstable_v3 The text_input_unstable_v3 protocol
 * Protocol for composing text
 *
 * @section page_desc_text_input_unstable_v3 Description
 *
 * This protocol allows compositors to act as input methods and to send text
 * to applications. A text input object is used to manage state of what are
 * typically text entry fields in the application.
 *
 * This document adheres to the RFC 2119 when using words like "must",
 * "should", "may", etc.
 *
 * Warning! The protocol described in this file is experimental and
 * backward incompatible changes may be made. Backward compatible changes
 * may be added together with the corresponding interface version bump.
 * Backward incompatible changes are done by bumping the version number in
 * the protocol and interface names and resetting the interface version.
 * Once the protocol is to be declared stable, the 'z' prefix and the
 * version number in the protocol and interface names are removed and the
 * interface version number is reset.
 *
 * @section page_ifaces_text_input_unstable_v3 Interfaces
 * - @subpage page_iface_zwp_text_input_v3 - text input
 * - @subpage page_iface_zwp_text_input_manager_v3 - text input manager
 * @section page_copyright_text_input_unstable_v3 Copyright
 * <pre>
 *
 * Copyright © 2012, 2013 Intel Corporation
 * Copyright © 2015, 2016 Jan Arne Petersen
 * Copyright © 2017, 2018 Red Hat, Inc.
 * Copyright © 2018       Purism SPC
 *
 * Permission to use, copy, modify, distribute, and sell this
 * software and its documentation for any purpose is hereby granted
 * without fee, provided that the above copyright notice appear in
 * all copies and that both that copyright notice and this permission
 * notice appear in supporting documentation, and that the name of
 * the copyright holders not be used in advertising or publicity
 * pertaining to distribution of the software without specific,
 * written prior permission.  The copyright holders make no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied
 * warranty.
 *
 * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
 * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
 * FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
 * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
 * ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
 * THIS SOFTWARE.
 * </pre>
 */
    pub type wl_seat;
    pub type zwp_input_method_v2;
    pub type zwp_input_method_manager_v2;
    #[no_mangle]
    fn __assert_fail(__assertion: *const libc::c_char,
                     __file: *const libc::c_char, __line: libc::c_uint,
                     __function: *const libc::c_char) -> !;
    #[no_mangle]
    fn __errno_location() -> *mut libc::c_int;
    #[no_mangle]
    static mut stderr: *mut FILE;
    #[no_mangle]
    fn fprintf(_: *mut FILE, _: *const libc::c_char, _: ...) -> libc::c_int;
    #[no_mangle]
    fn printf(_: *const libc::c_char, _: ...) -> libc::c_int;
    #[no_mangle]
    fn atoi(__nptr: *const libc::c_char) -> libc::c_int;
    #[no_mangle]
    fn free(__ptr: *mut libc::c_void);
    #[no_mangle]
    fn strcmp(_: *const libc::c_char, _: *const libc::c_char) -> libc::c_int;
    #[no_mangle]
    fn strdup(__s: *const libc::c_char) -> *mut libc::c_char;
    #[no_mangle]
    fn strndup(__string: *const libc::c_char, __n: size_t)
     -> *mut libc::c_char;
    #[no_mangle]
    fn strlen(_: *const libc::c_char) -> libc::c_ulong;
    #[no_mangle]
    fn strerror(_: libc::c_int) -> *mut libc::c_char;
    #[no_mangle]
    fn epoll_create1(__flags: libc::c_int) -> libc::c_int;
    #[no_mangle]
    fn epoll_ctl(__epfd: libc::c_int, __op: libc::c_int, __fd: libc::c_int,
                 __event: *mut epoll_event) -> libc::c_int;
    #[no_mangle]
    fn epoll_wait(__epfd: libc::c_int, __events: *mut epoll_event,
                  __maxevents: libc::c_int, __timeout: libc::c_int)
     -> libc::c_int;
    #[no_mangle]
    fn timerfd_create(__clock_id: __clockid_t, __flags: libc::c_int)
     -> libc::c_int;
    #[no_mangle]
    fn timerfd_settime(__ufd: libc::c_int, __flags: libc::c_int,
                       __utmr: *const itimerspec, __otmr: *mut itimerspec)
     -> libc::c_int;
    #[no_mangle]
    fn read(__fd: libc::c_int, __buf: *mut libc::c_void, __nbytes: size_t)
     -> ssize_t;
    #[no_mangle]
    fn wl_proxy_marshal(p: *mut wl_proxy, opcode: uint32_t, _: ...);
    #[no_mangle]
    fn wl_proxy_marshal_constructor(proxy: *mut wl_proxy, opcode: uint32_t,
                                    interface: *const wl_interface, _: ...)
     -> *mut wl_proxy;
    #[no_mangle]
    fn wl_proxy_marshal_constructor_versioned(proxy: *mut wl_proxy,
                                              opcode: uint32_t,
                                              interface: *const wl_interface,
                                              version: uint32_t, _: ...)
     -> *mut wl_proxy;
    #[no_mangle]
    fn wl_proxy_destroy(proxy: *mut wl_proxy);
    #[no_mangle]
    fn wl_proxy_add_listener(proxy: *mut wl_proxy,
                             implementation:
                                 *mut Option<unsafe extern "C" fn() -> ()>,
                             data: *mut libc::c_void) -> libc::c_int;
    #[no_mangle]
    fn wl_display_connect(name: *const libc::c_char) -> *mut wl_display;
    #[no_mangle]
    fn wl_display_get_fd(display_0: *mut wl_display) -> libc::c_int;
    #[no_mangle]
    fn wl_display_dispatch(display_0: *mut wl_display) -> libc::c_int;
    #[no_mangle]
    fn wl_display_roundtrip(display_0: *mut wl_display) -> libc::c_int;
    #[no_mangle]
    static wl_registry_interface: wl_interface;
    #[no_mangle]
    static wl_compositor_interface: wl_interface;
    #[no_mangle]
    static wl_seat_interface: wl_interface;
    /* *
 * @page page_iface_zwp_input_method_v2 zwp_input_method_v2
 * @section page_iface_zwp_input_method_v2_desc Description
 *
 * An input method object allows for clients to compose text.
 *
 * The objects connects the client to a text input in an application, and
 * lets the client to serve as an input method for a seat.
 *
 * The zwp_input_method_v2 object can occupy two distinct states: active and
 * inactive. In the active state, the object is associated to and
 * communicates with a text input. In the inactive state, there is no
 * associated text input, and the only communication is with the compositor.
 * Initially, the input method is in the inactive state.
 *
 * Requests issued in the inactive state must be accepted by the compositor.
 * Because of the serial mechanism, and the state reset on activate event,
 * they will not have any effect on the state of the next text input.
 *
 * There must be no more than one input method object per seat.
 * @section page_iface_zwp_input_method_v2_api API
 * See @ref iface_zwp_input_method_v2.
 */
/* *
 * @defgroup iface_zwp_input_method_v2 The zwp_input_method_v2 interface
 *
 * An input method object allows for clients to compose text.
 *
 * The objects connects the client to a text input in an application, and
 * lets the client to serve as an input method for a seat.
 *
 * The zwp_input_method_v2 object can occupy two distinct states: active and
 * inactive. In the active state, the object is associated to and
 * communicates with a text input. In the inactive state, there is no
 * associated text input, and the only communication is with the compositor.
 * Initially, the input method is in the inactive state.
 *
 * Requests issued in the inactive state must be accepted by the compositor.
 * Because of the serial mechanism, and the state reset on activate event,
 * they will not have any effect on the state of the next text input.
 *
 * There must be no more than one input method object per seat.
 */
    #[no_mangle]
    static zwp_input_method_v2_interface: wl_interface;
    /* *
 * @page page_iface_zwp_input_method_manager_v2 zwp_input_method_manager_v2
 * @section page_iface_zwp_input_method_manager_v2_desc Description
 *
 * The input method manager allows the client to become the input method on
 * a chosen seat.
 *
 * No more than one input method must be associated with any seat at any
 * given time.
 * @section page_iface_zwp_input_method_manager_v2_api API
 * See @ref iface_zwp_input_method_manager_v2.
 */
/* *
 * @defgroup iface_zwp_input_method_manager_v2 The zwp_input_method_manager_v2 interface
 *
 * The input method manager allows the client to become the input method on
 * a chosen seat.
 *
 * No more than one input method must be associated with any seat at any
 * given time.
 */
    #[no_mangle]
    static zwp_input_method_manager_v2_interface: wl_interface;
}
pub type size_t = libc::c_ulong;
pub type __int32_t = libc::c_int;
pub type __uint32_t = libc::c_uint;
pub type __uint64_t = libc::c_ulong;
pub type __off_t = libc::c_long;
pub type __off64_t = libc::c_long;
pub type __time_t = libc::c_long;
pub type __clockid_t = libc::c_int;
pub type __ssize_t = libc::c_long;
pub type __syscall_slong_t = libc::c_long;
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct _IO_FILE {
    pub _flags: libc::c_int,
    pub _IO_read_ptr: *mut libc::c_char,
    pub _IO_read_end: *mut libc::c_char,
    pub _IO_read_base: *mut libc::c_char,
    pub _IO_write_base: *mut libc::c_char,
    pub _IO_write_ptr: *mut libc::c_char,
    pub _IO_write_end: *mut libc::c_char,
    pub _IO_buf_base: *mut libc::c_char,
    pub _IO_buf_end: *mut libc::c_char,
    pub _IO_save_base: *mut libc::c_char,
    pub _IO_backup_base: *mut libc::c_char,
    pub _IO_save_end: *mut libc::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: libc::c_int,
    pub _flags2: libc::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: libc::c_ushort,
    pub _vtable_offset: libc::c_schar,
    pub _shortbuf: [libc::c_char; 1],
    pub _lock: *mut libc::c_void,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut libc::c_void,
    pub __pad5: size_t,
    pub _mode: libc::c_int,
    pub _unused2: [libc::c_char; 20],
}
pub type _IO_lock_t = ();
pub type FILE = _IO_FILE;
pub type ssize_t = __ssize_t;
pub type int32_t = __int32_t;
pub type uint32_t = __uint32_t;
pub type uint64_t = __uint64_t;
pub type C2RustUnnamed = libc::c_uint;
pub const EPOLL_CLOEXEC: C2RustUnnamed = 524288;
pub type EPOLL_EVENTS = libc::c_uint;
pub const EPOLLET: EPOLL_EVENTS = 2147483648;
pub const EPOLLONESHOT: EPOLL_EVENTS = 1073741824;
pub const EPOLLWAKEUP: EPOLL_EVENTS = 536870912;
pub const EPOLLEXCLUSIVE: EPOLL_EVENTS = 268435456;
pub const EPOLLRDHUP: EPOLL_EVENTS = 8192;
pub const EPOLLHUP: EPOLL_EVENTS = 16;
pub const EPOLLERR: EPOLL_EVENTS = 8;
pub const EPOLLMSG: EPOLL_EVENTS = 1024;
pub const EPOLLWRBAND: EPOLL_EVENTS = 512;
pub const EPOLLWRNORM: EPOLL_EVENTS = 256;
pub const EPOLLRDBAND: EPOLL_EVENTS = 128;
pub const EPOLLRDNORM: EPOLL_EVENTS = 64;
pub const EPOLLOUT: EPOLL_EVENTS = 4;
pub const EPOLLPRI: EPOLL_EVENTS = 2;
pub const EPOLLIN: EPOLL_EVENTS = 1;
#[derive ( Copy, Clone )]
#[repr ( C )]
pub union epoll_data {
    pub ptr: *mut libc::c_void,
    pub fd: libc::c_int,
    pub u32_0: uint32_t,
    pub u64_0: uint64_t,
}
pub type epoll_data_t = epoll_data;
#[derive ( Copy, Clone )]
#[repr(C, packed)]
pub struct epoll_event {
    pub events: uint32_t,
    pub data: epoll_data_t,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
pub type C2RustUnnamed_0 = libc::c_uint;
pub const TFD_NONBLOCK: C2RustUnnamed_0 = 2048;
pub const TFD_CLOEXEC: C2RustUnnamed_0 = 524288;
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wl_message {
    pub name: *const libc::c_char,
    pub signature: *const libc::c_char,
    pub types: *mut *const wl_interface,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wl_interface {
    pub name: *const libc::c_char,
    pub version: libc::c_int,
    pub method_count: libc::c_int,
    pub methods: *const wl_message,
    pub event_count: libc::c_int,
    pub events: *const wl_message,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wl_registry_listener {
    pub global: Option<unsafe extern "C" fn(_: *mut libc::c_void,
                                            _: *mut wl_registry, _: uint32_t,
                                            _: *const libc::c_char,
                                            _: uint32_t) -> ()>,
    pub global_remove: Option<unsafe extern "C" fn(_: *mut libc::c_void,
                                                   _: *mut wl_registry,
                                                   _: uint32_t) -> ()>,
}
/* *
 * @ingroup iface_zwp_input_method_v2
 * @struct zwp_input_method_v2_listener
 */
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct zwp_input_method_v2_listener {
    pub activate: Option<unsafe extern "C" fn(_: *mut libc::c_void,
                                              _: *mut zwp_input_method_v2)
                             -> ()>,
    pub deactivate: Option<unsafe extern "C" fn(_: *mut libc::c_void,
                                                _: *mut zwp_input_method_v2)
                               -> ()>,
    pub surrounding_text: Option<unsafe extern "C" fn(_: *mut libc::c_void,
                                                      _:
                                                          *mut zwp_input_method_v2,
                                                      _: *const libc::c_char,
                                                      _: uint32_t,
                                                      _: uint32_t) -> ()>,
    pub text_change_cause: Option<unsafe extern "C" fn(_: *mut libc::c_void,
                                                       _:
                                                           *mut zwp_input_method_v2,
                                                       _: uint32_t) -> ()>,
    pub content_type: Option<unsafe extern "C" fn(_: *mut libc::c_void,
                                                  _: *mut zwp_input_method_v2,
                                                  _: uint32_t, _: uint32_t)
                                 -> ()>,
    pub done: Option<unsafe extern "C" fn(_: *mut libc::c_void,
                                          _: *mut zwp_input_method_v2) -> ()>,
    pub unavailable: Option<unsafe extern "C" fn(_: *mut libc::c_void,
                                                 _: *mut zwp_input_method_v2)
                                -> ()>,
}
/* *
 * @ingroup iface_zwp_text_input_v3
 * text change reason
 *
 * Reason for the change of surrounding text or cursor posision.
 */
pub type zwp_text_input_v3_change_cause = libc::c_uint;
/* *
	 * something else than the input method caused the change
	 */
pub const ZWP_TEXT_INPUT_V3_CHANGE_CAUSE_OTHER: zwp_text_input_v3_change_cause
          =
    1;
/* *
	 * input method caused the change
	 */
pub const ZWP_TEXT_INPUT_V3_CHANGE_CAUSE_INPUT_METHOD:
          zwp_text_input_v3_change_cause =
    0;
/* ZWP_TEXT_INPUT_V3_CHANGE_CAUSE_ENUM */
/* *
 * @ingroup iface_zwp_text_input_v3
 * content hint
 *
 * Content hint is a bitmask to allow to modify the behavior of the text
 * input.
 */
pub type zwp_text_input_v3_content_hint = libc::c_uint;
/* *
	 * the text input is multiline
	 */
pub const ZWP_TEXT_INPUT_V3_CONTENT_HINT_MULTILINE:
          zwp_text_input_v3_content_hint =
    512;
/* *
	 * just Latin characters should be entered
	 */
pub const ZWP_TEXT_INPUT_V3_CONTENT_HINT_LATIN: zwp_text_input_v3_content_hint
          =
    256;
/* *
	 * typed text should not be stored
	 */
pub const ZWP_TEXT_INPUT_V3_CONTENT_HINT_SENSITIVE_DATA:
          zwp_text_input_v3_content_hint =
    128;
/* *
	 * characters should be hidden
	 */
pub const ZWP_TEXT_INPUT_V3_CONTENT_HINT_HIDDEN_TEXT:
          zwp_text_input_v3_content_hint =
    64;
/* *
	 * prefer casing for titles and headings (can be language dependent)
	 */
pub const ZWP_TEXT_INPUT_V3_CONTENT_HINT_TITLECASE:
          zwp_text_input_v3_content_hint =
    32;
/* *
	 * prefer uppercase letters
	 */
pub const ZWP_TEXT_INPUT_V3_CONTENT_HINT_UPPERCASE:
          zwp_text_input_v3_content_hint =
    16;
/* *
	 * prefer lowercase letters
	 */
pub const ZWP_TEXT_INPUT_V3_CONTENT_HINT_LOWERCASE:
          zwp_text_input_v3_content_hint =
    8;
/* *
	 * switch to uppercase letters at the start of a sentence
	 */
pub const ZWP_TEXT_INPUT_V3_CONTENT_HINT_AUTO_CAPITALIZATION:
          zwp_text_input_v3_content_hint =
    4;
/* *
	 * suggest word corrections
	 */
pub const ZWP_TEXT_INPUT_V3_CONTENT_HINT_SPELLCHECK:
          zwp_text_input_v3_content_hint =
    2;
/* *
	 * suggest word completions
	 */
pub const ZWP_TEXT_INPUT_V3_CONTENT_HINT_COMPLETION:
          zwp_text_input_v3_content_hint =
    1;
/* *
	 * no special behavior
	 */
pub const ZWP_TEXT_INPUT_V3_CONTENT_HINT_NONE: zwp_text_input_v3_content_hint
          =
    0;
/* ZWP_TEXT_INPUT_V3_CONTENT_HINT_ENUM */
/* *
 * @ingroup iface_zwp_text_input_v3
 * content purpose
 *
 * The content purpose allows to specify the primary purpose of a text
 * input.
 *
 * This allows an input method to show special purpose input panels with
 * extra characters or to disallow some characters.
 */
pub type zwp_text_input_v3_content_purpose = libc::c_uint;
/* *
	 * input for a terminal
	 */
pub const ZWP_TEXT_INPUT_V3_CONTENT_PURPOSE_TERMINAL:
          zwp_text_input_v3_content_purpose =
    13;
/* *
	 * input a date and time
	 */
pub const ZWP_TEXT_INPUT_V3_CONTENT_PURPOSE_DATETIME:
          zwp_text_input_v3_content_purpose =
    12;
/* *
	 * input a time
	 */
pub const ZWP_TEXT_INPUT_V3_CONTENT_PURPOSE_TIME:
          zwp_text_input_v3_content_purpose =
    11;
/* *
	 * input a date
	 */
pub const ZWP_TEXT_INPUT_V3_CONTENT_PURPOSE_DATE:
          zwp_text_input_v3_content_purpose =
    10;
/* *
	 * input is a numeric password (combine with sensitive_data hint)
	 */
pub const ZWP_TEXT_INPUT_V3_CONTENT_PURPOSE_PIN:
          zwp_text_input_v3_content_purpose =
    9;
/* *
	 * input a password (combine with sensitive_data hint)
	 */
pub const ZWP_TEXT_INPUT_V3_CONTENT_PURPOSE_PASSWORD:
          zwp_text_input_v3_content_purpose =
    8;
/* *
	 * input a name of a person
	 */
pub const ZWP_TEXT_INPUT_V3_CONTENT_PURPOSE_NAME:
          zwp_text_input_v3_content_purpose =
    7;
/* *
	 * input an email address
	 */
pub const ZWP_TEXT_INPUT_V3_CONTENT_PURPOSE_EMAIL:
          zwp_text_input_v3_content_purpose =
    6;
/* *
	 * input an URL
	 */
pub const ZWP_TEXT_INPUT_V3_CONTENT_PURPOSE_URL:
          zwp_text_input_v3_content_purpose =
    5;
/* *
	 * input a phone number
	 */
pub const ZWP_TEXT_INPUT_V3_CONTENT_PURPOSE_PHONE:
          zwp_text_input_v3_content_purpose =
    4;
/* *
	 * input a number (including decimal separator and sign)
	 */
pub const ZWP_TEXT_INPUT_V3_CONTENT_PURPOSE_NUMBER:
          zwp_text_input_v3_content_purpose =
    3;
/* *
	 * allow only digits
	 */
pub const ZWP_TEXT_INPUT_V3_CONTENT_PURPOSE_DIGITS:
          zwp_text_input_v3_content_purpose =
    2;
/* *
	 * allow only alphabetic characters
	 */
pub const ZWP_TEXT_INPUT_V3_CONTENT_PURPOSE_ALPHA:
          zwp_text_input_v3_content_purpose =
    1;
/* *
	 * default input, allowing all characters
	 */
pub const ZWP_TEXT_INPUT_V3_CONTENT_PURPOSE_NORMAL:
          zwp_text_input_v3_content_purpose =
    0;
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct input_method_state {
    pub change_cause: zwp_text_input_v3_change_cause,
    pub content_type: C2RustUnnamed_2,
    pub surrounding: C2RustUnnamed_1,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct C2RustUnnamed_1 {
    pub text: *mut libc::c_char,
    pub cursor: uint32_t,
    pub anchor: uint32_t,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct C2RustUnnamed_2 {
    pub hint: zwp_text_input_v3_content_hint,
    pub purpose: zwp_text_input_v3_content_purpose,
}
#[inline]
unsafe extern "C" fn wl_display_get_registry(mut wl_display: *mut wl_display)
 -> *mut wl_registry {
    let mut registry: *mut wl_proxy = 0 as *mut wl_proxy;
    registry =
        wl_proxy_marshal_constructor(wl_display as *mut wl_proxy,
                                     1i32 as uint32_t,
                                     &wl_registry_interface as
                                         *const wl_interface,
                                     0 as *mut libc::c_void);
    return registry as *mut wl_registry;
}
#[inline]
unsafe extern "C" fn wl_registry_add_listener(mut wl_registry:
                                                  *mut wl_registry,
                                              mut listener:
                                                  *const wl_registry_listener,
                                              mut data: *mut libc::c_void)
 -> libc::c_int {
    return wl_proxy_add_listener(wl_registry as *mut wl_proxy,
                                 listener as
                                     *mut Option<unsafe extern "C" fn()
                                                     -> ()>, data);
}
#[inline]
unsafe extern "C" fn wl_registry_bind(mut wl_registry: *mut wl_registry,
                                      mut name: uint32_t,
                                      mut interface: *const wl_interface,
                                      mut version: uint32_t)
 -> *mut libc::c_void {
    let mut id: *mut wl_proxy = 0 as *mut wl_proxy;
    id =
        wl_proxy_marshal_constructor_versioned(wl_registry as *mut wl_proxy,
                                               0i32 as uint32_t, interface,
                                               version, name,
                                               (*interface).name, version,
                                               0 as *mut libc::c_void);
    return id as *mut libc::c_void;
}
/* *
 * @ingroup iface_zwp_input_method_v2
 */
#[inline]
unsafe extern "C" fn zwp_input_method_v2_add_listener(mut zwp_input_method_v2:
                                                          *mut zwp_input_method_v2,
                                                      mut listener:
                                                          *const zwp_input_method_v2_listener,
                                                      mut data:
                                                          *mut libc::c_void)
 -> libc::c_int {
    return wl_proxy_add_listener(zwp_input_method_v2 as *mut wl_proxy,
                                 listener as
                                     *mut Option<unsafe extern "C" fn()
                                                     -> ()>, data);
}
/* *
 * @ingroup iface_zwp_input_method_v2
 *
 * Send the commit string text for insertion to the application.
 *
 * Inserts a string at current cursor position (see commit event
 * sequence). The string to commit could be either just a single character
 * after a key press or the result of some composing.
 *
 * The argument text is a buffer containing the string to insert. There is
 * a maximum length of wayland messages, so text can not be longer than
 * 4000 bytes.
 *
 * Values set with this event are double-buffered. They must be applied
 * and reset to initial on the next zwp_text_input_v3.commit request.
 *
 * The initial value of text is an empty string.
 */
#[inline]
unsafe extern "C" fn zwp_input_method_v2_commit_string(mut zwp_input_method_v2:
                                                           *mut zwp_input_method_v2,
                                                       mut text:
                                                           *const libc::c_char) {
    wl_proxy_marshal(zwp_input_method_v2 as *mut wl_proxy, 0i32 as uint32_t,
                     text);
}
/* *
 * @ingroup iface_zwp_input_method_v2
 *
 * Send the pre-edit string text to the application text input.
 *
 * Place a new composing text (pre-edit) at the current cursor position.
 * Any previously set composing text must be removed. Any previously
 * existing selected text must be removed. The cursor is moved to a new
 * position within the preedit string.
 *
 * The argument text is a buffer containing the preedit string. There is
 * a maximum length of wayland messages, so text can not be longer than
 * 4000 bytes.
 *
 * The arguments cursor_begin and cursor_end are counted in bytes relative
 * to the beginning of the submitted string buffer. Cursor should be
 * hidden by the text input when both are equal to -1.
 *
 * cursor_begin indicates the beginning of the cursor. cursor_end
 * indicates the end of the cursor. It may be equal or different than
 * cursor_begin.
 *
 * Values set with this event are double-buffered. They must be applied on
 * the next zwp_input_method_v2.commit event.
 *
 * The initial value of text is an empty string. The initial value of
 * cursor_begin, and cursor_end are both 0.
 */
#[inline]
unsafe extern "C" fn zwp_input_method_v2_set_preedit_string(mut zwp_input_method_v2:
                                                                *mut zwp_input_method_v2,
                                                            mut text:
                                                                *const libc::c_char,
                                                            mut cursor_begin:
                                                                int32_t,
                                                            mut cursor_end:
                                                                int32_t) {
    wl_proxy_marshal(zwp_input_method_v2 as *mut wl_proxy, 1i32 as uint32_t,
                     text, cursor_begin, cursor_end);
}
/* *
 * @ingroup iface_zwp_input_method_v2
 *
 * Remove the surrounding text.
 *
 * before_length and after_length are the number of bytes before and after
 * the current cursor index (excluding the preedit text) to delete.
 *
 * If any preedit text is present, it is replaced with the cursor for the
 * purpose of this event. In effect before_length is counted from the
 * beginning of preedit text, and after_length from its end (see commit
 * event sequence).
 *
 * Values set with this event are double-buffered. They must be applied
 * and reset to initial on the next zwp_input_method_v2.commit request.
 *
 * The initial values of both before_length and after_length are 0.
 */
#[inline]
unsafe extern "C" fn zwp_input_method_v2_delete_surrounding_text(mut zwp_input_method_v2:
                                                                     *mut zwp_input_method_v2,
                                                                 mut before_length:
                                                                     uint32_t,
                                                                 mut after_length:
                                                                     uint32_t) {
    wl_proxy_marshal(zwp_input_method_v2 as *mut wl_proxy, 2i32 as uint32_t,
                     before_length, after_length);
}
/* *
 * @ingroup iface_zwp_input_method_v2
 *
 * Apply state changes from commit_string, set_preedit_string and
 * delete_surrounding_text requests.
 *
 * The state relating to these events is double-buffered, and each one
 * modifies the pending state. This request replaces the current state
 * with the pending state.
 *
 * The connected text input is expected to proceed by evaluating the
 * changes in the following order:
 *
 * 1. Replace existing preedit string with the cursor.
 * 2. Delete requested surrounding text.
 * 3. Insert commit string with the cursor at its end.
 * 4. Calculate surrounding text to send.
 * 5. Insert new preedit text in cursor position.
 * 6. Place cursor inside preedit text.
 *
 * The serial number reflects the last state of the zwp_input_method_v2
 * object known to the client. The value of the serial argument must be
 * equal to the number of done events already issued by that object. When
 * the compositor receives a commit request with a serial different than
 * the number of past done events, it must proceed as normal, except it
 * should not change the current state of the zwp_input_method_v2 object.
 */
#[inline]
unsafe extern "C" fn zwp_input_method_v2_commit(mut zwp_input_method_v2:
                                                    *mut zwp_input_method_v2,
                                                mut serial_0: uint32_t) {
    wl_proxy_marshal(zwp_input_method_v2 as *mut wl_proxy, 3i32 as uint32_t,
                     serial_0);
}
/* *
 * @ingroup iface_zwp_input_method_v2
 *
 * Destroys the zwp_text_input_v2 object and any associated child
 * objects, i.e. zwp_input_popup_surface_v2 and
 * zwp_input_method_keyboard_grab_v2.
 */
#[inline]
unsafe extern "C" fn zwp_input_method_v2_destroy(mut zwp_input_method_v2:
                                                     *mut zwp_input_method_v2) {
    wl_proxy_marshal(zwp_input_method_v2 as *mut wl_proxy, 6i32 as uint32_t);
    wl_proxy_destroy(zwp_input_method_v2 as *mut wl_proxy);
}
/* *
 * @ingroup iface_zwp_input_method_manager_v2
 *
 * Request a new input zwp_input_method_v2 object associated with a given
 * seat.
 */
#[inline]
unsafe extern "C" fn zwp_input_method_manager_v2_get_input_method(mut zwp_input_method_manager_v2:
                                                                      *mut zwp_input_method_manager_v2,
                                                                  mut seat_0:
                                                                      *mut wl_seat)
 -> *mut zwp_input_method_v2 {
    let mut input_method_0: *mut wl_proxy = 0 as *mut wl_proxy;
    input_method_0 =
        wl_proxy_marshal_constructor(zwp_input_method_manager_v2 as
                                         *mut wl_proxy, 0i32 as uint32_t,
                                     &zwp_input_method_v2_interface as
                                         *const wl_interface, seat_0,
                                     0 as *mut libc::c_void);
    return input_method_0 as *mut zwp_input_method_v2;
}
#[no_mangle]
pub static mut usage: [libc::c_char; 334] =
    [85, 115, 97, 103, 101, 58, 32, 105, 110, 112, 117, 116, 45, 109, 101,
     116, 104, 111, 100, 32, 91, 115, 101, 99, 111, 110, 100, 115, 93, 10, 10,
     67, 114, 101, 97, 116, 101, 115, 32, 97, 110, 32, 105, 110, 112, 117,
     116, 32, 109, 101, 116, 104, 111, 100, 32, 117, 115, 105, 110, 103, 32,
     116, 104, 101, 32, 105, 110, 112, 117, 116, 45, 109, 101, 116, 104, 111,
     100, 32, 112, 114, 111, 116, 111, 99, 111, 108, 46, 10, 10, 87, 104, 101,
     110, 101, 118, 101, 114, 32, 97, 32, 116, 101, 120, 116, 32, 105, 110,
     112, 117, 116, 32, 105, 115, 32, 97, 99, 116, 105, 118, 97, 116, 101,
     100, 44, 32, 116, 104, 105, 115, 32, 112, 114, 111, 103, 114, 97, 109,
     32, 115, 101, 110, 100, 115, 32, 97, 32, 102, 101, 119, 32, 115, 101,
     113, 117, 101, 110, 99, 101, 115, 32, 111, 102, 10, 99, 111, 109, 109,
     97, 110, 100, 115, 32, 97, 110, 100, 32, 99, 104, 101, 99, 107, 115, 32,
     116, 104, 101, 32, 118, 97, 108, 105, 100, 105, 116, 121, 32, 111, 102,
     32, 116, 104, 101, 32, 114, 101, 115, 112, 111, 110, 115, 101, 115, 44,
     32, 114, 101, 108, 121, 105, 110, 103, 32, 111, 110, 32, 114, 101, 116,
     117, 114, 110, 101, 100, 10, 115, 117, 114, 114, 111, 117, 110, 100, 105,
     110, 103, 32, 116, 101, 120, 116, 46, 10, 10, 84, 104, 101, 32, 34, 115,
     101, 99, 111, 110, 100, 115, 34, 32, 97, 114, 103, 117, 109, 101, 110,
     116, 32, 105, 115, 32, 111, 112, 116, 105, 111, 110, 97, 108, 32, 97,
     110, 100, 32, 100, 101, 102, 105, 110, 101, 115, 32, 116, 104, 101, 32,
     109, 97, 120, 105, 109, 117, 109, 32, 100, 101, 108, 97, 121, 32, 98,
     101, 116, 119, 101, 101, 110, 10, 115, 116, 97, 103, 101, 115, 46, 0];
static mut sleeptime: libc::c_int = 0i32;
static mut display: *mut wl_display =
    0 as *const wl_display as *mut wl_display;
static mut compositor: *mut wl_compositor =
    0 as *const wl_compositor as *mut wl_compositor;
static mut seat: *mut wl_seat = 0 as *const wl_seat as *mut wl_seat;
static mut input_method_manager: *mut zwp_input_method_manager_v2 =
    0 as *const zwp_input_method_manager_v2 as
        *mut zwp_input_method_manager_v2;
static mut input_method: *mut zwp_input_method_v2 =
    0 as *const zwp_input_method_v2 as *mut zwp_input_method_v2;
#[no_mangle]
pub static mut pending: input_method_state =
    input_method_state{change_cause:
                           ZWP_TEXT_INPUT_V3_CHANGE_CAUSE_INPUT_METHOD,
                       content_type:
                           C2RustUnnamed_2{hint:
                                               ZWP_TEXT_INPUT_V3_CONTENT_HINT_NONE,
                                           purpose:
                                               ZWP_TEXT_INPUT_V3_CONTENT_PURPOSE_NORMAL,},
                       surrounding:
                           C2RustUnnamed_1{text:
                                               0 as *const libc::c_char as
                                                   *mut libc::c_char,
                                           cursor: 0,
                                           anchor: 0,},};
#[no_mangle]
pub static mut current: input_method_state =
    input_method_state{change_cause:
                           ZWP_TEXT_INPUT_V3_CHANGE_CAUSE_INPUT_METHOD,
                       content_type:
                           C2RustUnnamed_2{hint:
                                               ZWP_TEXT_INPUT_V3_CONTENT_HINT_NONE,
                                           purpose:
                                               ZWP_TEXT_INPUT_V3_CONTENT_PURPOSE_NORMAL,},
                       surrounding:
                           C2RustUnnamed_1{text:
                                               0 as *const libc::c_char as
                                                   *mut libc::c_char,
                                           cursor: 0,
                                           anchor: 0,},};
static mut serial: uint32_t = 0i32 as uint32_t;
#[no_mangle]
pub static mut active: bool = 0i32 != 0;
#[no_mangle]
pub static mut pending_active: bool = 0i32 != 0;
#[no_mangle]
pub static mut unavailable: bool = 0i32 != 0;
#[no_mangle]
pub static mut running: bool = 0i32 != 0;
#[no_mangle]
pub static mut update_stage: uint32_t = 0i32 as uint32_t;
#[no_mangle]
pub static mut timer_fd: libc::c_int = 0i32;
unsafe extern "C" fn print_state_diff(mut previous: input_method_state,
                                      mut future: input_method_state) {
    if previous.content_type.hint as libc::c_uint !=
           future.content_type.hint as libc::c_uint {
        let mut strs: [*const libc::c_char; 10] =
            [b"COMPLETION\x00" as *const u8 as *const libc::c_char,
             b"SPELLCHECK\x00" as *const u8 as *const libc::c_char,
             b"AUTO_CAPITALIZATION\x00" as *const u8 as *const libc::c_char,
             b"LOWERCASE\x00" as *const u8 as *const libc::c_char,
             b"UPPERCASE\x00" as *const u8 as *const libc::c_char,
             b"TITLECASE\x00" as *const u8 as *const libc::c_char,
             b"HIDDEN_TEXT\x00" as *const u8 as *const libc::c_char,
             b"SENSITIVE_DATA\x00" as *const u8 as *const libc::c_char,
             b"LATIN\x00" as *const u8 as *const libc::c_char,
             b"MULTILINE\x00" as *const u8 as *const libc::c_char];
        printf(b"content_type.hint:\x00" as *const u8 as *const libc::c_char);
        let mut hint: uint32_t = future.content_type.hint as uint32_t;
        if hint == 0 {
            printf(b" NONE\x00" as *const u8 as *const libc::c_char);
        }
        let mut i: libc::c_uint = 0i32 as libc::c_uint;
        while (i as libc::c_ulong) <
                  (::std::mem::size_of::<[*const libc::c_char; 10]>() as
                       libc::c_ulong).wrapping_div(::std::mem::size_of::<*const libc::c_char>()
                                                       as libc::c_ulong) {
            if hint & (1i32 << i) as libc::c_uint != 0 {
                printf(b" %s\x00" as *const u8 as *const libc::c_char,
                       strs[i as usize]);
            }
            i = i.wrapping_add(1)
        }
        printf(b"\n\x00" as *const u8 as *const libc::c_char);
    }
    if previous.content_type.purpose as libc::c_uint !=
           future.content_type.purpose as libc::c_uint {
        let mut strs_0: [*const libc::c_char; 14] =
            [b"NORMAL\x00" as *const u8 as *const libc::c_char,
             b"ALPHA\x00" as *const u8 as *const libc::c_char,
             b"DIGITS\x00" as *const u8 as *const libc::c_char,
             b"NUMBER\x00" as *const u8 as *const libc::c_char,
             b"PHONE\x00" as *const u8 as *const libc::c_char,
             b"URL\x00" as *const u8 as *const libc::c_char,
             b"EMAIL\x00" as *const u8 as *const libc::c_char,
             b"NAME\x00" as *const u8 as *const libc::c_char,
             b"PASSWORD\x00" as *const u8 as *const libc::c_char,
             b"PIN\x00" as *const u8 as *const libc::c_char,
             b"DATE\x00" as *const u8 as *const libc::c_char,
             b"TIME\x00" as *const u8 as *const libc::c_char,
             b"DATETIME\x00" as *const u8 as *const libc::c_char,
             b"TERMINAL\x00" as *const u8 as *const libc::c_char];
        printf(b"content_type.purpose: %s\n\x00" as *const u8 as
                   *const libc::c_char,
               strs_0[future.content_type.purpose as usize]);
    }
    if !previous.surrounding.text.is_null() as libc::c_int !=
           !future.surrounding.text.is_null() as libc::c_int ||
           !previous.surrounding.text.is_null() &&
               !future.surrounding.text.is_null() &&
               strcmp(previous.surrounding.text, future.surrounding.text) !=
                   0i32 ||
           previous.surrounding.anchor != future.surrounding.anchor ||
           previous.surrounding.cursor != future.surrounding.cursor {
        let mut text: *mut libc::c_char = future.surrounding.text;
        if text.is_null() {
            printf(b"Removed surrounding text\n\x00" as *const u8 as
                       *const libc::c_char);
        } else {
            printf(b"Surrounding text: %s\n\x00" as *const u8 as
                       *const libc::c_char, text);
            let mut anchor: uint32_t = future.surrounding.anchor;
            let mut cursor: uint32_t = future.surrounding.cursor;
            if cursor == anchor {
                let mut temp: *mut libc::c_char =
                    strndup(text, cursor as size_t);
                printf(b"Cursor after %d: %s\n\x00" as *const u8 as
                           *const libc::c_char, cursor, temp);
                free(temp as *mut libc::c_void);
            } else {
                if cursor > anchor {
                    let mut tmp: uint32_t = anchor;
                    anchor = cursor;
                    cursor = tmp
                }
                let mut temp_0: *mut libc::c_char =
                    strndup(&mut *text.offset(cursor as isize),
                            anchor.wrapping_sub(cursor) as size_t);
                printf(b"Selection: %s\n\x00" as *const u8 as
                           *const libc::c_char, temp_0);
                free(temp_0 as *mut libc::c_void);
            }
        }
    }
    if previous.change_cause as libc::c_uint !=
           future.change_cause as libc::c_uint {
        let mut strs_1: [*const libc::c_char; 2] =
            [b"INPUT_METHOD\x00" as *const u8 as *const libc::c_char,
             b"OTHER\x00" as *const u8 as *const libc::c_char];
        printf(b"Change cause: %s\n\x00" as *const u8 as *const libc::c_char,
               strs_1[future.change_cause as usize]);
    };
}
unsafe extern "C" fn handle_content_type(mut data: *mut libc::c_void,
                                         mut zwp_input_method_v2:
                                             *mut zwp_input_method_v2,
                                         mut hint: uint32_t,
                                         mut purpose: uint32_t) {
    pending.content_type.hint = hint as zwp_text_input_v3_content_hint;
    pending.content_type.purpose =
        purpose as zwp_text_input_v3_content_purpose;
}
unsafe extern "C" fn handle_surrounding_text(mut data: *mut libc::c_void,
                                             mut zwp_input_method_v2:
                                                 *mut zwp_input_method_v2,
                                             mut text: *const libc::c_char,
                                             mut cursor: uint32_t,
                                             mut anchor: uint32_t) {
    free(pending.surrounding.text as *mut libc::c_void);
    pending.surrounding.text = strdup(text);
    pending.surrounding.cursor = cursor;
    pending.surrounding.anchor = anchor;
}
unsafe extern "C" fn handle_text_change_cause(mut data: *mut libc::c_void,
                                              mut zwp_input_method_v2:
                                                  *mut zwp_input_method_v2,
                                              mut cause: uint32_t) {
    pending.change_cause = cause as zwp_text_input_v3_change_cause;
}
unsafe extern "C" fn handle_activate(mut data: *mut libc::c_void,
                                     mut zwp_input_method_v2:
                                         *mut zwp_input_method_v2) {
    pending_active = 1i32 != 0;
}
unsafe extern "C" fn handle_deactivate(mut data: *mut libc::c_void,
                                       mut zwp_input_method_v2:
                                           *mut zwp_input_method_v2) {
    pending_active = 0i32 != 0;
}
unsafe extern "C" fn handle_unavailable(mut data: *mut libc::c_void,
                                        mut zwp_input_method_v2:
                                            *mut zwp_input_method_v2) {
    printf(b"IM disappeared\n\x00" as *const u8 as *const libc::c_char);
    zwp_input_method_v2_destroy(zwp_input_method_v2);
    input_method = 0 as *mut zwp_input_method_v2;
    running = 0i32 != 0;
}
unsafe extern "C" fn im_activate(mut data: *mut libc::c_void,
                                 mut id: *mut zwp_input_method_v2) {
    update_stage = 0i32 as uint32_t;
}
unsafe extern "C" fn timer_arm(mut seconds: libc::c_uint) {
    printf(b"Timer armed\n\x00" as *const u8 as *const libc::c_char);
    let mut spec: itimerspec =
        {
            let mut init =
                itimerspec{it_interval:
                               {
                                   let mut init =
                                       timespec{tv_sec: 0i32 as __time_t,
                                                tv_nsec: 0,};
                                   init
                               },
                           it_value:
                               {
                                   let mut init =
                                       timespec{tv_sec: seconds as __time_t,
                                                tv_nsec:
                                                    0i32 as
                                                        __syscall_slong_t,};
                                   init
                               },};
            init
        };
    if timerfd_settime(timer_fd, 0i32, &mut spec, 0 as *mut itimerspec) != 0 {
        fprintf(stderr,
                b"Failed to arm timer: %s\n\x00" as *const u8 as
                    *const libc::c_char, strerror(*__errno_location()));
    };
}
unsafe extern "C" fn do_updates() {
    printf(b"Update %d\n\x00" as *const u8 as *const libc::c_char,
           update_stage);
    match update_stage {
        0 => {
            // TODO: remember initial surrounding text
            zwp_input_method_v2_set_preedit_string(input_method,
                                                   b"Preedit\x00" as *const u8
                                                       as *const libc::c_char,
                                                   2i32, 4i32);
            zwp_input_method_v2_commit(input_method, serial);
            // don't expect an answer, preedit doesn't change anything visible
            timer_arm(sleeptime as libc::c_uint);
            update_stage = update_stage.wrapping_add(1);
            return
        }
        1 => {
            zwp_input_method_v2_set_preedit_string(input_method,
                                                   b"Pr\xc3\xa6edit2\x00" as
                                                       *const u8 as
                                                       *const libc::c_char,
                                                   strlen(b"Pr\x00" as
                                                              *const u8 as
                                                              *const libc::c_char)
                                                       as int32_t,
                                                   strlen(b"Pr\xc3\xa6ed\x00"
                                                              as *const u8 as
                                                              *const libc::c_char)
                                                       as int32_t);
            zwp_input_method_v2_commit_string(input_method,
                                              b"_Commit_\x00" as *const u8 as
                                                  *const libc::c_char);
            zwp_input_method_v2_commit(input_method, serial);
            update_stage = update_stage.wrapping_add(1)
        }
        2 => {
            if strcmp(current.surrounding.text,
                      b"_Commit_\x00" as *const u8 as *const libc::c_char) !=
                   0i32 {
                return
            }
            zwp_input_method_v2_commit_string(input_method,
                                              b"_CommitNoPreed_\x00" as
                                                  *const u8 as
                                                  *const libc::c_char);
            zwp_input_method_v2_commit(input_method, serial);
            timer_arm(sleeptime as libc::c_uint);
            update_stage = update_stage.wrapping_add(1)
        }
        3 => {
            if strcmp(current.surrounding.text,
                      b"_Commit__CommitNoPreed_\x00" as *const u8 as
                          *const libc::c_char) != 0i32 {
                return
            }
            zwp_input_method_v2_commit_string(input_method,
                                              b"_WaitNo_\x00" as *const u8 as
                                                  *const libc::c_char);
            zwp_input_method_v2_delete_surrounding_text(input_method,
                                                        strlen(b"_CommitNoPreed_\x00"
                                                                   as
                                                                   *const u8
                                                                   as
                                                                   *const libc::c_char)
                                                            as uint32_t,
                                                        0i32 as uint32_t);
            zwp_input_method_v2_commit(input_method, serial);
            update_stage = update_stage.wrapping_add(1)
        }
        4 => {
            if strcmp(current.surrounding.text,
                      b"_Commit__WaitNo_\x00" as *const u8 as
                          *const libc::c_char) != 0i32 {
                return
            }
            zwp_input_method_v2_set_preedit_string(input_method,
                                                   b"PreedWithDel\x00" as
                                                       *const u8 as
                                                       *const libc::c_char,
                                                   strlen(b"Preed\x00" as
                                                              *const u8 as
                                                              *const libc::c_char)
                                                       as int32_t,
                                                   strlen(b"Preed\x00" as
                                                              *const u8 as
                                                              *const libc::c_char)
                                                       as int32_t);
            zwp_input_method_v2_delete_surrounding_text(input_method,
                                                        strlen(b"_WaitNo_\x00"
                                                                   as
                                                                   *const u8
                                                                   as
                                                                   *const libc::c_char)
                                                            as uint32_t,
                                                        0i32 as uint32_t);
            zwp_input_method_v2_commit(input_method, serial);
            update_stage = update_stage.wrapping_add(1)
        }
        5 => {
            if strcmp(current.surrounding.text,
                      b"_Commit_\x00" as *const u8 as *const libc::c_char) !=
                   0i32 {
                return
            }
            zwp_input_method_v2_delete_surrounding_text(input_method,
                                                        strlen(b"mit_\x00" as
                                                                   *const u8
                                                                   as
                                                                   *const libc::c_char)
                                                            as uint32_t,
                                                        0i32 as uint32_t);
            zwp_input_method_v2_commit(input_method, serial);
            update_stage = update_stage.wrapping_add(1)
        }
        6 => {
            if strcmp(current.surrounding.text,
                      b"_Com\x00" as *const u8 as *const libc::c_char) != 0i32
               {
                printf(b"Failed\n\x00" as *const u8 as *const libc::c_char);
            }
            update_stage = update_stage.wrapping_add(1)
        }
        _ => {
            printf(b"Submitted everything\n\x00" as *const u8 as
                       *const libc::c_char);
            return
        }
    };
}
unsafe extern "C" fn handle_timer() {
    printf(b"Timer dispatched at %d\n\x00" as *const u8 as
               *const libc::c_char, update_stage);
    do_updates();
}
unsafe extern "C" fn im_deactivate(mut data: *mut libc::c_void,
                                   mut context: *mut zwp_input_method_v2) {
    // No special action needed
}
unsafe extern "C" fn handle_done(mut data: *mut libc::c_void,
                                 mut zwp_input_method_v2:
                                     *mut zwp_input_method_v2) {
    let mut prev_active: bool = active;
    serial = serial.wrapping_add(1);
    printf(b"Handle serial %d\n\x00" as *const u8 as *const libc::c_char,
           serial);
    if active as libc::c_int != pending_active as libc::c_int {
        printf(b"Now %s\n\x00" as *const u8 as *const libc::c_char,
               if pending_active as libc::c_int != 0 {
                   b"active\x00" as *const u8 as *const libc::c_char
               } else {
                   b"inactive\x00" as *const u8 as *const libc::c_char
               });
    }
    if pending_active { print_state_diff(current, pending); }
    active = pending_active;
    free(current.surrounding.text as *mut libc::c_void);
    let mut default_state: input_method_state =
        {
            let mut init =
                input_method_state{change_cause:
                                       ZWP_TEXT_INPUT_V3_CHANGE_CAUSE_INPUT_METHOD,
                                   content_type:
                                       C2RustUnnamed_2{hint:
                                                           ZWP_TEXT_INPUT_V3_CONTENT_HINT_NONE,
                                                       purpose:
                                                           ZWP_TEXT_INPUT_V3_CONTENT_PURPOSE_NORMAL,},
                                   surrounding:
                                       C2RustUnnamed_1{text:
                                                           0 as
                                                               *const libc::c_char
                                                               as
                                                               *mut libc::c_char,
                                                       cursor: 0,
                                                       anchor: 0,},};
            init
        };
    current = pending;
    pending = default_state;
    if active as libc::c_int != 0 && !prev_active {
        im_activate(data, zwp_input_method_v2);
    } else if !active && prev_active as libc::c_int != 0 {
        im_deactivate(data, zwp_input_method_v2);
    }
    do_updates();
}
static mut im_listener: zwp_input_method_v2_listener =
    unsafe {
        {
            let mut init =
                zwp_input_method_v2_listener{activate:
                                                 Some(handle_activate as
                                                          unsafe extern "C" fn(_:
                                                                                   *mut libc::c_void,
                                                                               _:
                                                                                   *mut zwp_input_method_v2)
                                                              -> ()),
                                             deactivate:
                                                 Some(handle_deactivate as
                                                          unsafe extern "C" fn(_:
                                                                                   *mut libc::c_void,
                                                                               _:
                                                                                   *mut zwp_input_method_v2)
                                                              -> ()),
                                             surrounding_text:
                                                 Some(handle_surrounding_text
                                                          as
                                                          unsafe extern "C" fn(_:
                                                                                   *mut libc::c_void,
                                                                               _:
                                                                                   *mut zwp_input_method_v2,
                                                                               _:
                                                                                   *const libc::c_char,
                                                                               _:
                                                                                   uint32_t,
                                                                               _:
                                                                                   uint32_t)
                                                              -> ()),
                                             text_change_cause:
                                                 Some(handle_text_change_cause
                                                          as
                                                          unsafe extern "C" fn(_:
                                                                                   *mut libc::c_void,
                                                                               _:
                                                                                   *mut zwp_input_method_v2,
                                                                               _:
                                                                                   uint32_t)
                                                              -> ()),
                                             content_type:
                                                 Some(handle_content_type as
                                                          unsafe extern "C" fn(_:
                                                                                   *mut libc::c_void,
                                                                               _:
                                                                                   *mut zwp_input_method_v2,
                                                                               _:
                                                                                   uint32_t,
                                                                               _:
                                                                                   uint32_t)
                                                              -> ()),
                                             done:
                                                 Some(handle_done as
                                                          unsafe extern "C" fn(_:
                                                                                   *mut libc::c_void,
                                                                               _:
                                                                                   *mut zwp_input_method_v2)
                                                              -> ()),
                                             unavailable:
                                                 Some(handle_unavailable as
                                                          unsafe extern "C" fn(_:
                                                                                   *mut libc::c_void,
                                                                               _:
                                                                                   *mut zwp_input_method_v2)
                                                              -> ()),};
            init
        }
    };
unsafe extern "C" fn handle_global(mut data: *mut libc::c_void,
                                   mut registry: *mut wl_registry,
                                   mut name: uint32_t,
                                   mut interface: *const libc::c_char,
                                   mut version: uint32_t) {
    if strcmp(interface,
              b"wl_compositor\x00" as *const u8 as *const libc::c_char) ==
           0i32 {
        compositor =
            wl_registry_bind(registry, name, &wl_compositor_interface,
                             1i32 as uint32_t) as *mut wl_compositor
    } else if strcmp(interface, zwp_input_method_manager_v2_interface.name) ==
                  0i32 {
        input_method_manager =
            wl_registry_bind(registry, name,
                             &zwp_input_method_manager_v2_interface,
                             1i32 as uint32_t) as
                *mut zwp_input_method_manager_v2
    } else if strcmp(interface, wl_seat_interface.name) == 0i32 {
        seat =
            wl_registry_bind(registry, name, &wl_seat_interface, version) as
                *mut wl_seat
    };
}
unsafe extern "C" fn handle_global_remove(mut data: *mut libc::c_void,
                                          mut registry: *mut wl_registry,
                                          mut name: uint32_t) {
    // who cares
}
static mut registry_listener: wl_registry_listener =
    unsafe {
        {
            let mut init =
                wl_registry_listener{global:
                                         Some(handle_global as
                                                  unsafe extern "C" fn(_:
                                                                           *mut libc::c_void,
                                                                       _:
                                                                           *mut wl_registry,
                                                                       _:
                                                                           uint32_t,
                                                                       _:
                                                                           *const libc::c_char,
                                                                       _:
                                                                           uint32_t)
                                                      -> ()),
                                     global_remove:
                                         Some(handle_global_remove as
                                                  unsafe extern "C" fn(_:
                                                                           *mut libc::c_void,
                                                                       _:
                                                                           *mut wl_registry,
                                                                       _:
                                                                           uint32_t)
                                                      ->
                                                          ()),}; // timer may be armed here
            init
        }
    };
unsafe fn main_0(mut argc: libc::c_int, mut argv: *mut *mut libc::c_char)
 -> libc::c_int {
    if argc > 1i32 {
        if strcmp(*argv.offset(1),
                  b"--help\x00" as *const u8 as *const libc::c_char) == 0i32
               ||
               strcmp(*argv.offset(1),
                      b"-h\x00" as *const u8 as *const libc::c_char) == 0i32 {
            printf(usage.as_ptr());
            return 0i32
        }
        sleeptime = atoi(*argv.offset(1))
    }
    display = wl_display_connect(0 as *const libc::c_char);
    if display.is_null() {
        fprintf(stderr,
                b"Failed to create display\n\x00" as *const u8 as
                    *const libc::c_char);
        return 1i32
    }
    let mut registry: *mut wl_registry = wl_display_get_registry(display);
    wl_registry_add_listener(registry, &registry_listener,
                             0 as *mut libc::c_void);
    wl_display_dispatch(display);
    wl_display_roundtrip(display);
    if compositor.is_null() {
        fprintf(stderr,
                b"wl-compositor not available\n\x00" as *const u8 as
                    *const libc::c_char);
        return 1i32
    }
    if input_method_manager.is_null() {
        fprintf(stderr,
                b"input-method not available\n\x00" as *const u8 as
                    *const libc::c_char);
        return 1i32
    }
    if seat.is_null() {
        fprintf(stderr,
                b"seat not available\n\x00" as *const u8 as
                    *const libc::c_char);
        return 1i32
    }
    input_method =
        zwp_input_method_manager_v2_get_input_method(input_method_manager,
                                                     seat);
    running = 1i32 != 0;
    zwp_input_method_v2_add_listener(input_method, &im_listener,
                                     0 as *mut libc::c_void);
    let mut display_fd: libc::c_int = wl_display_get_fd(display);
    timer_fd =
        timerfd_create(1i32,
                       TFD_CLOEXEC as libc::c_int |
                           TFD_NONBLOCK as libc::c_int);
    if timer_fd < 0i32 {
        fprintf(stderr,
                b"Failed to start timer\n\x00" as *const u8 as
                    *const libc::c_char);
        return 1i32
    }
    let mut epoll: libc::c_int = epoll_create1(EPOLL_CLOEXEC as libc::c_int);
    if epoll < 0i32 {
        fprintf(stderr,
                b"Failed to start epoll\n\x00" as *const u8 as
                    *const libc::c_char);
        return 1i32
    }
    let mut epoll_display: epoll_event =
        {
            let mut init =
                epoll_event{events:
                                (EPOLLIN as libc::c_int |
                                     EPOLLOUT as libc::c_int) as uint32_t,
                            data: epoll_data{fd: display_fd,},};
            init
        };
    if epoll_ctl(epoll, 1i32, display_fd, &mut epoll_display) != 0 {
        fprintf(stderr,
                b"Failed to epoll display\n\x00" as *const u8 as
                    *const libc::c_char);
        return 1i32
    }
    wl_display_roundtrip(display);
    let mut epoll_timer: epoll_event =
        {
            let mut init =
                epoll_event{events: EPOLLIN as libc::c_int as uint32_t,
                            data: epoll_data{fd: timer_fd,},};
            init
        };
    if epoll_ctl(epoll, 1i32, timer_fd, &mut epoll_timer) != 0 {
        fprintf(stderr,
                b"Failed to epoll timer\n\x00" as *const u8 as
                    *const libc::c_char);
        return 1i32
    }
    timer_arm(2i32 as libc::c_uint);
    let mut caught: epoll_event =
        epoll_event{events: 0,
                    data: epoll_data{ptr: 0 as *mut libc::c_void,},};
    while epoll_wait(epoll, &mut caught, 1i32, -1i32) != 0 {
        if !running {
            printf(b"Exiting\n\x00" as *const u8 as *const libc::c_char);
            return 0i32
        }
        if caught.data.fd == display_fd {
            if wl_display_dispatch(display) == -1i32 { break ; }
        } else if caught.data.fd == timer_fd {
            let mut expirations: uint64_t = 0;
            let mut n: ssize_t =
                read(timer_fd,
                     &mut expirations as *mut uint64_t as *mut libc::c_void,
                     ::std::mem::size_of::<uint64_t>() as libc::c_ulong);
            if n >= 0i32 as libc::c_long {
            } else {
                __assert_fail(b"n >= 0\x00" as *const u8 as
                                  *const libc::c_char,
                              b"../examples/input-method.c\x00" as *const u8
                                  as *const libc::c_char,
                              395i32 as libc::c_uint,
                              (*::std::mem::transmute::<&[u8; 23],
                                                        &[libc::c_char; 23]>(b"int main(int, char **)\x00")).as_ptr());
            };
            handle_timer();
        } else {
            printf(b"Unknown source\n\x00" as *const u8 as
                       *const libc::c_char);
        }
    }
    return 0i32;
}
#[main]
pub fn main() {
    let mut args: Vec<*mut libc::c_char> = Vec::new();
    for arg in ::std::env::args() {
        args.push(::std::ffi::CString::new(arg).expect("Failed to convert argument into CString.").into_raw());
    };
    args.push(::std::ptr::null_mut());
    unsafe {
        ::std::process::exit(main_0((args.len() - 1) as libc::c_int,
                                    args.as_mut_ptr() as
                                        *mut *mut libc::c_char) as i32)
    }
}
