use libc;
extern "C" {
    pub type wl_display;
    /* Generated by wayland-scanner 1.17.0 */
    pub type wl_client;
    pub type wl_global;
    pub type wlr_renderer_impl;
    pub type wlr_texture_impl;
    #[no_mangle]
    fn __assert_fail(__assertion: *const libc::c_char,
                     __file: *const libc::c_char, __line: libc::c_uint,
                     __function: *const libc::c_char) -> !;
    #[no_mangle]
    fn calloc(_: libc::c_ulong, _: libc::c_ulong) -> *mut libc::c_void;
    #[no_mangle]
    fn free(__ptr: *mut libc::c_void);
    #[no_mangle]
    fn lseek(__fd: libc::c_int, __offset: __off64_t, __whence: libc::c_int)
     -> __off64_t;
    #[no_mangle]
    fn close(__fd: libc::c_int) -> libc::c_int;
    #[no_mangle]
    fn wl_list_init(list: *mut wl_list);
    #[no_mangle]
    fn wl_list_insert(list: *mut wl_list, elm: *mut wl_list);
    #[no_mangle]
    fn wl_list_remove(elm: *mut wl_list);
    #[no_mangle]
    fn wl_display_add_destroy_listener(display: *mut wl_display,
                                       listener: *mut wl_listener);
    #[no_mangle]
    fn wl_global_create(display: *mut wl_display,
                        interface: *const wl_interface, version: libc::c_int,
                        data: *mut libc::c_void, bind: wl_global_bind_func_t)
     -> *mut wl_global;
    #[no_mangle]
    fn wl_global_destroy(global: *mut wl_global);
    #[no_mangle]
    fn wl_client_post_no_memory(client: *mut wl_client);
    #[no_mangle]
    fn wl_resource_post_event(resource: *mut wl_resource, opcode: uint32_t,
                              _: ...);
    #[no_mangle]
    fn wl_resource_post_error(resource: *mut wl_resource, code: uint32_t,
                              msg: *const libc::c_char, _: ...);
    #[no_mangle]
    fn wl_resource_post_no_memory(resource: *mut wl_resource);
    #[no_mangle]
    fn wl_resource_create(client: *mut wl_client,
                          interface: *const wl_interface,
                          version: libc::c_int, id: uint32_t)
     -> *mut wl_resource;
    #[no_mangle]
    fn wl_resource_set_implementation(resource: *mut wl_resource,
                                      implementation: *const libc::c_void,
                                      data: *mut libc::c_void,
                                      destroy: wl_resource_destroy_func_t);
    #[no_mangle]
    fn wl_resource_destroy(resource: *mut wl_resource);
    #[no_mangle]
    fn wl_resource_set_user_data(resource: *mut wl_resource,
                                 data: *mut libc::c_void);
    #[no_mangle]
    fn wl_resource_get_user_data(resource: *mut wl_resource)
     -> *mut libc::c_void;
    #[no_mangle]
    fn wl_resource_get_version(resource: *mut wl_resource) -> libc::c_int;
    #[no_mangle]
    fn wl_resource_instance_of(resource: *mut wl_resource,
                               interface: *const wl_interface,
                               implementation: *const libc::c_void)
     -> libc::c_int;
    #[no_mangle]
    static wl_buffer_interface: wl_interface;
    #[no_mangle]
    fn wlr_renderer_get_dmabuf_formats(renderer: *mut wlr_renderer)
     -> *const wlr_drm_format_set;
    /*
 * This an unstable interface of wlroots. No guarantees are made regarding the
 * future consistency of this API.
 */
    /* *
 * Create a new texture from raw pixel data. `stride` is in bytes. The returned
 * texture is mutable.
 */
    /* *
 * Create a new texture from a wl_drm resource. The returned texture is
 * immutable.
 */
    /* *
 * Create a new texture from a DMA-BUF. The returned texture is immutable.
 */
    /* *
 * Get the texture width and height.
 */
    /* *
 * Returns true if this texture is using a fully opaque format.
 */
    /* *
  * Update a texture with raw pixels. The texture must be mutable, and the input
  * data must have the same pixel format that the texture was created with.
  */
    /* *
 * Destroys this wlr_texture.
 */
    #[no_mangle]
    fn wlr_texture_destroy(texture: *mut wlr_texture);
    #[no_mangle]
    fn wlr_texture_from_dmabuf(renderer: *mut wlr_renderer,
                               attribs: *mut wlr_dmabuf_attributes)
     -> *mut wlr_texture;
    /* *
 * Closes all file descriptors in the DMA-BUF attributes.
 */
    #[no_mangle]
    fn wlr_dmabuf_attributes_finish(attribs: *mut wlr_dmabuf_attributes);
    #[no_mangle]
    fn _wlr_log(verbosity: wlr_log_importance, format: *const libc::c_char,
                _: ...);
    /* *
 * @page page_iface_zwp_linux_dmabuf_v1 zwp_linux_dmabuf_v1
 * @section page_iface_zwp_linux_dmabuf_v1_desc Description
 *
 * Following the interfaces from:
 * https://www.khronos.org/registry/egl/extensions/EXT/EGL_EXT_image_dma_buf_import.txt
 * https://www.khronos.org/registry/EGL/extensions/EXT/EGL_EXT_image_dma_buf_import_modifiers.txt
 * and the Linux DRM sub-system's AddFb2 ioctl.
 *
 * This interface offers ways to create generic dmabuf-based
 * wl_buffers. Immediately after a client binds to this interface,
 * the set of supported formats and format modifiers is sent with
 * 'format' and 'modifier' events.
 *
 * The following are required from clients:
 *
 * - Clients must ensure that either all data in the dma-buf is
 * coherent for all subsequent read access or that coherency is
 * correctly handled by the underlying kernel-side dma-buf
 * implementation.
 *
 * - Don't make any more attachments after sending the buffer to the
 * compositor. Making more attachments later increases the risk of
 * the compositor not being able to use (re-import) an existing
 * dmabuf-based wl_buffer.
 *
 * The underlying graphics stack must ensure the following:
 *
 * - The dmabuf file descriptors relayed to the server will stay valid
 * for the whole lifetime of the wl_buffer. This means the server may
 * at any time use those fds to import the dmabuf into any kernel
 * sub-system that might accept it.
 *
 * To create a wl_buffer from one or more dmabufs, a client creates a
 * zwp_linux_dmabuf_params_v1 object with a zwp_linux_dmabuf_v1.create_params
 * request. All planes required by the intended format are added with
 * the 'add' request. Finally, a 'create' or 'create_immed' request is
 * issued, which has the following outcome depending on the import success.
 *
 * The 'create' request,
 * - on success, triggers a 'created' event which provides the final
 * wl_buffer to the client.
 * - on failure, triggers a 'failed' event to convey that the server
 * cannot use the dmabufs received from the client.
 *
 * For the 'create_immed' request,
 * - on success, the server immediately imports the added dmabufs to
 * create a wl_buffer. No event is sent from the server in this case.
 * - on failure, the server can choose to either:
 * - terminate the client by raising a fatal error.
 * - mark the wl_buffer as failed, and send a 'failed' event to the
 * client. If the client uses a failed wl_buffer as an argument to any
 * request, the behaviour is compositor implementation-defined.
 *
 * Warning! The protocol described in this file is experimental and
 * backward incompatible changes may be made. Backward compatible changes
 * may be added together with the corresponding interface version bump.
 * Backward incompatible changes are done by bumping the version number in
 * the protocol and interface names and resetting the interface version.
 * Once the protocol is to be declared stable, the 'z' prefix and the
 * version number in the protocol and interface names are removed and the
 * interface version number is reset.
 * @section page_iface_zwp_linux_dmabuf_v1_api API
 * See @ref iface_zwp_linux_dmabuf_v1.
 */
/* *
 * @defgroup iface_zwp_linux_dmabuf_v1 The zwp_linux_dmabuf_v1 interface
 *
 * Following the interfaces from:
 * https://www.khronos.org/registry/egl/extensions/EXT/EGL_EXT_image_dma_buf_import.txt
 * https://www.khronos.org/registry/EGL/extensions/EXT/EGL_EXT_image_dma_buf_import_modifiers.txt
 * and the Linux DRM sub-system's AddFb2 ioctl.
 *
 * This interface offers ways to create generic dmabuf-based
 * wl_buffers. Immediately after a client binds to this interface,
 * the set of supported formats and format modifiers is sent with
 * 'format' and 'modifier' events.
 *
 * The following are required from clients:
 *
 * - Clients must ensure that either all data in the dma-buf is
 * coherent for all subsequent read access or that coherency is
 * correctly handled by the underlying kernel-side dma-buf
 * implementation.
 *
 * - Don't make any more attachments after sending the buffer to the
 * compositor. Making more attachments later increases the risk of
 * the compositor not being able to use (re-import) an existing
 * dmabuf-based wl_buffer.
 *
 * The underlying graphics stack must ensure the following:
 *
 * - The dmabuf file descriptors relayed to the server will stay valid
 * for the whole lifetime of the wl_buffer. This means the server may
 * at any time use those fds to import the dmabuf into any kernel
 * sub-system that might accept it.
 *
 * To create a wl_buffer from one or more dmabufs, a client creates a
 * zwp_linux_dmabuf_params_v1 object with a zwp_linux_dmabuf_v1.create_params
 * request. All planes required by the intended format are added with
 * the 'add' request. Finally, a 'create' or 'create_immed' request is
 * issued, which has the following outcome depending on the import success.
 *
 * The 'create' request,
 * - on success, triggers a 'created' event which provides the final
 * wl_buffer to the client.
 * - on failure, triggers a 'failed' event to convey that the server
 * cannot use the dmabufs received from the client.
 *
 * For the 'create_immed' request,
 * - on success, the server immediately imports the added dmabufs to
 * create a wl_buffer. No event is sent from the server in this case.
 * - on failure, the server can choose to either:
 * - terminate the client by raising a fatal error.
 * - mark the wl_buffer as failed, and send a 'failed' event to the
 * client. If the client uses a failed wl_buffer as an argument to any
 * request, the behaviour is compositor implementation-defined.
 *
 * Warning! The protocol described in this file is experimental and
 * backward incompatible changes may be made. Backward compatible changes
 * may be added together with the corresponding interface version bump.
 * Backward incompatible changes are done by bumping the version number in
 * the protocol and interface names and resetting the interface version.
 * Once the protocol is to be declared stable, the 'z' prefix and the
 * version number in the protocol and interface names are removed and the
 * interface version number is reset.
 */
    #[no_mangle]
    static zwp_linux_dmabuf_v1_interface: wl_interface;
    /* *
 * @page page_iface_zwp_linux_buffer_params_v1 zwp_linux_buffer_params_v1
 * @section page_iface_zwp_linux_buffer_params_v1_desc Description
 *
 * This temporary object is a collection of dmabufs and other
 * parameters that together form a single logical buffer. The temporary
 * object may eventually create one wl_buffer unless cancelled by
 * destroying it before requesting 'create'.
 *
 * Single-planar formats only require one dmabuf, however
 * multi-planar formats may require more than one dmabuf. For all
 * formats, an 'add' request must be called once per plane (even if the
 * underlying dmabuf fd is identical).
 *
 * You must use consecutive plane indices ('plane_idx' argument for 'add')
 * from zero to the number of planes used by the drm_fourcc format code.
 * All planes required by the format must be given exactly once, but can
 * be given in any order. Each plane index can be set only once.
 * @section page_iface_zwp_linux_buffer_params_v1_api API
 * See @ref iface_zwp_linux_buffer_params_v1.
 */
/* *
 * @defgroup iface_zwp_linux_buffer_params_v1 The zwp_linux_buffer_params_v1 interface
 *
 * This temporary object is a collection of dmabufs and other
 * parameters that together form a single logical buffer. The temporary
 * object may eventually create one wl_buffer unless cancelled by
 * destroying it before requesting 'create'.
 *
 * Single-planar formats only require one dmabuf, however
 * multi-planar formats may require more than one dmabuf. For all
 * formats, an 'add' request must be called once per plane (even if the
 * underlying dmabuf fd is identical).
 *
 * You must use consecutive plane indices ('plane_idx' argument for 'add')
 * from zero to the number of planes used by the drm_fourcc format code.
 * All planes required by the format must be given exactly once, but can
 * be given in any order. Each plane index can be set only once.
 */
    #[no_mangle]
    static zwp_linux_buffer_params_v1_interface: wl_interface;
    #[no_mangle]
    fn wlr_signal_emit_safe(signal: *mut wl_signal, data: *mut libc::c_void);
}
pub type __u64 = libc::c_ulonglong;
pub type size_t = libc::c_ulong;
pub type __int32_t = libc::c_int;
pub type __uint32_t = libc::c_uint;
pub type __uint64_t = libc::c_ulong;
pub type __off64_t = libc::c_long;
pub type off_t = __off64_t;
pub type int32_t = __int32_t;
pub type uint32_t = __uint32_t;
pub type uint64_t = __uint64_t;

#[repr(C)]#[derive(Copy, Clone)]
pub struct wl_object {
    pub interface: *const wl_interface,
    pub implementation: *const libc::c_void,
    pub id: uint32_t,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct wl_interface {
    pub name: *const libc::c_char,
    pub version: libc::c_int,
    pub method_count: libc::c_int,
    pub methods: *const wl_message,
    pub event_count: libc::c_int,
    pub events: *const wl_message,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct wl_message {
    pub name: *const libc::c_char,
    pub signature: *const libc::c_char,
    pub types: *mut *const wl_interface,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct wl_list {
    pub prev: *mut wl_list,
    pub next: *mut wl_list,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct wl_listener {
    pub link: wl_list,
    pub notify: wl_notify_func_t,
}
pub type wl_notify_func_t
    =
    Option<unsafe extern "C" fn(_: *mut wl_listener, _: *mut libc::c_void)
               -> ()>;
pub type wl_global_bind_func_t
    =
    Option<unsafe extern "C" fn(_: *mut wl_client, _: *mut libc::c_void,
                                _: uint32_t, _: uint32_t) -> ()>;

#[repr(C)]#[derive(Copy, Clone)]
pub struct wl_resource {
    pub object: wl_object,
    pub destroy: wl_resource_destroy_func_t,
    pub link: wl_list,
    pub destroy_signal: wl_signal,
    pub client: *mut wl_client,
    pub data: *mut libc::c_void,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct wl_signal {
    pub listener_list: wl_list,
}
pub type wl_resource_destroy_func_t
    =
    Option<unsafe extern "C" fn(_: *mut wl_resource) -> ()>;

#[repr(C)]#[derive(Copy, Clone)]
pub struct wlr_drm_format {
    pub format: uint32_t,
    pub len: size_t,
    pub cap: size_t,
    pub modifiers: [uint64_t; 0],
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct wlr_drm_format_set {
    pub len: size_t,
    pub cap: size_t,
    pub formats: *mut *mut wlr_drm_format,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct wl_buffer_interface {
    pub destroy: Option<unsafe extern "C" fn(_: *mut wl_client,
                                             _: *mut wl_resource) -> ()>,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct wlr_dmabuf_attributes {
    pub width: int32_t,
    pub height: int32_t,
    pub format: uint32_t,
    pub flags: uint32_t,
    pub modifier: uint64_t,
    pub n_planes: libc::c_int,
    pub offset: [uint32_t; 4],
    pub stride: [uint32_t; 4],
    pub fd: [libc::c_int; 4],
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct wlr_renderer {
    pub impl_0: *const crate::src::render::gles2::renderer::wlr_renderer_impl,
    pub events: C2RustUnnamed,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct C2RustUnnamed {
    pub destroy: wl_signal,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct wlr_texture {
    pub impl_0: *const crate::src::render::gles2::renderer::wlr_texture_impl,
}
/*
 * This an unstable interface of wlroots. No guarantees are made regarding the
 * future consistency of this API.
 */

#[repr(C)]#[derive(Copy, Clone)]
pub struct wlr_dmabuf_v1_buffer {
    pub renderer: *mut wlr_renderer,
    pub buffer_resource: *mut wl_resource,
    pub params_resource: *mut wl_resource,
    pub attributes: wlr_dmabuf_attributes,
    pub has_modifier: bool,
}
/* ZWP_LINUX_BUFFER_PARAMS_V1_FLAGS_ENUM */
/* *
 * @ingroup iface_zwp_linux_buffer_params_v1
 * @struct zwp_linux_buffer_params_v1_interface
 */

#[repr(C)]#[derive(Copy, Clone)]
pub struct zwp_linux_buffer_params_v1_interface {
    pub destroy: Option<unsafe extern "C" fn(_: *mut wl_client,
                                             _: *mut wl_resource) -> ()>,
    pub add: Option<unsafe extern "C" fn(_: *mut wl_client,
                                         _: *mut wl_resource, _: int32_t,
                                         _: uint32_t, _: uint32_t,
                                         _: uint32_t, _: uint32_t,
                                         _: uint32_t) -> ()>,
    pub create: Option<unsafe extern "C" fn(_: *mut wl_client,
                                            _: *mut wl_resource, _: int32_t,
                                            _: int32_t, _: uint32_t,
                                            _: uint32_t) -> ()>,
    pub create_immed: Option<unsafe extern "C" fn(_: *mut wl_client,
                                                  _: *mut wl_resource,
                                                  _: uint32_t, _: int32_t,
                                                  _: int32_t, _: uint32_t,
                                                  _: uint32_t) -> ()>,
}
/* *
	 * invalid wl_buffer resulted from importing dmabufs via                the create_immed request on given buffer_params
	 */
pub const ZWP_LINUX_BUFFER_PARAMS_V1_ERROR_INVALID_WL_BUFFER:
          zwp_linux_buffer_params_v1_error =
    7;
/* the protocol interface */

#[repr(C)]#[derive(Copy, Clone)]
pub struct wlr_linux_dmabuf_v1 {
    pub global: *mut wl_global,
    pub renderer: *mut wlr_renderer,
    pub events: C2RustUnnamed_0,
    pub display_destroy: wl_listener,
    pub renderer_destroy: wl_listener,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct C2RustUnnamed_0 {
    pub destroy: wl_signal,
}
/* *
	 * format not supported
	 */
pub const ZWP_LINUX_BUFFER_PARAMS_V1_ERROR_INVALID_FORMAT:
          zwp_linux_buffer_params_v1_error =
    4;
/* *
	 * contents are y-inverted
	 */
pub const ZWP_LINUX_BUFFER_PARAMS_V1_FLAGS_Y_INVERT:
          zwp_linux_buffer_params_v1_flags =
    1;
/* *
	 * offset + stride * height goes out of dmabuf bounds
	 */
pub const ZWP_LINUX_BUFFER_PARAMS_V1_ERROR_OUT_OF_BOUNDS:
          zwp_linux_buffer_params_v1_error =
    6;
/* *
	 * invalid width or height
	 */
pub const ZWP_LINUX_BUFFER_PARAMS_V1_ERROR_INVALID_DIMENSIONS:
          zwp_linux_buffer_params_v1_error =
    5;
/* *
	 * missing or too many planes to create a buffer
	 */
pub const ZWP_LINUX_BUFFER_PARAMS_V1_ERROR_INCOMPLETE:
          zwp_linux_buffer_params_v1_error =
    3;
/* *
	 * the dmabuf_batch object has already been used to create a wl_buffer
	 */
pub const ZWP_LINUX_BUFFER_PARAMS_V1_ERROR_ALREADY_USED:
          zwp_linux_buffer_params_v1_error =
    0;
/* *
	 * the plane index was already set
	 */
pub const ZWP_LINUX_BUFFER_PARAMS_V1_ERROR_PLANE_SET:
          zwp_linux_buffer_params_v1_error =
    2;
/* *
	 * plane index out of bounds
	 */
pub const ZWP_LINUX_BUFFER_PARAMS_V1_ERROR_PLANE_IDX:
          zwp_linux_buffer_params_v1_error =
    1;
/*
 * This is a stable interface of wlroots. Future changes will be limited to:
 *
 * - New functions
 * - New struct members
 * - New enum members
 *
 * Note that wlroots does not make an ABI compatibility promise - in the future,
 * the layout and size of structs used by wlroots may change, requiring code
 * depending on this header to be recompiled (but not edited).
 *
 * Breaking changes are announced by email and follow a 1-year deprecation
 * schedule. Send an email to ~sircmpwn/wlroots-announce+subscribe@lists.sr.ht
 * to receive these announcements.
 */
pub type wlr_log_importance = libc::c_uint;
pub const WLR_LOG_IMPORTANCE_LAST: wlr_log_importance = 4;
pub const WLR_DEBUG: wlr_log_importance = 3;
pub const WLR_INFO: wlr_log_importance = 2;
pub const WLR_ERROR: wlr_log_importance = 1;
pub const WLR_SILENT: wlr_log_importance = 0;
/* *
 * @ingroup iface_zwp_linux_dmabuf_v1
 * @struct zwp_linux_dmabuf_v1_interface
 */

#[repr(C)]#[derive(Copy, Clone)]
pub struct zwp_linux_dmabuf_v1_interface {
    pub destroy: Option<unsafe extern "C" fn(_: *mut wl_client,
                                             _: *mut wl_resource) -> ()>,
    pub create_params: Option<unsafe extern "C" fn(_: *mut wl_client,
                                                   _: *mut wl_resource,
                                                   _: uint32_t) -> ()>,
}
pub type zwp_linux_buffer_params_v1_error = libc::c_uint;
/* ZWP_LINUX_BUFFER_PARAMS_V1_ERROR_ENUM */
pub type zwp_linux_buffer_params_v1_flags = libc::c_uint;
/* *
	 * bottom field first
	 */
pub const ZWP_LINUX_BUFFER_PARAMS_V1_FLAGS_BOTTOM_FIRST:
          zwp_linux_buffer_params_v1_flags =
    4;
/* *
	 * content is interlaced
	 */
pub const ZWP_LINUX_BUFFER_PARAMS_V1_FLAGS_INTERLACED:
          zwp_linux_buffer_params_v1_flags =
    2;
#[inline]
unsafe extern "C" fn wl_signal_init(mut signal: *mut wl_signal) {
    wl_list_init(&mut (*signal).listener_list);
}
#[inline]
unsafe extern "C" fn wl_signal_add(mut signal: *mut wl_signal,
                                   mut listener: *mut wl_listener) {
    wl_list_insert((*signal).listener_list.prev, &mut (*listener).link);
}
/* *
 * @ingroup iface_zwp_linux_dmabuf_v1
 */
/* *
 * @ingroup iface_zwp_linux_dmabuf_v1
 */
/* *
 * @ingroup iface_zwp_linux_dmabuf_v1
 * Sends an format event to the client owning the resource.
 * @param resource_ The client's resource
 * @param format DRM_FORMAT code
 */
#[inline]
unsafe extern "C" fn zwp_linux_dmabuf_v1_send_format(mut resource_:
                                                         *mut wl_resource,
                                                     mut format: uint32_t) {
    wl_resource_post_event(resource_, 0i32 as uint32_t, format);
}
/* *
 * @ingroup iface_zwp_linux_dmabuf_v1
 * Sends an modifier event to the client owning the resource.
 * @param resource_ The client's resource
 * @param format DRM_FORMAT code
 * @param modifier_hi high 32 bits of layout modifier
 * @param modifier_lo low 32 bits of layout modifier
 */
#[inline]
unsafe extern "C" fn zwp_linux_dmabuf_v1_send_modifier(mut resource_:
                                                           *mut wl_resource,
                                                       mut format: uint32_t,
                                                       mut modifier_hi:
                                                           uint32_t,
                                                       mut modifier_lo:
                                                           uint32_t) {
    wl_resource_post_event(resource_, 1i32 as uint32_t, format, modifier_hi,
                           modifier_lo);
}
/* *
 * @ingroup iface_zwp_linux_buffer_params_v1
 */
/* *
 * @ingroup iface_zwp_linux_buffer_params_v1
 */
/* *
 * @ingroup iface_zwp_linux_buffer_params_v1
 */
/* *
 * @ingroup iface_zwp_linux_buffer_params_v1
 */
/* *
 * @ingroup iface_zwp_linux_buffer_params_v1
 */
/* *
 * @ingroup iface_zwp_linux_buffer_params_v1
 */
/* *
 * @ingroup iface_zwp_linux_buffer_params_v1
 * Sends an created event to the client owning the resource.
 * @param resource_ The client's resource
 * @param buffer the newly created wl_buffer
 */
#[inline]
unsafe extern "C" fn zwp_linux_buffer_params_v1_send_created(mut resource_:
                                                                 *mut wl_resource,
                                                             mut buffer:
                                                                 *mut wl_resource) {
    wl_resource_post_event(resource_, 0i32 as uint32_t, buffer);
}
/* *
 * @ingroup iface_zwp_linux_buffer_params_v1
 * Sends an failed event to the client owning the resource.
 * @param resource_ The client's resource
 */
#[inline]
unsafe extern "C" fn zwp_linux_buffer_params_v1_send_failed(mut resource_:
                                                                *mut wl_resource) {
    wl_resource_post_event(resource_, 1i32 as uint32_t);
}
unsafe extern "C" fn buffer_handle_destroy(mut client: *mut wl_client,
                                           mut resource: *mut wl_resource) {
    wl_resource_destroy(resource);
}
static mut buffer_impl: wl_buffer_interface =
    {
    
        {
            let mut init =
                wl_buffer_interface{destroy:
                                        Some(buffer_handle_destroy as
                                                 unsafe extern "C" fn(_:
                                                                          *mut wl_client,
                                                                      _:
                                                                          *mut wl_resource)
                                                     -> ()),};
            init
        }
};
/* *
 * Returns true if the given resource was created via the linux-dmabuf
 * buffer protocol, false otherwise
 */
#[no_mangle]
pub unsafe extern "C" fn wlr_dmabuf_v1_resource_is_buffer(mut buffer_resource:
                                                              *mut wl_resource)
 -> bool {
    if wl_resource_instance_of(buffer_resource, &wl_buffer_interface,
                               &buffer_impl as *const wl_buffer_interface as
                                   *const libc::c_void) == 0 {
        return 0i32 != 0
    }
    let mut buffer: *mut wlr_dmabuf_v1_buffer =
        wl_resource_get_user_data(buffer_resource) as
            *mut wlr_dmabuf_v1_buffer;
    if !buffer.is_null() && !(*buffer).buffer_resource.is_null() &&
           (*buffer).params_resource.is_null() &&
           (*buffer).buffer_resource == buffer_resource {
        return 1i32 != 0
    }
    return 0i32 != 0;
}
/* *
 * Returns the wlr_dmabuf_buffer if the given resource was created
 * via the linux-dmabuf buffer protocol
 */
#[no_mangle]
pub unsafe extern "C" fn wlr_dmabuf_v1_buffer_from_buffer_resource(mut buffer_resource:
                                                                       *mut wl_resource)
 -> *mut wlr_dmabuf_v1_buffer {
    if wl_resource_instance_of(buffer_resource, &wl_buffer_interface,
                               &buffer_impl as *const wl_buffer_interface as
                                   *const libc::c_void) != 0 {
    } else {
        __assert_fail(b"wl_resource_instance_of(buffer_resource, &wl_buffer_interface, &buffer_impl)\x00"
                          as *const u8 as *const libc::c_char,
                      b"../types/wlr_linux_dmabuf_v1.c\x00" as *const u8 as
                          *const libc::c_char, 44i32 as libc::c_uint,
                      (*::std::mem::transmute::<&[u8; 93],
                                                &[libc::c_char; 93]>(b"struct wlr_dmabuf_v1_buffer *wlr_dmabuf_v1_buffer_from_buffer_resource(struct wl_resource *)\x00")).as_ptr());
    };
    let mut buffer: *mut wlr_dmabuf_v1_buffer =
        wl_resource_get_user_data(buffer_resource) as
            *mut wlr_dmabuf_v1_buffer;
    if !buffer.is_null() {
    } else {
        __assert_fail(b"buffer\x00" as *const u8 as *const libc::c_char,
                      b"../types/wlr_linux_dmabuf_v1.c\x00" as *const u8 as
                          *const libc::c_char, 48i32 as libc::c_uint,
                      (*::std::mem::transmute::<&[u8; 93],
                                                &[libc::c_char; 93]>(b"struct wlr_dmabuf_v1_buffer *wlr_dmabuf_v1_buffer_from_buffer_resource(struct wl_resource *)\x00")).as_ptr());
    };
    if !(*buffer).buffer_resource.is_null() {
    } else {
        __assert_fail(b"buffer->buffer_resource\x00" as *const u8 as
                          *const libc::c_char,
                      b"../types/wlr_linux_dmabuf_v1.c\x00" as *const u8 as
                          *const libc::c_char, 49i32 as libc::c_uint,
                      (*::std::mem::transmute::<&[u8; 93],
                                                &[libc::c_char; 93]>(b"struct wlr_dmabuf_v1_buffer *wlr_dmabuf_v1_buffer_from_buffer_resource(struct wl_resource *)\x00")).as_ptr());
    };
    if (*buffer).params_resource.is_null() {
    } else {
        __assert_fail(b"!buffer->params_resource\x00" as *const u8 as
                          *const libc::c_char,
                      b"../types/wlr_linux_dmabuf_v1.c\x00" as *const u8 as
                          *const libc::c_char, 50i32 as libc::c_uint,
                      (*::std::mem::transmute::<&[u8; 93],
                                                &[libc::c_char; 93]>(b"struct wlr_dmabuf_v1_buffer *wlr_dmabuf_v1_buffer_from_buffer_resource(struct wl_resource *)\x00")).as_ptr());
    };
    if (*buffer).buffer_resource == buffer_resource {
    } else {
        __assert_fail(b"buffer->buffer_resource == buffer_resource\x00" as
                          *const u8 as *const libc::c_char,
                      b"../types/wlr_linux_dmabuf_v1.c\x00" as *const u8 as
                          *const libc::c_char, 51i32 as libc::c_uint,
                      (*::std::mem::transmute::<&[u8; 93],
                                                &[libc::c_char; 93]>(b"struct wlr_dmabuf_v1_buffer *wlr_dmabuf_v1_buffer_from_buffer_resource(struct wl_resource *)\x00")).as_ptr());
    };
    return buffer;
}
unsafe extern "C" fn linux_dmabuf_buffer_destroy(mut buffer:
                                                     *mut wlr_dmabuf_v1_buffer) {
    wlr_dmabuf_attributes_finish(&mut (*buffer).attributes);
    free(buffer as *mut libc::c_void);
}
unsafe extern "C" fn params_destroy(mut client: *mut wl_client,
                                    mut resource: *mut wl_resource) {
    wl_resource_destroy(resource);
}
unsafe extern "C" fn params_add(mut client: *mut wl_client,
                                mut params_resource: *mut wl_resource,
                                mut fd: int32_t, mut plane_idx: uint32_t,
                                mut offset: uint32_t, mut stride: uint32_t,
                                mut modifier_hi: uint32_t,
                                mut modifier_lo: uint32_t) {
    let mut buffer: *mut wlr_dmabuf_v1_buffer =
        wlr_dmabuf_v1_buffer_from_params_resource(params_resource);
    if buffer.is_null() {
        wl_resource_post_error(params_resource,
                               ZWP_LINUX_BUFFER_PARAMS_V1_ERROR_ALREADY_USED
                                   as libc::c_int as uint32_t,
                               b"params was already used to create a wl_buffer\x00"
                                   as *const u8 as *const libc::c_char);
        close(fd);
        return
    }
    if plane_idx >= 4i32 as libc::c_uint {
        wl_resource_post_error(params_resource,
                               ZWP_LINUX_BUFFER_PARAMS_V1_ERROR_PLANE_IDX as
                                   libc::c_int as uint32_t,
                               b"plane index %u > %u\x00" as *const u8 as
                                   *const libc::c_char, plane_idx, 4i32);
        close(fd);
        return
    }
    if (*buffer).attributes.fd[plane_idx as usize] != -1i32 {
        wl_resource_post_error(params_resource,
                               ZWP_LINUX_BUFFER_PARAMS_V1_ERROR_PLANE_SET as
                                   libc::c_int as uint32_t,
                               b"a dmabuf with FD %d has already been added for plane %u\x00"
                                   as *const u8 as *const libc::c_char,
                               (*buffer).attributes.fd[plane_idx as usize],
                               plane_idx);
        close(fd);
        return
    }
    let mut modifier: uint64_t =
        (modifier_hi as uint64_t) << 32i32 | modifier_lo as libc::c_ulong;
    if (*buffer).has_modifier as libc::c_int != 0 &&
           modifier != (*buffer).attributes.modifier {
        wl_resource_post_error(params_resource,
                               ZWP_LINUX_BUFFER_PARAMS_V1_ERROR_INVALID_FORMAT
                                   as libc::c_int as uint32_t,
                               b"sent modifier %lu for plane %u, expected modifier %lu like other planes\x00"
                                   as *const u8 as *const libc::c_char,
                               modifier, plane_idx,
                               (*buffer).attributes.modifier);
        close(fd);
        return
    }
    (*buffer).attributes.modifier = modifier;
    (*buffer).has_modifier = 1i32 != 0;
    (*buffer).attributes.fd[plane_idx as usize] = fd;
    (*buffer).attributes.offset[plane_idx as usize] = offset;
    (*buffer).attributes.stride[plane_idx as usize] = stride;
    (*buffer).attributes.n_planes += 1;
}
unsafe extern "C" fn buffer_handle_resource_destroy(mut buffer_resource:
                                                        *mut wl_resource) {
    let mut buffer: *mut wlr_dmabuf_v1_buffer =
        wlr_dmabuf_v1_buffer_from_buffer_resource(buffer_resource);
    linux_dmabuf_buffer_destroy(buffer);
}
unsafe extern "C" fn check_import_dmabuf(mut buffer:
                                             *mut wlr_dmabuf_v1_buffer)
 -> bool {
    let mut texture: *mut wlr_texture =
        wlr_texture_from_dmabuf((*buffer).renderer,
                                &mut (*buffer).attributes);
    if texture.is_null() { return 0i32 != 0 }
    // We can import the image, good. No need to keep it since wlr_surface will
	// import it again on commit.
    wlr_texture_destroy(texture);
    return 1i32 != 0;
}
unsafe extern "C" fn params_create_common(mut client: *mut wl_client,
                                          mut params_resource:
                                              *mut wl_resource,
                                          mut buffer_id: uint32_t,
                                          mut width: int32_t,
                                          mut height: int32_t,
                                          mut format: uint32_t,
                                          mut flags: uint32_t) {
    let mut current_block: u64;
    if wl_resource_get_user_data(params_resource).is_null() {
        wl_resource_post_error(params_resource,
                               ZWP_LINUX_BUFFER_PARAMS_V1_ERROR_ALREADY_USED
                                   as libc::c_int as uint32_t,
                               b"params was already used to create a wl_buffer\x00"
                                   as *const u8 as *const libc::c_char);
        return
    }
    let mut buffer: *mut wlr_dmabuf_v1_buffer =
        wlr_dmabuf_v1_buffer_from_params_resource(params_resource);
    /* Switch the linux_dmabuf_buffer object from params resource to
	 * eventually wl_buffer resource. */
    wl_resource_set_user_data((*buffer).params_resource,
                              0 as *mut libc::c_void);
    (*buffer).params_resource = 0 as *mut wl_resource;
    if (*buffer).attributes.n_planes == 0 {
        wl_resource_post_error(params_resource,
                               ZWP_LINUX_BUFFER_PARAMS_V1_ERROR_INCOMPLETE as
                                   libc::c_int as uint32_t,
                               b"no dmabuf has been added to the params\x00"
                                   as *const u8 as *const libc::c_char);
    } else if (*buffer).attributes.fd[0] == -1i32 {
        wl_resource_post_error(params_resource,
                               ZWP_LINUX_BUFFER_PARAMS_V1_ERROR_INCOMPLETE as
                                   libc::c_int as uint32_t,
                               b"no dmabuf has been added for plane 0\x00" as
                                   *const u8 as *const libc::c_char);
    } else if ((*buffer).attributes.fd[3] >= 0i32 ||
                   (*buffer).attributes.fd[2] >= 0i32) &&
                  ((*buffer).attributes.fd[2] == -1i32 ||
                       (*buffer).attributes.fd[1] == -1i32) {
        wl_resource_post_error(params_resource,
                               ZWP_LINUX_BUFFER_PARAMS_V1_ERROR_INCOMPLETE as
                                   libc::c_int as uint32_t,
                               b"gap in dmabuf planes\x00" as *const u8 as
                                   *const libc::c_char);
    } else {
        (*buffer).attributes.width = width;
        (*buffer).attributes.height = height;
        (*buffer).attributes.format = format;
        (*buffer).attributes.flags = flags;
        if width < 1i32 || height < 1i32 {
            wl_resource_post_error(params_resource,
                                   ZWP_LINUX_BUFFER_PARAMS_V1_ERROR_INVALID_DIMENSIONS
                                       as libc::c_int as uint32_t,
                                   b"invalid width %d or height %d\x00" as
                                       *const u8 as *const libc::c_char,
                                   width, height);
        } else {
            let mut i: libc::c_int = 0i32;
            loop  {
                if !(i < (*buffer).attributes.n_planes) {
                    current_block = 11048769245176032998;
                    break ;
                }
                if ((*buffer).attributes.offset[i as usize] as
                        uint64_t).wrapping_add((*buffer).attributes.stride[i
                                                                               as
                                                                               usize]
                                                   as libc::c_ulong) >
                       4294967295u32 as libc::c_ulong {
                    wl_resource_post_error(params_resource,
                                           ZWP_LINUX_BUFFER_PARAMS_V1_ERROR_OUT_OF_BOUNDS
                                               as libc::c_int as uint32_t,
                                           b"size overflow for plane %d\x00"
                                               as *const u8 as
                                               *const libc::c_char, i);
                    current_block = 12463185726172239640;
                    break ;
                } else if ((*buffer).attributes.offset[i as usize] as
                               uint64_t).wrapping_add(((*buffer).attributes.stride[i
                                                                                       as
                                                                                       usize]
                                                           as
                                                           uint64_t).wrapping_mul(height
                                                                                      as
                                                                                      libc::c_ulong))
                              > 4294967295u32 as libc::c_ulong {
                    wl_resource_post_error(params_resource,
                                           ZWP_LINUX_BUFFER_PARAMS_V1_ERROR_OUT_OF_BOUNDS
                                               as libc::c_int as uint32_t,
                                           b"size overflow for plane %d\x00"
                                               as *const u8 as
                                               *const libc::c_char, i);
                    current_block = 12463185726172239640;
                    break ;
                } else {
                    let mut size: off_t =
                        lseek((*buffer).attributes.fd[i as usize],
                              0i32 as __off64_t, 2i32);
                    if !(size == -1i32 as libc::c_long) {
                        if (*buffer).attributes.offset[i as usize] as
                               libc::c_long > size {
                            wl_resource_post_error(params_resource,
                                                   ZWP_LINUX_BUFFER_PARAMS_V1_ERROR_OUT_OF_BOUNDS
                                                       as libc::c_int as
                                                       uint32_t,
                                                   b"invalid offset %i for plane %d\x00"
                                                       as *const u8 as
                                                       *const libc::c_char,
                                                   (*buffer).attributes.offset[i
                                                                                   as
                                                                                   usize],
                                                   i);
                            current_block = 12463185726172239640;
                            break ;
                        } else if (*buffer).attributes.offset[i as
                                                                  usize].wrapping_add((*buffer).attributes.stride[i
                                                                                                                      as
                                                                                                                      usize])
                                      as libc::c_long > size ||
                                      (*buffer).attributes.stride[i as usize]
                                          == 0i32 as libc::c_uint {
                            wl_resource_post_error(params_resource,
                                                   ZWP_LINUX_BUFFER_PARAMS_V1_ERROR_OUT_OF_BOUNDS
                                                       as libc::c_int as
                                                       uint32_t,
                                                   b"invalid stride %i for plane %d\x00"
                                                       as *const u8 as
                                                       *const libc::c_char,
                                                   (*buffer).attributes.stride[i
                                                                                   as
                                                                                   usize],
                                                   i);
                            current_block = 12463185726172239640;
                            break ;
                        } else if i == 0i32 &&
                                      (*buffer).attributes.offset[i as
                                                                      usize].wrapping_add((*buffer).attributes.stride[i
                                                                                                                          as
                                                                                                                          usize].wrapping_mul(height
                                                                                                                                                  as
                                                                                                                                                  libc::c_uint))
                                          as libc::c_long > size {
                            wl_resource_post_error(params_resource,
                                                   ZWP_LINUX_BUFFER_PARAMS_V1_ERROR_OUT_OF_BOUNDS
                                                       as libc::c_int as
                                                       uint32_t,
                                                   b"invalid buffer stride or height for plane %d\x00"
                                                       as *const u8 as
                                                       *const libc::c_char,
                                                   i);
                            current_block = 12463185726172239640;
                            break ;
                        }
                    }
                    // planes > 0 might be subsampled according to fourcc format
                    // Skip checks if kernel does no support seek on buffer
                    i += 1
                }
            }
            match current_block {
                12463185726172239640 => { }
                _ =>
                /* reject unknown flags */
                {
                    if (*buffer).attributes.flags &
                           !(ZWP_LINUX_BUFFER_PARAMS_V1_FLAGS_Y_INVERT as
                                 libc::c_int) as libc::c_uint != 0 {
                        wl_resource_post_error(params_resource,
                                               ZWP_LINUX_BUFFER_PARAMS_V1_ERROR_INVALID_FORMAT
                                                   as libc::c_int as uint32_t,
                                               b"Unknown dmabuf flags %u\x00"
                                                   as *const u8 as
                                                   *const libc::c_char,
                                               (*buffer).attributes.flags);
                    } else {
                        /* Check if dmabuf is usable */
                        if check_import_dmabuf(buffer) {
                            (*buffer).buffer_resource =
                                wl_resource_create(client,
                                                   &wl_buffer_interface, 1i32,
                                                   buffer_id);
                            if (*buffer).buffer_resource.is_null() {
                                wl_resource_post_no_memory(params_resource);
                            } else {
                                wl_resource_set_implementation((*buffer).buffer_resource,
                                                               &buffer_impl as
                                                                   *const wl_buffer_interface
                                                                   as
                                                                   *const libc::c_void,
                                                               buffer as
                                                                   *mut libc::c_void,
                                                               Some(buffer_handle_resource_destroy
                                                                        as
                                                                        unsafe extern "C" fn(_:
                                                                                                 *mut wl_resource)
                                                                            ->
                                                                                ()));
                                /* send 'created' event when the request is not for an immediate
	 * import, that is buffer_id is zero */
                                if buffer_id == 0i32 as libc::c_uint {
                                    zwp_linux_buffer_params_v1_send_created(params_resource,
                                                                            (*buffer).buffer_resource);
                                }
                                return
                            }
                        }
                        if buffer_id == 0i32 as libc::c_uint {
                            zwp_linux_buffer_params_v1_send_failed(params_resource);
                        } else {
                            /* since the behavior is left implementation defined by the
		 * protocol in case of create_immed failure due to an unknown cause,
		 * we choose to treat it as a fatal error and immediately kill the
		 * client instead of creating an invalid handle and waiting for it
		 * to be used.
		 */
                            wl_resource_post_error(params_resource,
                                                   ZWP_LINUX_BUFFER_PARAMS_V1_ERROR_INVALID_WL_BUFFER
                                                       as libc::c_int as
                                                       uint32_t,
                                                   b"importing the supplied dmabufs failed\x00"
                                                       as *const u8 as
                                                       *const libc::c_char);
                        }
                    }
                }
            }
        }
    }
    linux_dmabuf_buffer_destroy(buffer);
}
unsafe extern "C" fn params_create(mut client: *mut wl_client,
                                   mut params_resource: *mut wl_resource,
                                   mut width: int32_t, mut height: int32_t,
                                   mut format: uint32_t,
                                   mut flags: uint32_t) {
    params_create_common(client, params_resource, 0i32 as uint32_t, width,
                         height, format, flags);
}
unsafe extern "C" fn params_create_immed(mut client: *mut wl_client,
                                         mut params_resource:
                                             *mut wl_resource,
                                         mut buffer_id: uint32_t,
                                         mut width: int32_t,
                                         mut height: int32_t,
                                         mut format: uint32_t,
                                         mut flags: uint32_t) {
    params_create_common(client, params_resource, buffer_id, width, height,
                         format, flags);
}
static mut linux_buffer_params_impl: zwp_linux_buffer_params_v1_interface =
    {
    
        {
            let mut init =
                zwp_linux_buffer_params_v1_interface{destroy:
                                                         Some(params_destroy
                                                                  as
                                                                  unsafe extern "C" fn(_:
                                                                                           *mut wl_client,
                                                                                       _:
                                                                                           *mut wl_resource)
                                                                      -> ()),
                                                     add:
                                                         Some(params_add as
                                                                  unsafe extern "C" fn(_:
                                                                                           *mut wl_client,
                                                                                       _:
                                                                                           *mut wl_resource,
                                                                                       _:
                                                                                           int32_t,
                                                                                       _:
                                                                                           uint32_t,
                                                                                       _:
                                                                                           uint32_t,
                                                                                       _:
                                                                                           uint32_t,
                                                                                       _:
                                                                                           uint32_t,
                                                                                       _:
                                                                                           uint32_t)
                                                                      -> ()),
                                                     create:
                                                         Some(params_create as
                                                                  unsafe extern "C" fn(_:
                                                                                           *mut wl_client,
                                                                                       _:
                                                                                           *mut wl_resource,
                                                                                       _:
                                                                                           int32_t,
                                                                                       _:
                                                                                           int32_t,
                                                                                       _:
                                                                                           uint32_t,
                                                                                       _:
                                                                                           uint32_t)
                                                                      -> ()),
                                                     create_immed:
                                                         Some(params_create_immed
                                                                  as
                                                                  unsafe extern "C" fn(_:
                                                                                           *mut wl_client,
                                                                                       _:
                                                                                           *mut wl_resource,
                                                                                       _:
                                                                                           uint32_t,
                                                                                       _:
                                                                                           int32_t,
                                                                                       _:
                                                                                           int32_t,
                                                                                       _:
                                                                                           uint32_t,
                                                                                       _:
                                                                                           uint32_t)
                                                                      ->
                                                                          ()),};
            init
        }
};
/* *
 * Returns the wlr_dmabuf_buffer if the given resource was created
 * via the linux-dmabuf params protocol
 */
#[no_mangle]
pub unsafe extern "C" fn wlr_dmabuf_v1_buffer_from_params_resource(mut params_resource:
                                                                       *mut wl_resource)
 -> *mut wlr_dmabuf_v1_buffer {
    if wl_resource_instance_of(params_resource,
                               &zwp_linux_buffer_params_v1_interface,
                               &linux_buffer_params_impl as
                                   *const zwp_linux_buffer_params_v1_interface
                                   as *const libc::c_void) != 0 {
    } else {
        __assert_fail(b"wl_resource_instance_of(params_resource, &zwp_linux_buffer_params_v1_interface, &linux_buffer_params_impl)\x00"
                          as *const u8 as *const libc::c_char,
                      b"../types/wlr_linux_dmabuf_v1.c\x00" as *const u8 as
                          *const libc::c_char, 312i32 as libc::c_uint,
                      (*::std::mem::transmute::<&[u8; 93],
                                                &[libc::c_char; 93]>(b"struct wlr_dmabuf_v1_buffer *wlr_dmabuf_v1_buffer_from_params_resource(struct wl_resource *)\x00")).as_ptr());
    };
    let mut buffer: *mut wlr_dmabuf_v1_buffer =
        wl_resource_get_user_data(params_resource) as
            *mut wlr_dmabuf_v1_buffer;
    if !buffer.is_null() {
    } else {
        __assert_fail(b"buffer\x00" as *const u8 as *const libc::c_char,
                      b"../types/wlr_linux_dmabuf_v1.c\x00" as *const u8 as
                          *const libc::c_char, 316i32 as libc::c_uint,
                      (*::std::mem::transmute::<&[u8; 93],
                                                &[libc::c_char; 93]>(b"struct wlr_dmabuf_v1_buffer *wlr_dmabuf_v1_buffer_from_params_resource(struct wl_resource *)\x00")).as_ptr());
    };
    if !(*buffer).params_resource.is_null() {
    } else {
        __assert_fail(b"buffer->params_resource\x00" as *const u8 as
                          *const libc::c_char,
                      b"../types/wlr_linux_dmabuf_v1.c\x00" as *const u8 as
                          *const libc::c_char, 317i32 as libc::c_uint,
                      (*::std::mem::transmute::<&[u8; 93],
                                                &[libc::c_char; 93]>(b"struct wlr_dmabuf_v1_buffer *wlr_dmabuf_v1_buffer_from_params_resource(struct wl_resource *)\x00")).as_ptr());
    };
    if (*buffer).buffer_resource.is_null() {
    } else {
        __assert_fail(b"!buffer->buffer_resource\x00" as *const u8 as
                          *const libc::c_char,
                      b"../types/wlr_linux_dmabuf_v1.c\x00" as *const u8 as
                          *const libc::c_char, 318i32 as libc::c_uint,
                      (*::std::mem::transmute::<&[u8; 93],
                                                &[libc::c_char; 93]>(b"struct wlr_dmabuf_v1_buffer *wlr_dmabuf_v1_buffer_from_params_resource(struct wl_resource *)\x00")).as_ptr());
    };
    if (*buffer).params_resource == params_resource {
    } else {
        __assert_fail(b"buffer->params_resource == params_resource\x00" as
                          *const u8 as *const libc::c_char,
                      b"../types/wlr_linux_dmabuf_v1.c\x00" as *const u8 as
                          *const libc::c_char, 319i32 as libc::c_uint,
                      (*::std::mem::transmute::<&[u8; 93],
                                                &[libc::c_char; 93]>(b"struct wlr_dmabuf_v1_buffer *wlr_dmabuf_v1_buffer_from_params_resource(struct wl_resource *)\x00")).as_ptr());
    };
    return buffer;
}
unsafe extern "C" fn handle_params_destroy(mut params_resource:
                                               *mut wl_resource) {
    /* Check for NULL since wlr_dmabuf_v1_buffer_from_params_resource will choke */
    if wl_resource_get_user_data(params_resource).is_null() { return }
    let mut buffer: *mut wlr_dmabuf_v1_buffer =
        wlr_dmabuf_v1_buffer_from_params_resource(params_resource);
    linux_dmabuf_buffer_destroy(buffer);
}
unsafe extern "C" fn linux_dmabuf_create_params(mut client: *mut wl_client,
                                                mut linux_dmabuf_resource:
                                                    *mut wl_resource,
                                                mut params_id: uint32_t) {
    let mut linux_dmabuf: *mut wlr_linux_dmabuf_v1 =
        wlr_linux_dmabuf_v1_from_resource(linux_dmabuf_resource);
    let mut version: uint32_t =
        wl_resource_get_version(linux_dmabuf_resource) as uint32_t;
    let mut buffer: *mut wlr_dmabuf_v1_buffer =
        calloc(1i32 as libc::c_ulong,
               ::std::mem::size_of::<wlr_dmabuf_v1_buffer>() as libc::c_ulong)
            as *mut wlr_dmabuf_v1_buffer;
    if !buffer.is_null() {
        let mut i: libc::c_int = 0i32;
        while i < 4i32 { (*buffer).attributes.fd[i as usize] = -1i32; i += 1 }
        (*buffer).renderer = (*linux_dmabuf).renderer;
        (*buffer).params_resource =
            wl_resource_create(client, &zwp_linux_buffer_params_v1_interface,
                               version as libc::c_int, params_id);
        if (*buffer).params_resource.is_null() {
            free(buffer as *mut libc::c_void);
        } else {
            wl_resource_set_implementation((*buffer).params_resource,
                                           &linux_buffer_params_impl as
                                               *const zwp_linux_buffer_params_v1_interface
                                               as *const libc::c_void,
                                           buffer as *mut libc::c_void,
                                           Some(handle_params_destroy as
                                                    unsafe extern "C" fn(_:
                                                                             *mut wl_resource)
                                                        -> ()));
            return
        }
    }
    wl_resource_post_no_memory(linux_dmabuf_resource);
}
unsafe extern "C" fn linux_dmabuf_destroy(mut client: *mut wl_client,
                                          mut resource: *mut wl_resource) {
    wl_resource_destroy(resource);
}
static mut linux_dmabuf_impl: zwp_linux_dmabuf_v1_interface =
    {
    
        {
            let mut init =
                zwp_linux_dmabuf_v1_interface{destroy:
                                                  Some(linux_dmabuf_destroy as
                                                           unsafe extern "C" fn(_:
                                                                                    *mut wl_client,
                                                                                _:
                                                                                    *mut wl_resource)
                                                               -> ()),
                                              create_params:
                                                  Some(linux_dmabuf_create_params
                                                           as
                                                           unsafe extern "C" fn(_:
                                                                                    *mut wl_client,
                                                                                _:
                                                                                    *mut wl_resource,
                                                                                _:
                                                                                    uint32_t)
                                                               -> ()),};
            init
        }
};
/* *
 * Returns the wlr_linux_dmabuf if the given resource was created
 * via the linux_dmabuf protocol
 */
#[no_mangle]
pub unsafe extern "C" fn wlr_linux_dmabuf_v1_from_resource(mut resource:
                                                               *mut wl_resource)
 -> *mut wlr_linux_dmabuf_v1 {
    if wl_resource_instance_of(resource, &zwp_linux_dmabuf_v1_interface,
                               &linux_dmabuf_impl as
                                   *const zwp_linux_dmabuf_v1_interface as
                                   *const libc::c_void) != 0 {
    } else {
        __assert_fail(b"wl_resource_instance_of(resource, &zwp_linux_dmabuf_v1_interface, &linux_dmabuf_impl)\x00"
                          as *const u8 as *const libc::c_char,
                      b"../types/wlr_linux_dmabuf_v1.c\x00" as *const u8 as
                          *const libc::c_char, 381i32 as libc::c_uint,
                      (*::std::mem::transmute::<&[u8; 84],
                                                &[libc::c_char; 84]>(b"struct wlr_linux_dmabuf_v1 *wlr_linux_dmabuf_v1_from_resource(struct wl_resource *)\x00")).as_ptr());
    };
    let mut dmabuf: *mut wlr_linux_dmabuf_v1 =
        wl_resource_get_user_data(resource) as *mut wlr_linux_dmabuf_v1;
    if !dmabuf.is_null() {
    } else {
        __assert_fail(b"dmabuf\x00" as *const u8 as *const libc::c_char,
                      b"../types/wlr_linux_dmabuf_v1.c\x00" as *const u8 as
                          *const libc::c_char, 384i32 as libc::c_uint,
                      (*::std::mem::transmute::<&[u8; 84],
                                                &[libc::c_char; 84]>(b"struct wlr_linux_dmabuf_v1 *wlr_linux_dmabuf_v1_from_resource(struct wl_resource *)\x00")).as_ptr());
    };
    return dmabuf;
}
unsafe extern "C" fn linux_dmabuf_send_formats(mut linux_dmabuf:
                                                   *mut wlr_linux_dmabuf_v1,
                                               mut resource: *mut wl_resource,
                                               mut version: uint32_t) {
    let mut modifier_invalid: uint64_t =
        ((0i32 as __u64) << 56i32 |
             (1u64 << 56i32).wrapping_sub(1i32 as libc::c_ulonglong) &
                 0xffffffffffffffu64) as uint64_t;
    let mut formats: *const wlr_drm_format_set =
        wlr_renderer_get_dmabuf_formats((*linux_dmabuf).renderer);
    if formats.is_null() { return }
    let mut i: size_t = 0i32 as size_t;
    while i < (*formats).len {
        let mut fmt: *mut wlr_drm_format =
            *(*formats).formats.offset(i as isize);
        let mut modifiers_len: size_t = (*fmt).len;
        let mut modifiers: *mut uint64_t = (*fmt).modifiers.as_mut_ptr();
        // Send DRM_FORMAT_MOD_INVALID token when no modifiers are supported
		// for this format
        if modifiers_len == 0i32 as libc::c_ulong {
            modifiers_len = 1i32 as size_t;
            modifiers = &mut modifier_invalid
        }
        let mut j: size_t = 0i32 as size_t;
        while j < modifiers_len {
            if version >= 3i32 as libc::c_uint {
                let mut modifier_lo: uint32_t =
                    (*modifiers.offset(j as isize) &
                         0xffffffffu32 as libc::c_ulong) as uint32_t;
                let mut modifier_hi: uint32_t =
                    (*modifiers.offset(j as isize) >> 32i32) as uint32_t;
                zwp_linux_dmabuf_v1_send_modifier(resource, (*fmt).format,
                                                  modifier_hi, modifier_lo);
            } else if *modifiers.offset(j as isize) as libc::c_ulonglong ==
                          (0i32 as __u64) << 56i32 |
                              0i32 as libc::c_ulonglong & 0xffffffffffffffu64
                          ||
                          modifiers == &mut modifier_invalid as *mut uint64_t
             {
                zwp_linux_dmabuf_v1_send_format(resource, (*fmt).format);
            }
            j = j.wrapping_add(1)
        }
        i = i.wrapping_add(1)
    };
}
unsafe extern "C" fn linux_dmabuf_bind(mut client: *mut wl_client,
                                       mut data: *mut libc::c_void,
                                       mut version: uint32_t,
                                       mut id: uint32_t) {
    let mut linux_dmabuf: *mut wlr_linux_dmabuf_v1 =
        data as *mut wlr_linux_dmabuf_v1;
    let mut resource: *mut wl_resource =
        wl_resource_create(client, &zwp_linux_dmabuf_v1_interface,
                           version as libc::c_int, id);
    if resource.is_null() { wl_client_post_no_memory(client); return }
    wl_resource_set_implementation(resource,
                                   &linux_dmabuf_impl as
                                       *const zwp_linux_dmabuf_v1_interface as
                                       *const libc::c_void,
                                   linux_dmabuf as *mut libc::c_void, None);
    linux_dmabuf_send_formats(linux_dmabuf, resource, version);
}
unsafe extern "C" fn linux_dmabuf_v1_destroy(mut linux_dmabuf:
                                                 *mut wlr_linux_dmabuf_v1) {
    wlr_signal_emit_safe(&mut (*linux_dmabuf).events.destroy,
                         linux_dmabuf as *mut libc::c_void);
    wl_list_remove(&mut (*linux_dmabuf).display_destroy.link);
    wl_list_remove(&mut (*linux_dmabuf).renderer_destroy.link);
    wl_global_destroy((*linux_dmabuf).global);
    free(linux_dmabuf as *mut libc::c_void);
}
unsafe extern "C" fn handle_display_destroy(mut listener: *mut wl_listener,
                                            mut data: *mut libc::c_void) {
    let mut linux_dmabuf: *mut wlr_linux_dmabuf_v1 =
        (listener as *mut libc::c_char).offset(-32) as
            *mut wlr_linux_dmabuf_v1;
    linux_dmabuf_v1_destroy(linux_dmabuf);
}
unsafe extern "C" fn handle_renderer_destroy(mut listener: *mut wl_listener,
                                             mut data: *mut libc::c_void) {
    let mut linux_dmabuf: *mut wlr_linux_dmabuf_v1 =
        (listener as *mut libc::c_char).offset(-56) as
            *mut wlr_linux_dmabuf_v1;
    linux_dmabuf_v1_destroy(linux_dmabuf);
}
/* *
 * Create linux-dmabuf interface
 */
#[no_mangle]
pub unsafe extern "C" fn wlr_linux_dmabuf_v1_create(mut display:
                                                        *mut wl_display,
                                                    mut renderer:
                                                        *mut wlr_renderer)
 -> *mut wlr_linux_dmabuf_v1 {
    let mut linux_dmabuf: *mut wlr_linux_dmabuf_v1 =
        calloc(1i32 as libc::c_ulong,
               ::std::mem::size_of::<wlr_linux_dmabuf_v1>() as libc::c_ulong)
            as *mut wlr_linux_dmabuf_v1;
    if linux_dmabuf.is_null() {
        _wlr_log(WLR_ERROR,
                 b"[%s:%d] could not create simple dmabuf manager\x00" as
                     *const u8 as *const libc::c_char,
                 b"../types/wlr_linux_dmabuf_v1.c\x00" as *const u8 as
                     *const libc::c_char, 467i32);
        return 0 as *mut wlr_linux_dmabuf_v1
    }
    (*linux_dmabuf).renderer = renderer;
    wl_signal_init(&mut (*linux_dmabuf).events.destroy);
    (*linux_dmabuf).global =
        wl_global_create(display, &zwp_linux_dmabuf_v1_interface, 3i32,
                         linux_dmabuf as *mut libc::c_void,
                         Some(linux_dmabuf_bind as
                                  unsafe extern "C" fn(_: *mut wl_client,
                                                       _: *mut libc::c_void,
                                                       _: uint32_t,
                                                       _: uint32_t) -> ()));
    if (*linux_dmabuf).global.is_null() {
        _wlr_log(WLR_ERROR,
                 b"[%s:%d] could not create linux dmabuf v1 wl global\x00" as
                     *const u8 as *const libc::c_char,
                 b"../types/wlr_linux_dmabuf_v1.c\x00" as *const u8 as
                     *const libc::c_char, 478i32);
        free(linux_dmabuf as *mut libc::c_void);
        return 0 as *mut wlr_linux_dmabuf_v1
    }
    (*linux_dmabuf).display_destroy.notify =
        Some(handle_display_destroy as
                 unsafe extern "C" fn(_: *mut wl_listener,
                                      _: *mut libc::c_void) -> ());
    wl_display_add_destroy_listener(display,
                                    &mut (*linux_dmabuf).display_destroy);
    (*linux_dmabuf).renderer_destroy.notify =
        Some(handle_renderer_destroy as
                 unsafe extern "C" fn(_: *mut wl_listener,
                                      _: *mut libc::c_void) -> ());
    wl_signal_add(&mut (*renderer).events.destroy,
                  &mut (*linux_dmabuf).renderer_destroy);
    return linux_dmabuf;
}
