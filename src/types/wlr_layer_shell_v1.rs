use libc;
extern "C" {
    pub type wl_event_source;
    pub type wl_display;
    /* Generated by wayland-scanner 1.17.0 */
    pub type wl_client;
    pub type wl_global;
    pub type wlr_texture;
    pub type wlr_renderer;
    pub type wlr_backend;
    pub type wlr_output_impl;
    pub type xkb_state;
    pub type xkb_keymap;
    pub type wlr_keyboard_group;
    /*
 * This an unstable interface of wlroots. No guarantees are made regarding the
 * future consistency of this API.
 */
    pub type wlr_keyboard_impl;
    pub type wlr_data_source;
    pub type wlr_drag;
    pub type wlr_primary_selection_source;
    #[no_mangle]
    fn __assert_fail(__assertion: *const libc::c_char,
                     __file: *const libc::c_char, __line: libc::c_uint,
                     __function: *const libc::c_char) -> !;
    #[no_mangle]
    fn calloc(_: libc::c_ulong, _: libc::c_ulong) -> *mut libc::c_void;
    #[no_mangle]
    fn free(__ptr: *mut libc::c_void);
    #[no_mangle]
    fn strdup(__s: *const libc::c_char) -> *mut libc::c_char;
    #[no_mangle]
    fn wl_list_init(list: *mut wl_list);
    #[no_mangle]
    fn wl_list_insert(list: *mut wl_list, elm: *mut wl_list);
    #[no_mangle]
    fn wl_list_remove(elm: *mut wl_list);
    #[no_mangle]
    fn wl_list_empty(list: *const wl_list) -> libc::c_int;
    #[no_mangle]
    fn wl_display_next_serial(display: *mut wl_display) -> uint32_t;
    #[no_mangle]
    fn wl_display_add_destroy_listener(display: *mut wl_display,
                                       listener: *mut wl_listener);
    #[no_mangle]
    fn wl_global_create(display: *mut wl_display,
                        interface: *const wl_interface, version: libc::c_int,
                        data: *mut libc::c_void, bind: wl_global_bind_func_t)
     -> *mut wl_global;
    #[no_mangle]
    fn wl_global_destroy(global: *mut wl_global);
    #[no_mangle]
    fn wl_client_post_no_memory(client: *mut wl_client);
    #[no_mangle]
    fn wl_resource_post_event(resource: *mut wl_resource, opcode: uint32_t,
                              _: ...);
    #[no_mangle]
    fn wl_resource_post_error(resource: *mut wl_resource, code: uint32_t,
                              msg: *const libc::c_char, _: ...);
    #[no_mangle]
    fn wl_client_get_display(client: *mut wl_client) -> *mut wl_display;
    #[no_mangle]
    fn wl_resource_create(client: *mut wl_client,
                          interface: *const wl_interface,
                          version: libc::c_int, id: uint32_t)
     -> *mut wl_resource;
    #[no_mangle]
    fn wl_resource_set_implementation(resource: *mut wl_resource,
                                      implementation: *const libc::c_void,
                                      data: *mut libc::c_void,
                                      destroy: wl_resource_destroy_func_t);
    #[no_mangle]
    fn wl_resource_destroy(resource: *mut wl_resource);
    #[no_mangle]
    fn wl_resource_get_client(resource: *mut wl_resource) -> *mut wl_client;
    #[no_mangle]
    fn wl_resource_set_user_data(resource: *mut wl_resource,
                                 data: *mut libc::c_void);
    #[no_mangle]
    fn wl_resource_get_user_data(resource: *mut wl_resource)
     -> *mut libc::c_void;
    #[no_mangle]
    fn wl_resource_get_version(resource: *mut wl_resource) -> libc::c_int;
    #[no_mangle]
    fn wl_resource_instance_of(resource: *mut wl_resource,
                               interface: *const wl_interface,
                               implementation: *const libc::c_void)
     -> libc::c_int;
    #[no_mangle]
    fn wlr_output_from_resource(resource: *mut wl_resource)
     -> *mut wlr_output;
    /* *
 * Set the lifetime role for this surface. Returns 0 on success or -1 if the
 * role cannot be set.
 */
    #[no_mangle]
    fn wlr_surface_set_role(surface: *mut wlr_surface,
                            role: *const wlr_surface_role,
                            role_data: *mut libc::c_void,
                            error_resource: *mut wl_resource,
                            error_code: uint32_t) -> bool;
    /* *
 * Whether or not this surface currently has an attached buffer. A surface has
 * an attached buffer when it commits with a non-null buffer in its pending
 * state. A surface will not have a buffer if it has never committed one, has
 * committed a null buffer, or something went wrong with uploading the buffer.
 */
    #[no_mangle]
    fn wlr_surface_has_buffer(surface: *mut wlr_surface) -> bool;
    /* *
 * Find a surface in this surface's tree that accepts input events at the given
 * surface-local coordinates. Returns the surface and coordinates in the leaf
 * surface coordinate system or NULL if no surface is found at that location.
 */
    #[no_mangle]
    fn wlr_surface_surface_at(surface: *mut wlr_surface, sx: libc::c_double,
                              sy: libc::c_double, sub_x: *mut libc::c_double,
                              sub_y: *mut libc::c_double) -> *mut wlr_surface;
    #[no_mangle]
    fn wlr_surface_from_resource(resource: *mut wl_resource)
     -> *mut wlr_surface;
    /* *
 * Call `iterator` on each surface in the surface tree, with the surface's
 * position relative to the root surface. The function is called from root to
 * leaves (in rendering order).
 */
    #[no_mangle]
    fn wlr_surface_for_each_surface(surface: *mut wlr_surface,
                                    iterator: wlr_surface_iterator_func_t,
                                    user_data: *mut libc::c_void);
    /* *
 * @page page_wlr_layer_shell_unstable_v1 The wlr_layer_shell_unstable_v1 protocol
 * @section page_ifaces_wlr_layer_shell_unstable_v1 Interfaces
 * - @subpage page_iface_zwlr_layer_shell_v1 - create surfaces that are layers of the desktop
 * - @subpage page_iface_zwlr_layer_surface_v1 - layer metadata interface
 * @section page_copyright_wlr_layer_shell_unstable_v1 Copyright
 * <pre>
 *
 * Copyright © 2017 Drew DeVault
 *
 * Permission to use, copy, modify, distribute, and sell this
 * software and its documentation for any purpose is hereby granted
 * without fee, provided that the above copyright notice appear in
 * all copies and that both that copyright notice and this permission
 * notice appear in supporting documentation, and that the name of
 * the copyright holders not be used in advertising or publicity
 * pertaining to distribution of the software without specific,
 * written prior permission.  The copyright holders make no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied
 * warranty.
 *
 * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
 * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
 * FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
 * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
 * ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
 * THIS SOFTWARE.
 * </pre>
 */
    /* *
 * @page page_iface_zwlr_layer_shell_v1 zwlr_layer_shell_v1
 * @section page_iface_zwlr_layer_shell_v1_desc Description
 *
 * Clients can use this interface to assign the surface_layer role to
 * wl_surfaces. Such surfaces are assigned to a "layer" of the output and
 * rendered with a defined z-depth respective to each other. They may also be
 * anchored to the edges and corners of a screen and specify input handling
 * semantics. This interface should be suitable for the implementation of
 * many desktop shell components, and a broad number of other applications
 * that interact with the desktop.
 * @section page_iface_zwlr_layer_shell_v1_api API
 * See @ref iface_zwlr_layer_shell_v1.
 */
/* *
 * @defgroup iface_zwlr_layer_shell_v1 The zwlr_layer_shell_v1 interface
 *
 * Clients can use this interface to assign the surface_layer role to
 * wl_surfaces. Such surfaces are assigned to a "layer" of the output and
 * rendered with a defined z-depth respective to each other. They may also be
 * anchored to the edges and corners of a screen and specify input handling
 * semantics. This interface should be suitable for the implementation of
 * many desktop shell components, and a broad number of other applications
 * that interact with the desktop.
 */
    #[no_mangle]
    static zwlr_layer_shell_v1_interface: wl_interface;
    #[no_mangle]
    static zwlr_layer_surface_v1_interface: wl_interface;
    #[no_mangle]
    fn wlr_xdg_popup_destroy(surface: *mut wlr_xdg_surface);
    #[no_mangle]
    fn wlr_xdg_surface_from_popup_resource(resource: *mut wl_resource)
     -> *mut wlr_xdg_surface;
    #[no_mangle]
    fn wlr_xdg_surface_surface_at(surface: *mut wlr_xdg_surface,
                                  sx: libc::c_double, sy: libc::c_double,
                                  sub_x: *mut libc::c_double,
                                  sub_y: *mut libc::c_double)
     -> *mut wlr_surface;
    #[no_mangle]
    fn _wlr_log(verbosity: wlr_log_importance, format: *const libc::c_char,
                _: ...);
    #[no_mangle]
    fn wlr_signal_emit_safe(signal: *mut wl_signal, data: *mut libc::c_void);
}
pub type size_t = libc::c_ulong;
pub type __int32_t = libc::c_int;
pub type __uint32_t = libc::c_uint;
pub type __time_t = libc::c_long;
pub type __syscall_slong_t = libc::c_long;
pub type int32_t = __int32_t;
pub type uint32_t = __uint32_t;

#[repr(C)]#[derive(Copy, Clone)]
pub struct wl_object {
    pub interface: *const wl_interface,
    pub implementation: *const libc::c_void,
    pub id: uint32_t,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct wl_interface {
    pub name: *const libc::c_char,
    pub version: libc::c_int,
    pub method_count: libc::c_int,
    pub methods: *const wl_message,
    pub event_count: libc::c_int,
    pub events: *const wl_message,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct wl_message {
    pub name: *const libc::c_char,
    pub signature: *const libc::c_char,
    pub types: *mut *const wl_interface,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct wl_list {
    pub prev: *mut wl_list,
    pub next: *mut wl_list,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct wl_listener {
    pub link: wl_list,
    pub notify: wl_notify_func_t,
}
pub type wl_notify_func_t
    =
    Option<unsafe extern "C" fn(_: *mut wl_listener, _: *mut libc::c_void)
               -> ()>;
pub type wl_global_bind_func_t
    =
    Option<unsafe extern "C" fn(_: *mut wl_client, _: *mut libc::c_void,
                                _: uint32_t, _: uint32_t) -> ()>;

#[repr(C)]#[derive(Copy, Clone)]
pub struct wl_resource {
    pub object: wl_object,
    pub destroy: wl_resource_destroy_func_t,
    pub link: wl_list,
    pub destroy_signal: wl_signal,
    pub client: *mut wl_client,
    pub data: *mut libc::c_void,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct wl_signal {
    pub listener_list: wl_list,
}
pub type wl_resource_destroy_func_t
    =
    Option<unsafe extern "C" fn(_: *mut wl_resource) -> ()>;
/*
 * 32 bit regions
 */

#[repr(C)]#[derive(Copy, Clone)]
pub struct pixman_region32_data {
    pub size: libc::c_long,
    pub numRects: libc::c_long,
}
pub type pixman_region32_data_t = pixman_region32_data;

#[repr(C)]#[derive(Copy, Clone)]
pub struct pixman_box32 {
    pub x1: int32_t,
    pub y1: int32_t,
    pub x2: int32_t,
    pub y2: int32_t,
}
pub type pixman_box32_t = pixman_box32;

#[repr(C)]#[derive(Copy, Clone)]
pub struct pixman_region32 {
    pub extents: pixman_box32_t,
    pub data: *mut pixman_region32_data_t,
}
pub type pixman_region32_t = pixman_region32;
pub type wl_output_subpixel = libc::c_uint;
pub const WL_OUTPUT_SUBPIXEL_VERTICAL_BGR: wl_output_subpixel = 5;
pub const WL_OUTPUT_SUBPIXEL_VERTICAL_RGB: wl_output_subpixel = 4;
pub const WL_OUTPUT_SUBPIXEL_HORIZONTAL_BGR: wl_output_subpixel = 3;
pub const WL_OUTPUT_SUBPIXEL_HORIZONTAL_RGB: wl_output_subpixel = 2;
pub const WL_OUTPUT_SUBPIXEL_NONE: wl_output_subpixel = 1;
pub const WL_OUTPUT_SUBPIXEL_UNKNOWN: wl_output_subpixel = 0;
pub type wl_output_transform = libc::c_uint;
pub const WL_OUTPUT_TRANSFORM_FLIPPED_270: wl_output_transform = 7;
pub const WL_OUTPUT_TRANSFORM_FLIPPED_180: wl_output_transform = 6;
pub const WL_OUTPUT_TRANSFORM_FLIPPED_90: wl_output_transform = 5;
pub const WL_OUTPUT_TRANSFORM_FLIPPED: wl_output_transform = 4;
pub const WL_OUTPUT_TRANSFORM_270: wl_output_transform = 3;
pub const WL_OUTPUT_TRANSFORM_180: wl_output_transform = 2;
pub const WL_OUTPUT_TRANSFORM_90: wl_output_transform = 1;
pub const WL_OUTPUT_TRANSFORM_NORMAL: wl_output_transform = 0;
/*
 * This an unstable interface of wlroots. No guarantees are made regarding the
 * future consistency of this API.
 */

#[repr(C)]#[derive(Copy, Clone)]
pub struct wlr_box {
    pub x: libc::c_int,
    pub y: libc::c_int,
    pub width: libc::c_int,
    pub height: libc::c_int,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
/*
 * This an unstable interface of wlroots. No guarantees are made regarding the
 * future consistency of this API.
 */
/* *
 * A client buffer.
 */

#[repr(C)]#[derive(Copy, Clone)]
pub struct wlr_buffer {
    pub resource: *mut wl_resource,
    pub texture: *mut crate::src::backend::drm::atomic::wlr_texture,
    pub released: bool,
    pub n_refs: size_t,
    pub resource_destroy: wl_listener,
}
/*
 * This an unstable interface of wlroots. No guarantees are made regarding the
 * future consistency of this API.
 */

#[repr(C)]#[derive(Copy, Clone)]
pub struct wlr_output_mode {
    pub width: int32_t,
    pub height: int32_t,
    pub refresh: int32_t,
    pub preferred: bool,
    pub link: wl_list,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct wlr_output_cursor {
    pub output: *mut wlr_output,
    pub x: libc::c_double,
    pub y: libc::c_double,
    pub enabled: bool,
    pub visible: bool,
    pub width: uint32_t,
    pub height: uint32_t,
    pub hotspot_x: int32_t,
    pub hotspot_y: int32_t,
    pub link: wl_list,
    pub texture: *mut crate::src::backend::drm::atomic::wlr_texture,
    pub surface: *mut wlr_surface,
    pub surface_commit: wl_listener,
    pub surface_destroy: wl_listener,
    pub events: C2RustUnnamed,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct C2RustUnnamed {
    pub destroy: wl_signal,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct wlr_surface {
    pub resource: *mut wl_resource,
    pub renderer: *mut crate::src::backend::drm::atomic::wlr_renderer,
    pub buffer: *mut wlr_buffer,
    pub sx: libc::c_int,
    pub sy: libc::c_int,
    pub buffer_damage: pixman_region32_t,
    pub opaque_region: pixman_region32_t,
    pub input_region: pixman_region32_t,
    pub current: wlr_surface_state,
    pub pending: wlr_surface_state,
    pub previous: wlr_surface_state,
    pub role: *const wlr_surface_role,
    pub role_data: *mut libc::c_void,
    pub events: C2RustUnnamed_0,
    pub subsurfaces: wl_list,
    pub subsurface_pending_list: wl_list,
    pub renderer_destroy: wl_listener,
    pub data: *mut libc::c_void,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct C2RustUnnamed_0 {
    pub commit: wl_signal,
    pub new_subsurface: wl_signal,
    pub destroy: wl_signal,
}
/*
 * This an unstable interface of wlroots. No guarantees are made regarding the
 * future consistency of this API.
 */
// enum wlr_surface_state_field
// relative to previous position
// clipped to bounds
// wl_resource
// in surface-local coordinates

#[repr(C)]#[derive(Copy, Clone)]
pub struct wlr_surface_role {
    pub name: *const libc::c_char,
    pub commit: Option<unsafe extern "C" fn(_: *mut wlr_surface) -> ()>,
    pub precommit: Option<unsafe extern "C" fn(_: *mut wlr_surface) -> ()>,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct wlr_surface_state {
    pub committed: uint32_t,
    pub buffer_resource: *mut wl_resource,
    pub dx: int32_t,
    pub dy: int32_t,
    pub surface_damage: pixman_region32_t,
    pub buffer_damage: pixman_region32_t,
    pub opaque: pixman_region32_t,
    pub input: pixman_region32_t,
    pub transform: wl_output_transform,
    pub scale: int32_t,
    pub frame_callback_list: wl_list,
    pub width: libc::c_int,
    pub height: libc::c_int,
    pub buffer_width: libc::c_int,
    pub buffer_height: libc::c_int,
    pub buffer_destroy: wl_listener,
}
/* *
 * A compositor output region. This typically corresponds to a monitor that
 * displays part of the compositor space.
 *
 * The `frame` event will be emitted when it is a good time for the compositor
 * to submit a new frame.
 *
 * To render a new frame, compositors should call `wlr_output_attach_render`,
 * render and call `wlr_output_commit`. No rendering should happen outside a
 * `frame` event handler or before `wlr_output_attach_render`.
 */

#[repr(C)]#[derive(Copy, Clone)]
pub struct wlr_output {
    pub impl_0: *const crate::src::backend::drm::backend::wlr_output_impl,
    pub backend: *mut crate::src::backend::backend::wlr_backend,
    pub display: *mut wl_display,
    pub global: *mut wl_global,
    pub resources: wl_list,
    pub name: [libc::c_char; 24],
    pub make: [libc::c_char; 56],
    pub model: [libc::c_char; 16],
    pub serial: [libc::c_char; 16],
    pub phys_width: int32_t,
    pub phys_height: int32_t,
    pub modes: wl_list,
    pub current_mode: *mut wlr_output_mode,
    pub width: int32_t,
    pub height: int32_t,
    pub refresh: int32_t,
    pub enabled: bool,
    pub scale: libc::c_float,
    pub subpixel: wl_output_subpixel,
    pub transform: wl_output_transform,
    pub needs_frame: bool,
    pub damage: pixman_region32_t,
    pub frame_pending: bool,
    pub transform_matrix: [libc::c_float; 9],
    pub pending: wlr_output_state,
    pub commit_seq: uint32_t,
    pub events: C2RustUnnamed_1,
    pub idle_frame: *mut wl_event_source,
    pub idle_done: *mut wl_event_source,
    pub attach_render_locks: libc::c_int,
    pub cursors: wl_list,
    pub hardware_cursor: *mut wlr_output_cursor,
    pub software_cursor_locks: libc::c_int,
    pub display_destroy: wl_listener,
    pub data: *mut libc::c_void,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct C2RustUnnamed_1 {
    pub frame: wl_signal,
    pub needs_frame: wl_signal,
    pub precommit: wl_signal,
    pub commit: wl_signal,
    pub present: wl_signal,
    pub enable: wl_signal,
    pub mode: wl_signal,
    pub scale: wl_signal,
    pub transform: wl_signal,
    pub destroy: wl_signal,
}
/* *
 * Holds the double-buffered output state.
 */

#[repr(C)]#[derive(Copy, Clone)]
pub struct wlr_output_state {
    pub committed: uint32_t,
    pub damage: pixman_region32_t,
    pub buffer_type: wlr_output_state_buffer_type,
    pub buffer: *mut wlr_buffer,
    // if WLR_OUTPUT_STATE_BUFFER_SCANOUT
}
pub type wlr_output_state_buffer_type = libc::c_uint;
pub const WLR_OUTPUT_STATE_BUFFER_SCANOUT: wlr_output_state_buffer_type = 1;
pub const WLR_OUTPUT_STATE_BUFFER_RENDER: wlr_output_state_buffer_type = 0;
pub type wlr_surface_iterator_func_t
    =
    Option<unsafe extern "C" fn(_: *mut wlr_surface, _: libc::c_int,
                                _: libc::c_int, _: *mut libc::c_void) -> ()>;
pub type zwlr_layer_shell_v1_error = libc::c_uint;
pub const ZWLR_LAYER_SHELL_V1_ERROR_ALREADY_CONSTRUCTED:
          zwlr_layer_shell_v1_error =
    2;
pub const ZWLR_LAYER_SHELL_V1_ERROR_INVALID_LAYER: zwlr_layer_shell_v1_error =
    1;
pub const ZWLR_LAYER_SHELL_V1_ERROR_ROLE: zwlr_layer_shell_v1_error = 0;
pub type zwlr_layer_shell_v1_layer = libc::c_uint;
pub const ZWLR_LAYER_SHELL_V1_LAYER_OVERLAY: zwlr_layer_shell_v1_layer = 3;
pub const ZWLR_LAYER_SHELL_V1_LAYER_TOP: zwlr_layer_shell_v1_layer = 2;
pub const ZWLR_LAYER_SHELL_V1_LAYER_BOTTOM: zwlr_layer_shell_v1_layer = 1;
pub const ZWLR_LAYER_SHELL_V1_LAYER_BACKGROUND: zwlr_layer_shell_v1_layer = 0;

#[repr(C)]#[derive(Copy, Clone)]
pub struct zwlr_layer_shell_v1_interface {
    pub get_layer_surface: Option<unsafe extern "C" fn(_: *mut wl_client,
                                                       _: *mut wl_resource,
                                                       _: uint32_t,
                                                       _: *mut wl_resource,
                                                       _: *mut wl_resource,
                                                       _: uint32_t,
                                                       _: *const libc::c_char)
                                      -> ()>,
}
pub type zwlr_layer_surface_v1_error = libc::c_uint;
pub const ZWLR_LAYER_SURFACE_V1_ERROR_INVALID_ANCHOR:
          zwlr_layer_surface_v1_error =
    2;
pub const ZWLR_LAYER_SURFACE_V1_ERROR_INVALID_SIZE:
          zwlr_layer_surface_v1_error =
    1;
pub const ZWLR_LAYER_SURFACE_V1_ERROR_INVALID_SURFACE_STATE:
          zwlr_layer_surface_v1_error =
    0;
pub type zwlr_layer_surface_v1_anchor = libc::c_uint;
pub const ZWLR_LAYER_SURFACE_V1_ANCHOR_RIGHT: zwlr_layer_surface_v1_anchor =
    8;
pub const ZWLR_LAYER_SURFACE_V1_ANCHOR_LEFT: zwlr_layer_surface_v1_anchor = 4;
pub const ZWLR_LAYER_SURFACE_V1_ANCHOR_BOTTOM: zwlr_layer_surface_v1_anchor =
    2;
pub const ZWLR_LAYER_SURFACE_V1_ANCHOR_TOP: zwlr_layer_surface_v1_anchor = 1;

#[repr(C)]#[derive(Copy, Clone)]
pub struct zwlr_layer_surface_v1_interface {
    pub set_size: Option<unsafe extern "C" fn(_: *mut wl_client,
                                              _: *mut wl_resource,
                                              _: uint32_t, _: uint32_t)
                             -> ()>,
    pub set_anchor: Option<unsafe extern "C" fn(_: *mut wl_client,
                                                _: *mut wl_resource,
                                                _: uint32_t) -> ()>,
    pub set_exclusive_zone: Option<unsafe extern "C" fn(_: *mut wl_client,
                                                        _: *mut wl_resource,
                                                        _: int32_t) -> ()>,
    pub set_margin: Option<unsafe extern "C" fn(_: *mut wl_client,
                                                _: *mut wl_resource,
                                                _: int32_t, _: int32_t,
                                                _: int32_t, _: int32_t)
                               -> ()>,
    pub set_keyboard_interactivity: Option<unsafe extern "C" fn(_:
                                                                    *mut wl_client,
                                                                _:
                                                                    *mut wl_resource,
                                                                _: uint32_t)
                                               -> ()>,
    pub get_popup: Option<unsafe extern "C" fn(_: *mut wl_client,
                                               _: *mut wl_resource,
                                               _: *mut wl_resource) -> ()>,
    pub ack_configure: Option<unsafe extern "C" fn(_: *mut wl_client,
                                                   _: *mut wl_resource,
                                                   _: uint32_t) -> ()>,
    pub destroy: Option<unsafe extern "C" fn(_: *mut wl_client,
                                             _: *mut wl_resource) -> ()>,
    pub set_layer: Option<unsafe extern "C" fn(_: *mut wl_client,
                                               _: *mut wl_resource,
                                               _: uint32_t) -> ()>,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct wlr_layer_shell_v1 {
    pub global: *mut wl_global,
    pub surfaces: wl_list,
    pub display_destroy: wl_listener,
    pub events: C2RustUnnamed_2,
    pub data: *mut libc::c_void,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct C2RustUnnamed_2 {
    pub new_surface: wl_signal,
    pub destroy: wl_signal,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct wlr_layer_surface_v1_state {
    pub anchor: uint32_t,
    pub exclusive_zone: int32_t,
    pub margin: C2RustUnnamed_3,
    pub keyboard_interactive: bool,
    pub desired_width: uint32_t,
    pub desired_height: uint32_t,
    pub actual_width: uint32_t,
    pub actual_height: uint32_t,
    pub layer: zwlr_layer_shell_v1_layer,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct C2RustUnnamed_3 {
    pub top: uint32_t,
    pub right: uint32_t,
    pub bottom: uint32_t,
    pub left: uint32_t,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct wlr_layer_surface_v1_configure {
    pub link: wl_list,
    pub serial: uint32_t,
    pub state: wlr_layer_surface_v1_state,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct wlr_layer_surface_v1 {
    pub link: wl_list,
    pub surface: *mut wlr_surface,
    pub output: *mut wlr_output,
    pub resource: *mut wl_resource,
    pub shell: *mut wlr_layer_shell_v1,
    pub popups: wl_list,
    pub namespace: *mut libc::c_char,
    pub added: bool,
    pub configured: bool,
    pub mapped: bool,
    pub closed: bool,
    pub configure_serial: uint32_t,
    pub configure_next_serial: uint32_t,
    pub configure_list: wl_list,
    pub acked_configure: *mut wlr_layer_surface_v1_configure,
    pub client_pending: wlr_layer_surface_v1_state,
    pub server_pending: wlr_layer_surface_v1_state,
    pub current: wlr_layer_surface_v1_state,
    pub surface_destroy: wl_listener,
    pub events: C2RustUnnamed_4,
    pub data: *mut libc::c_void,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct C2RustUnnamed_4 {
    pub destroy: wl_signal,
    pub map: wl_signal,
    pub unmap: wl_signal,
    pub new_popup: wl_signal,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct wlr_xdg_popup {
    pub base: *mut wlr_xdg_surface,
    pub link: wl_list,
    pub resource: *mut wl_resource,
    pub committed: bool,
    pub parent: *mut wlr_surface,
    pub seat: *mut wlr_seat,
    pub geometry: wlr_box,
    pub positioner: wlr_xdg_positioner,
    pub grab_link: wl_list,
}
/*
 * This an unstable interface of wlroots. No guarantees are made regarding the
 * future consistency of this API.
 */
/* *
		 * The `new_surface` event signals that a client has requested to
		 * create a new shell surface. At this point, the surface is ready to
		 * be configured but is not mapped or ready receive input events. The
		 * surface will be ready to be managed on the `map` event.
		 */
// wlr_xdg_shell::clients

#[repr(C)]#[derive(Copy, Clone)]
pub struct wlr_xdg_positioner {
    pub resource: *mut wl_resource,
    pub anchor_rect: wlr_box,
    pub anchor: xdg_positioner_anchor,
    pub gravity: xdg_positioner_gravity,
    pub constraint_adjustment: xdg_positioner_constraint_adjustment,
    pub size: C2RustUnnamed_6,
    pub offset: C2RustUnnamed_5,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct C2RustUnnamed_5 {
    pub x: int32_t,
    pub y: int32_t,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct C2RustUnnamed_6 {
    pub width: int32_t,
    pub height: int32_t,
}
/* XDG_POSITIONER_GRAVITY_ENUM */
/* *
 * @ingroup iface_xdg_positioner
 * vertically resize the surface
 *
 * Resize the surface vertically so that it is completely unconstrained.
 */
pub type xdg_positioner_constraint_adjustment = libc::c_uint;
pub const XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_RESIZE_Y:
          xdg_positioner_constraint_adjustment =
    32;
pub const XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_RESIZE_X:
          xdg_positioner_constraint_adjustment =
    16;
pub const XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_FLIP_Y:
          xdg_positioner_constraint_adjustment =
    8;
pub const XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_FLIP_X:
          xdg_positioner_constraint_adjustment =
    4;
pub const XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_SLIDE_Y:
          xdg_positioner_constraint_adjustment =
    2;
pub const XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_SLIDE_X:
          xdg_positioner_constraint_adjustment =
    1;
pub const XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_NONE:
          xdg_positioner_constraint_adjustment =
    0;
/* XDG_POSITIONER_ANCHOR_ENUM */
pub type xdg_positioner_gravity = libc::c_uint;
pub const XDG_POSITIONER_GRAVITY_BOTTOM_RIGHT: xdg_positioner_gravity = 8;
pub const XDG_POSITIONER_GRAVITY_TOP_RIGHT: xdg_positioner_gravity = 7;
pub const XDG_POSITIONER_GRAVITY_BOTTOM_LEFT: xdg_positioner_gravity = 6;
pub const XDG_POSITIONER_GRAVITY_TOP_LEFT: xdg_positioner_gravity = 5;
pub const XDG_POSITIONER_GRAVITY_RIGHT: xdg_positioner_gravity = 4;
pub const XDG_POSITIONER_GRAVITY_LEFT: xdg_positioner_gravity = 3;
pub const XDG_POSITIONER_GRAVITY_BOTTOM: xdg_positioner_gravity = 2;
pub const XDG_POSITIONER_GRAVITY_TOP: xdg_positioner_gravity = 1;
pub const XDG_POSITIONER_GRAVITY_NONE: xdg_positioner_gravity = 0;
/* Generated by wayland-scanner 1.17.0 */
/* *
 * @page page_xdg_shell The xdg_shell protocol
 * @section page_ifaces_xdg_shell Interfaces
 * - @subpage page_iface_xdg_wm_base - create desktop-style surfaces
 * - @subpage page_iface_xdg_positioner - child surface positioner
 * - @subpage page_iface_xdg_surface - desktop user interface surface base interface
 * - @subpage page_iface_xdg_toplevel - toplevel surface
 * - @subpage page_iface_xdg_popup - short-lived, popup surfaces for menus
 * @section page_copyright_xdg_shell Copyright
 * <pre>
 *
 * Copyright © 2008-2013 Kristian Høgsberg
 * Copyright © 2013      Rafael Antognolli
 * Copyright © 2013      Jasper St. Pierre
 * Copyright © 2010-2013 Intel Corporation
 * Copyright © 2015-2017 Samsung Electronics Co., Ltd
 * Copyright © 2015-2017 Red Hat Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 * </pre>
 */
/* *
 * @page page_iface_xdg_wm_base xdg_wm_base
 * @section page_iface_xdg_wm_base_desc Description
 *
 * The xdg_wm_base interface is exposed as a global object enabling clients
 * to turn their wl_surfaces into windows in a desktop environment. It
 * defines the basic functionality needed for clients and the compositor to
 * create windows that can be dragged, resized, maximized, etc, as well as
 * creating transient windows such as popup menus.
 * @section page_iface_xdg_wm_base_api API
 * See @ref iface_xdg_wm_base.
 */
/* *
 * @defgroup iface_xdg_wm_base The xdg_wm_base interface
 *
 * The xdg_wm_base interface is exposed as a global object enabling clients
 * to turn their wl_surfaces into windows in a desktop environment. It
 * defines the basic functionality needed for clients and the compositor to
 * create windows that can be dragged, resized, maximized, etc, as well as
 * creating transient windows such as popup menus.
 */
/* *
 * @page page_iface_xdg_positioner xdg_positioner
 * @section page_iface_xdg_positioner_desc Description
 *
 * The xdg_positioner provides a collection of rules for the placement of a
 * child surface relative to a parent surface. Rules can be defined to ensure
 * the child surface remains within the visible area's borders, and to
 * specify how the child surface changes its position, such as sliding along
 * an axis, or flipping around a rectangle. These positioner-created rules are
 * constrained by the requirement that a child surface must intersect with or
 * be at least partially adjacent to its parent surface.
 *
 * See the various requests for details about possible rules.
 *
 * At the time of the request, the compositor makes a copy of the rules
 * specified by the xdg_positioner. Thus, after the request is complete the
 * xdg_positioner object can be destroyed or reused; further changes to the
 * object will have no effect on previous usages.
 *
 * For an xdg_positioner object to be considered complete, it must have a
 * non-zero size set by set_size, and a non-zero anchor rectangle set by
 * set_anchor_rect. Passing an incomplete xdg_positioner object when
 * positioning a surface raises an error.
 * @section page_iface_xdg_positioner_api API
 * See @ref iface_xdg_positioner.
 */
/* *
 * @defgroup iface_xdg_positioner The xdg_positioner interface
 *
 * The xdg_positioner provides a collection of rules for the placement of a
 * child surface relative to a parent surface. Rules can be defined to ensure
 * the child surface remains within the visible area's borders, and to
 * specify how the child surface changes its position, such as sliding along
 * an axis, or flipping around a rectangle. These positioner-created rules are
 * constrained by the requirement that a child surface must intersect with or
 * be at least partially adjacent to its parent surface.
 *
 * See the various requests for details about possible rules.
 *
 * At the time of the request, the compositor makes a copy of the rules
 * specified by the xdg_positioner. Thus, after the request is complete the
 * xdg_positioner object can be destroyed or reused; further changes to the
 * object will have no effect on previous usages.
 *
 * For an xdg_positioner object to be considered complete, it must have a
 * non-zero size set by set_size, and a non-zero anchor rectangle set by
 * set_anchor_rect. Passing an incomplete xdg_positioner object when
 * positioning a surface raises an error.
 */
/* *
 * @page page_iface_xdg_surface xdg_surface
 * @section page_iface_xdg_surface_desc Description
 *
 * An interface that may be implemented by a wl_surface, for
 * implementations that provide a desktop-style user interface.
 *
 * It provides a base set of functionality required to construct user
 * interface elements requiring management by the compositor, such as
 * toplevel windows, menus, etc. The types of functionality are split into
 * xdg_surface roles.
 *
 * Creating an xdg_surface does not set the role for a wl_surface. In order
 * to map an xdg_surface, the client must create a role-specific object
 * using, e.g., get_toplevel, get_popup. The wl_surface for any given
 * xdg_surface can have at most one role, and may not be assigned any role
 * not based on xdg_surface.
 *
 * A role must be assigned before any other requests are made to the
 * xdg_surface object.
 *
 * The client must call wl_surface.commit on the corresponding wl_surface
 * for the xdg_surface state to take effect.
 *
 * Creating an xdg_surface from a wl_surface which has a buffer attached or
 * committed is a client error, and any attempts by a client to attach or
 * manipulate a buffer prior to the first xdg_surface.configure call must
 * also be treated as errors.
 *
 * Mapping an xdg_surface-based role surface is defined as making it
 * possible for the surface to be shown by the compositor. Note that
 * a mapped surface is not guaranteed to be visible once it is mapped.
 *
 * For an xdg_surface to be mapped by the compositor, the following
 * conditions must be met:
 * (1) the client has assigned an xdg_surface-based role to the surface
 * (2) the client has set and committed the xdg_surface state and the
 * role-dependent state to the surface
 * (3) the client has committed a buffer to the surface
 *
 * A newly-unmapped surface is considered to have met condition (1) out
 * of the 3 required conditions for mapping a surface if its role surface
 * has not been destroyed.
 * @section page_iface_xdg_surface_api API
 * See @ref iface_xdg_surface.
 */
/* *
 * @defgroup iface_xdg_surface The xdg_surface interface
 *
 * An interface that may be implemented by a wl_surface, for
 * implementations that provide a desktop-style user interface.
 *
 * It provides a base set of functionality required to construct user
 * interface elements requiring management by the compositor, such as
 * toplevel windows, menus, etc. The types of functionality are split into
 * xdg_surface roles.
 *
 * Creating an xdg_surface does not set the role for a wl_surface. In order
 * to map an xdg_surface, the client must create a role-specific object
 * using, e.g., get_toplevel, get_popup. The wl_surface for any given
 * xdg_surface can have at most one role, and may not be assigned any role
 * not based on xdg_surface.
 *
 * A role must be assigned before any other requests are made to the
 * xdg_surface object.
 *
 * The client must call wl_surface.commit on the corresponding wl_surface
 * for the xdg_surface state to take effect.
 *
 * Creating an xdg_surface from a wl_surface which has a buffer attached or
 * committed is a client error, and any attempts by a client to attach or
 * manipulate a buffer prior to the first xdg_surface.configure call must
 * also be treated as errors.
 *
 * Mapping an xdg_surface-based role surface is defined as making it
 * possible for the surface to be shown by the compositor. Note that
 * a mapped surface is not guaranteed to be visible once it is mapped.
 *
 * For an xdg_surface to be mapped by the compositor, the following
 * conditions must be met:
 * (1) the client has assigned an xdg_surface-based role to the surface
 * (2) the client has set and committed the xdg_surface state and the
 * role-dependent state to the surface
 * (3) the client has committed a buffer to the surface
 *
 * A newly-unmapped surface is considered to have met condition (1) out
 * of the 3 required conditions for mapping a surface if its role surface
 * has not been destroyed.
 */
/* *
 * @page page_iface_xdg_toplevel xdg_toplevel
 * @section page_iface_xdg_toplevel_desc Description
 *
 * This interface defines an xdg_surface role which allows a surface to,
 * among other things, set window-like properties such as maximize,
 * fullscreen, and minimize, set application-specific metadata like title and
 * id, and well as trigger user interactive operations such as interactive
 * resize and move.
 *
 * Unmapping an xdg_toplevel means that the surface cannot be shown
 * by the compositor until it is explicitly mapped again.
 * All active operations (e.g., move, resize) are canceled and all
 * attributes (e.g. title, state, stacking, ...) are discarded for
 * an xdg_toplevel surface when it is unmapped.
 *
 * Attaching a null buffer to a toplevel unmaps the surface.
 * @section page_iface_xdg_toplevel_api API
 * See @ref iface_xdg_toplevel.
 */
/* *
 * @defgroup iface_xdg_toplevel The xdg_toplevel interface
 *
 * This interface defines an xdg_surface role which allows a surface to,
 * among other things, set window-like properties such as maximize,
 * fullscreen, and minimize, set application-specific metadata like title and
 * id, and well as trigger user interactive operations such as interactive
 * resize and move.
 *
 * Unmapping an xdg_toplevel means that the surface cannot be shown
 * by the compositor until it is explicitly mapped again.
 * All active operations (e.g., move, resize) are canceled and all
 * attributes (e.g. title, state, stacking, ...) are discarded for
 * an xdg_toplevel surface when it is unmapped.
 *
 * Attaching a null buffer to a toplevel unmaps the surface.
 */
/* *
 * @page page_iface_xdg_popup xdg_popup
 * @section page_iface_xdg_popup_desc Description
 *
 * A popup surface is a short-lived, temporary surface. It can be used to
 * implement for example menus, popovers, tooltips and other similar user
 * interface concepts.
 *
 * A popup can be made to take an explicit grab. See xdg_popup.grab for
 * details.
 *
 * When the popup is dismissed, a popup_done event will be sent out, and at
 * the same time the surface will be unmapped. See the xdg_popup.popup_done
 * event for details.
 *
 * Explicitly destroying the xdg_popup object will also dismiss the popup and
 * unmap the surface. Clients that want to dismiss the popup when another
 * surface of their own is clicked should dismiss the popup using the destroy
 * request.
 *
 * A newly created xdg_popup will be stacked on top of all previously created
 * xdg_popup surfaces associated with the same xdg_toplevel.
 *
 * The parent of an xdg_popup must be mapped (see the xdg_surface
 * description) before the xdg_popup itself.
 *
 * The x and y arguments passed when creating the popup object specify
 * where the top left of the popup should be placed, relative to the
 * local surface coordinates of the parent surface. See
 * xdg_surface.get_popup. An xdg_popup must intersect with or be at least
 * partially adjacent to its parent surface.
 *
 * The client must call wl_surface.commit on the corresponding wl_surface
 * for the xdg_popup state to take effect.
 * @section page_iface_xdg_popup_api API
 * See @ref iface_xdg_popup.
 */
/* *
 * @defgroup iface_xdg_popup The xdg_popup interface
 *
 * A popup surface is a short-lived, temporary surface. It can be used to
 * implement for example menus, popovers, tooltips and other similar user
 * interface concepts.
 *
 * A popup can be made to take an explicit grab. See xdg_popup.grab for
 * details.
 *
 * When the popup is dismissed, a popup_done event will be sent out, and at
 * the same time the surface will be unmapped. See the xdg_popup.popup_done
 * event for details.
 *
 * Explicitly destroying the xdg_popup object will also dismiss the popup and
 * unmap the surface. Clients that want to dismiss the popup when another
 * surface of their own is clicked should dismiss the popup using the destroy
 * request.
 *
 * A newly created xdg_popup will be stacked on top of all previously created
 * xdg_popup surfaces associated with the same xdg_toplevel.
 *
 * The parent of an xdg_popup must be mapped (see the xdg_surface
 * description) before the xdg_popup itself.
 *
 * The x and y arguments passed when creating the popup object specify
 * where the top left of the popup should be placed, relative to the
 * local surface coordinates of the parent surface. See
 * xdg_surface.get_popup. An xdg_popup must intersect with or be at least
 * partially adjacent to its parent surface.
 *
 * The client must call wl_surface.commit on the corresponding wl_surface
 * for the xdg_popup state to take effect.
 */
/* *
	 * given wl_surface has another role
	 */
/* *
	 * xdg_wm_base was destroyed before children
	 */
/* *
	 * the client tried to map or destroy a non-topmost popup
	 */
/* *
	 * the client specified an invalid popup parent surface
	 */
/* *
	 * the client provided an invalid surface state
	 */
/* *
	 * the client provided an invalid positioner
	 */
/* XDG_WM_BASE_ERROR_ENUM */
/* *
 * @ingroup iface_xdg_wm_base
 * @struct xdg_wm_base_interface
 */
/* *
	 * destroy xdg_wm_base
	 *
	 * Destroy this xdg_wm_base object.
	 *
	 * Destroying a bound xdg_wm_base object while there are surfaces
	 * still alive created by this xdg_wm_base object instance is
	 * illegal and will result in a protocol error.
	 */
/* *
	 * create a positioner object
	 *
	 * Create a positioner object. A positioner object is used to
	 * position surfaces relative to some parent surface. See the
	 * interface description and xdg_surface.get_popup for details.
	 */
/* *
	 * create a shell surface from a surface
	 *
	 * This creates an xdg_surface for the given surface. While
	 * xdg_surface itself is not a role, the corresponding surface may
	 * only be assigned a role extending xdg_surface, such as
	 * xdg_toplevel or xdg_popup.
	 *
	 * This creates an xdg_surface for the given surface. An
	 * xdg_surface is used as basis to define a role to a given
	 * surface, such as xdg_toplevel or xdg_popup. It also manages
	 * functionality shared between xdg_surface based surface roles.
	 *
	 * See the documentation of xdg_surface for more details about what
	 * an xdg_surface is and how it is used.
	 */
/* *
	 * respond to a ping event
	 *
	 * A client must respond to a ping event with a pong request or
	 * the client may be deemed unresponsive. See xdg_wm_base.ping.
	 * @param serial serial of the ping event
	 */
/* *
 * @ingroup iface_xdg_wm_base
 */
/* *
 * @ingroup iface_xdg_wm_base
 */
/* *
 * @ingroup iface_xdg_wm_base
 */
/* *
 * @ingroup iface_xdg_wm_base
 */
/* *
 * @ingroup iface_xdg_wm_base
 */
/* *
 * @ingroup iface_xdg_wm_base
 * Sends an ping event to the client owning the resource.
 * @param resource_ The client's resource
 * @param serial pass this to the pong request
 */
/* *
	 * invalid input provided
	 */
/* XDG_POSITIONER_ERROR_ENUM */
pub type xdg_positioner_anchor = libc::c_uint;
pub const XDG_POSITIONER_ANCHOR_BOTTOM_RIGHT: xdg_positioner_anchor = 8;
pub const XDG_POSITIONER_ANCHOR_TOP_RIGHT: xdg_positioner_anchor = 7;
pub const XDG_POSITIONER_ANCHOR_BOTTOM_LEFT: xdg_positioner_anchor = 6;
pub const XDG_POSITIONER_ANCHOR_TOP_LEFT: xdg_positioner_anchor = 5;
pub const XDG_POSITIONER_ANCHOR_RIGHT: xdg_positioner_anchor = 4;
pub const XDG_POSITIONER_ANCHOR_LEFT: xdg_positioner_anchor = 3;
pub const XDG_POSITIONER_ANCHOR_BOTTOM: xdg_positioner_anchor = 2;
pub const XDG_POSITIONER_ANCHOR_TOP: xdg_positioner_anchor = 1;
pub const XDG_POSITIONER_ANCHOR_NONE: xdg_positioner_anchor = 0;

#[repr(C)]#[derive(Copy, Clone)]
pub struct wlr_seat {
    pub global: *mut wl_global,
    pub display: *mut wl_display,
    pub clients: wl_list,
    pub name: *mut libc::c_char,
    pub capabilities: uint32_t,
    pub last_event: timespec,
    pub selection_source: *mut crate::src::types::data_device::wlr_data_device::wlr_data_source,
    pub selection_serial: uint32_t,
    pub selection_offers: wl_list,
    pub primary_selection_source: *mut crate::src::types::wlr_data_control_v1::wlr_primary_selection_source,
    pub primary_selection_serial: uint32_t,
    pub drag: *mut crate::src::types::data_device::wlr_data_device::wlr_drag,
    pub drag_source: *mut crate::src::types::data_device::wlr_data_device::wlr_data_source,
    pub drag_serial: uint32_t,
    pub drag_offers: wl_list,
    pub pointer_state: wlr_seat_pointer_state,
    pub keyboard_state: wlr_seat_keyboard_state,
    pub touch_state: wlr_seat_touch_state,
    pub display_destroy: wl_listener,
    pub selection_source_destroy: wl_listener,
    pub primary_selection_source_destroy: wl_listener,
    pub drag_source_destroy: wl_listener,
    pub events: C2RustUnnamed_7,
    pub data: *mut libc::c_void,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct C2RustUnnamed_7 {
    pub pointer_grab_begin: wl_signal,
    pub pointer_grab_end: wl_signal,
    pub keyboard_grab_begin: wl_signal,
    pub keyboard_grab_end: wl_signal,
    pub touch_grab_begin: wl_signal,
    pub touch_grab_end: wl_signal,
    pub request_set_cursor: wl_signal,
    pub request_set_selection: wl_signal,
    pub set_selection: wl_signal,
    pub request_set_primary_selection: wl_signal,
    pub set_primary_selection: wl_signal,
    pub request_start_drag: wl_signal,
    pub start_drag: wl_signal,
    pub destroy: wl_signal,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct wlr_seat_touch_state {
    pub seat: *mut wlr_seat,
    pub touch_points: wl_list,
    pub grab_serial: uint32_t,
    pub grab_id: uint32_t,
    pub grab: *mut wlr_seat_touch_grab,
    pub default_grab: *mut wlr_seat_touch_grab,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct wlr_seat_touch_grab {
    pub interface: *const wlr_touch_grab_interface,
    pub seat: *mut wlr_seat,
    pub data: *mut libc::c_void,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct wlr_touch_grab_interface {
    pub down: Option<unsafe extern "C" fn(_: *mut wlr_seat_touch_grab,
                                          _: uint32_t,
                                          _: *mut wlr_touch_point)
                         -> uint32_t>,
    pub up: Option<unsafe extern "C" fn(_: *mut wlr_seat_touch_grab,
                                        _: uint32_t, _: *mut wlr_touch_point)
                       -> ()>,
    pub motion: Option<unsafe extern "C" fn(_: *mut wlr_seat_touch_grab,
                                            _: uint32_t,
                                            _: *mut wlr_touch_point) -> ()>,
    pub enter: Option<unsafe extern "C" fn(_: *mut wlr_seat_touch_grab,
                                           _: uint32_t,
                                           _: *mut wlr_touch_point) -> ()>,
    pub cancel: Option<unsafe extern "C" fn(_: *mut wlr_seat_touch_grab)
                           -> ()>,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct wlr_touch_point {
    pub touch_id: int32_t,
    pub surface: *mut wlr_surface,
    pub client: *mut wlr_seat_client,
    pub focus_surface: *mut wlr_surface,
    pub focus_client: *mut wlr_seat_client,
    pub sx: libc::c_double,
    pub sy: libc::c_double,
    pub surface_destroy: wl_listener,
    pub focus_surface_destroy: wl_listener,
    pub client_destroy: wl_listener,
    pub events: C2RustUnnamed_8,
    pub link: wl_list,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct C2RustUnnamed_8 {
    pub destroy: wl_signal,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct wlr_seat_client {
    pub client: *mut wl_client,
    pub seat: *mut wlr_seat,
    pub link: wl_list,
    pub resources: wl_list,
    pub pointers: wl_list,
    pub keyboards: wl_list,
    pub touches: wl_list,
    pub data_devices: wl_list,
    pub events: C2RustUnnamed_9,
    pub serials: wlr_serial_ringset,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct wlr_serial_ringset {
    pub data: [wlr_serial_range; 128],
    pub end: libc::c_int,
    pub count: libc::c_int,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct wlr_serial_range {
    pub min_incl: uint32_t,
    pub max_incl: uint32_t,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct C2RustUnnamed_9 {
    pub destroy: wl_signal,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct wlr_seat_keyboard_state {
    pub seat: *mut wlr_seat,
    pub keyboard: *mut wlr_keyboard,
    pub focused_client: *mut wlr_seat_client,
    pub focused_surface: *mut wlr_surface,
    pub keyboard_destroy: wl_listener,
    pub keyboard_keymap: wl_listener,
    pub keyboard_repeat_info: wl_listener,
    pub surface_destroy: wl_listener,
    pub grab: *mut wlr_seat_keyboard_grab,
    pub default_grab: *mut wlr_seat_keyboard_grab,
    pub events: C2RustUnnamed_10,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct C2RustUnnamed_10 {
    pub focus_change: wl_signal,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct wlr_seat_keyboard_grab {
    pub interface: *const wlr_keyboard_grab_interface,
    pub seat: *mut wlr_seat,
    pub data: *mut libc::c_void,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct wlr_keyboard_grab_interface {
    pub enter: Option<unsafe extern "C" fn(_: *mut wlr_seat_keyboard_grab,
                                           _: *mut wlr_surface,
                                           _: *mut uint32_t, _: size_t,
                                           _: *mut wlr_keyboard_modifiers)
                          -> ()>,
    pub key: Option<unsafe extern "C" fn(_: *mut wlr_seat_keyboard_grab,
                                         _: uint32_t, _: uint32_t,
                                         _: uint32_t) -> ()>,
    pub modifiers: Option<unsafe extern "C" fn(_: *mut wlr_seat_keyboard_grab,
                                               _: *mut wlr_keyboard_modifiers)
                              -> ()>,
    pub cancel: Option<unsafe extern "C" fn(_: *mut wlr_seat_keyboard_grab)
                           -> ()>,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct wlr_keyboard_modifiers {
    pub depressed: xkb_mod_mask_t,
    pub latched: xkb_mod_mask_t,
    pub locked: xkb_mod_mask_t,
    pub group: xkb_mod_mask_t,
}
pub type xkb_mod_mask_t = uint32_t;

#[repr(C)]#[derive(Copy, Clone)]
pub struct wlr_keyboard {
    pub impl_0: *const crate::src::backend::headless::input_device::wlr_keyboard_impl,
    pub group: *mut crate::src::types::wlr_keyboard_group::wlr_keyboard_group,
    pub keymap_string: *mut libc::c_char,
    pub keymap_size: size_t,
    pub keymap: *mut xkb_keymap,
    pub xkb_state: *mut xkb_state,
    pub led_indexes: [xkb_led_index_t; 3],
    pub mod_indexes: [xkb_mod_index_t; 8],
    pub keycodes: [uint32_t; 32],
    pub num_keycodes: size_t,
    pub modifiers: wlr_keyboard_modifiers,
    pub repeat_info: C2RustUnnamed_12,
    pub events: C2RustUnnamed_11,
    pub data: *mut libc::c_void,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct C2RustUnnamed_11 {
    pub key: wl_signal,
    pub modifiers: wl_signal,
    pub keymap: wl_signal,
    pub repeat_info: wl_signal,
    pub destroy: wl_signal,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct C2RustUnnamed_12 {
    pub rate: int32_t,
    pub delay: int32_t,
}
pub type xkb_mod_index_t = uint32_t;
pub type xkb_led_index_t = uint32_t;

#[repr(C)]#[derive(Copy, Clone)]
pub struct wlr_seat_pointer_state {
    pub seat: *mut wlr_seat,
    pub focused_client: *mut wlr_seat_client,
    pub focused_surface: *mut wlr_surface,
    pub sx: libc::c_double,
    pub sy: libc::c_double,
    pub grab: *mut wlr_seat_pointer_grab,
    pub default_grab: *mut wlr_seat_pointer_grab,
    pub buttons: [uint32_t; 16],
    pub button_count: size_t,
    pub grab_button: uint32_t,
    pub grab_serial: uint32_t,
    pub grab_time: uint32_t,
    pub surface_destroy: wl_listener,
    pub events: C2RustUnnamed_13,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct C2RustUnnamed_13 {
    pub focus_change: wl_signal,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct wlr_seat_pointer_grab {
    pub interface: *const wlr_pointer_grab_interface,
    pub seat: *mut wlr_seat,
    pub data: *mut libc::c_void,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct wlr_pointer_grab_interface {
    pub enter: Option<unsafe extern "C" fn(_: *mut wlr_seat_pointer_grab,
                                           _: *mut wlr_surface,
                                           _: libc::c_double,
                                           _: libc::c_double) -> ()>,
    pub motion: Option<unsafe extern "C" fn(_: *mut wlr_seat_pointer_grab,
                                            _: uint32_t, _: libc::c_double,
                                            _: libc::c_double) -> ()>,
    pub button: Option<unsafe extern "C" fn(_: *mut wlr_seat_pointer_grab,
                                            _: uint32_t, _: uint32_t,
                                            _: wlr_button_state) -> uint32_t>,
    pub axis: Option<unsafe extern "C" fn(_: *mut wlr_seat_pointer_grab,
                                          _: uint32_t,
                                          _: wlr_axis_orientation,
                                          _: libc::c_double, _: int32_t,
                                          _: wlr_axis_source) -> ()>,
    pub frame: Option<unsafe extern "C" fn(_: *mut wlr_seat_pointer_grab)
                          -> ()>,
    pub cancel: Option<unsafe extern "C" fn(_: *mut wlr_seat_pointer_grab)
                           -> ()>,
}
pub type wlr_axis_source = libc::c_uint;
pub const WLR_AXIS_SOURCE_WHEEL_TILT: wlr_axis_source = 3;
pub const WLR_AXIS_SOURCE_CONTINUOUS: wlr_axis_source = 2;
pub const WLR_AXIS_SOURCE_FINGER: wlr_axis_source = 1;
pub const WLR_AXIS_SOURCE_WHEEL: wlr_axis_source = 0;
// From 0..1
pub type wlr_axis_orientation = libc::c_uint;
pub const WLR_AXIS_ORIENTATION_HORIZONTAL: wlr_axis_orientation = 1;
pub const WLR_AXIS_ORIENTATION_VERTICAL: wlr_axis_orientation = 0;
/*
 * This an unstable interface of wlroots. No guarantees are made regarding the
 * future consistency of this API.
 */
pub type wlr_button_state = libc::c_uint;
pub const WLR_BUTTON_PRESSED: wlr_button_state = 1;
pub const WLR_BUTTON_RELEASED: wlr_button_state = 0;

#[repr(C)]#[derive(Copy, Clone)]
pub struct wlr_xdg_surface {
    pub client: *mut wlr_xdg_client,
    pub resource: *mut wl_resource,
    pub surface: *mut wlr_surface,
    pub link: wl_list,
    pub role: wlr_xdg_surface_role,
    pub c2rust_unnamed: C2RustUnnamed_15,
    pub popups: wl_list,
    pub added: bool,
    pub configured: bool,
    pub mapped: bool,
    pub configure_serial: uint32_t,
    pub configure_idle: *mut wl_event_source,
    pub configure_next_serial: uint32_t,
    pub configure_list: wl_list,
    pub has_next_geometry: bool,
    pub next_geometry: wlr_box,
    pub geometry: wlr_box,
    pub surface_destroy: wl_listener,
    pub surface_commit: wl_listener,
    pub events: C2RustUnnamed_14,
    pub data: *mut libc::c_void,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct C2RustUnnamed_14 {
    pub destroy: wl_signal,
    pub ping_timeout: wl_signal,
    pub new_popup: wl_signal,
    pub map: wl_signal,
    pub unmap: wl_signal,
    pub configure: wl_signal,
    pub ack_configure: wl_signal,
}

#[repr ( C )]#[derive(Copy, Clone)]
pub union C2RustUnnamed_15 {
    pub toplevel: *mut wlr_xdg_toplevel,
    pub popup: *mut wlr_xdg_popup,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct wlr_xdg_toplevel {
    pub resource: *mut wl_resource,
    pub base: *mut wlr_xdg_surface,
    pub added: bool,
    pub parent: *mut wlr_xdg_surface,
    pub parent_unmap: wl_listener,
    pub client_pending: wlr_xdg_toplevel_state,
    pub server_pending: wlr_xdg_toplevel_state,
    pub current: wlr_xdg_toplevel_state,
    pub title: *mut libc::c_char,
    pub app_id: *mut libc::c_char,
    pub events: C2RustUnnamed_16,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct C2RustUnnamed_16 {
    pub request_maximize: wl_signal,
    pub request_fullscreen: wl_signal,
    pub request_minimize: wl_signal,
    pub request_move: wl_signal,
    pub request_resize: wl_signal,
    pub request_show_window_menu: wl_signal,
    pub set_parent: wl_signal,
    pub set_title: wl_signal,
    pub set_app_id: wl_signal,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct wlr_xdg_toplevel_state {
    pub maximized: bool,
    pub fullscreen: bool,
    pub resizing: bool,
    pub activated: bool,
    pub tiled: uint32_t,
    pub width: uint32_t,
    pub height: uint32_t,
    pub max_width: uint32_t,
    pub max_height: uint32_t,
    pub min_width: uint32_t,
    pub min_height: uint32_t,
    pub fullscreen_output: *mut wlr_output,
    pub fullscreen_output_destroy: wl_listener,
}
pub type wlr_xdg_surface_role = libc::c_uint;
pub const WLR_XDG_SURFACE_ROLE_POPUP: wlr_xdg_surface_role = 2;
pub const WLR_XDG_SURFACE_ROLE_TOPLEVEL: wlr_xdg_surface_role = 1;
pub const WLR_XDG_SURFACE_ROLE_NONE: wlr_xdg_surface_role = 0;

#[repr(C)]#[derive(Copy, Clone)]
pub struct wlr_xdg_client {
    pub shell: *mut wlr_xdg_shell,
    pub resource: *mut wl_resource,
    pub client: *mut wl_client,
    pub surfaces: wl_list,
    pub link: wl_list,
    pub ping_serial: uint32_t,
    pub ping_timer: *mut wl_event_source,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct wlr_xdg_shell {
    pub global: *mut wl_global,
    pub clients: wl_list,
    pub popup_grabs: wl_list,
    pub ping_timeout: uint32_t,
    pub display_destroy: wl_listener,
    pub events: C2RustUnnamed_17,
    pub data: *mut libc::c_void,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct C2RustUnnamed_17 {
    pub new_surface: wl_signal,
    pub destroy: wl_signal,
}
/*
 * This is a stable interface of wlroots. Future changes will be limited to:
 *
 * - New functions
 * - New struct members
 * - New enum members
 *
 * Note that wlroots does not make an ABI compatibility promise - in the future,
 * the layout and size of structs used by wlroots may change, requiring code
 * depending on this header to be recompiled (but not edited).
 *
 * Breaking changes are announced by email and follow a 1-year deprecation
 * schedule. Send an email to ~sircmpwn/wlroots-announce+subscribe@lists.sr.ht
 * to receive these announcements.
 */
pub type wlr_log_importance = libc::c_uint;
pub const WLR_LOG_IMPORTANCE_LAST: wlr_log_importance = 4;
pub const WLR_DEBUG: wlr_log_importance = 3;
pub const WLR_INFO: wlr_log_importance = 2;
pub const WLR_ERROR: wlr_log_importance = 1;
pub const WLR_SILENT: wlr_log_importance = 0;

#[repr(C)]#[derive(Copy, Clone)]
pub struct layer_surface_iterator_data {
    pub user_iterator: wlr_surface_iterator_func_t,
    pub user_data: *mut libc::c_void,
    pub x: libc::c_int,
    pub y: libc::c_int,
}
#[inline]
unsafe extern "C" fn wl_signal_init(mut signal: *mut wl_signal) {
    wl_list_init(&mut (*signal).listener_list);
}
#[inline]
unsafe extern "C" fn wl_signal_add(mut signal: *mut wl_signal,
                                   mut listener: *mut wl_listener) {
    wl_list_insert((*signal).listener_list.prev, &mut (*listener).link);
}
/* *
 * @ingroup iface_zwlr_layer_surface_v1
 */
/* *
 * @ingroup iface_zwlr_layer_surface_v1
 */
/* *
 * @ingroup iface_zwlr_layer_surface_v1
 */
/* *
 * @ingroup iface_zwlr_layer_surface_v1
 */
/* *
 * @ingroup iface_zwlr_layer_surface_v1
 */
/* *
 * @ingroup iface_zwlr_layer_surface_v1
 */
/* *
 * @ingroup iface_zwlr_layer_surface_v1
 */
/* *
 * @ingroup iface_zwlr_layer_surface_v1
 */
/* *
 * @ingroup iface_zwlr_layer_surface_v1
 */
/* *
 * @ingroup iface_zwlr_layer_surface_v1
 */
/* *
 * @ingroup iface_zwlr_layer_surface_v1
 */
/* *
 * @ingroup iface_zwlr_layer_surface_v1
 * Sends an configure event to the client owning the resource.
 * @param resource_ The client's resource
 */
#[inline]
unsafe extern "C" fn zwlr_layer_surface_v1_send_configure(mut resource_:
                                                              *mut wl_resource,
                                                          mut serial:
                                                              uint32_t,
                                                          mut width: uint32_t,
                                                          mut height:
                                                              uint32_t) {
    wl_resource_post_event(resource_, 0i32 as uint32_t, serial, width,
                           height);
}
/* *
 * @ingroup iface_zwlr_layer_surface_v1
 * Sends an closed event to the client owning the resource.
 * @param resource_ The client's resource
 */
#[inline]
unsafe extern "C" fn zwlr_layer_surface_v1_send_closed(mut resource_:
                                                           *mut wl_resource) {
    wl_resource_post_event(resource_, 1i32 as uint32_t);
}
unsafe extern "C" fn resource_handle_destroy(mut client: *mut wl_client,
                                             mut resource: *mut wl_resource) {
    wl_resource_destroy(resource);
}
unsafe extern "C" fn layer_shell_from_resource(mut resource: *mut wl_resource)
 -> *mut wlr_layer_shell_v1 {
    if wl_resource_instance_of(resource, &zwlr_layer_shell_v1_interface,
                               &layer_shell_implementation as
                                   *const zwlr_layer_shell_v1_interface as
                                   *const libc::c_void) != 0 {
    } else {
        __assert_fail(b"wl_resource_instance_of(resource, &zwlr_layer_shell_v1_interface, &layer_shell_implementation)\x00"
                          as *const u8 as *const libc::c_char,
                      b"../types/wlr_layer_shell_v1.c\x00" as *const u8 as
                          *const libc::c_char, 25i32 as libc::c_uint,
                      (*::std::mem::transmute::<&[u8; 75],
                                                &[libc::c_char; 75]>(b"struct wlr_layer_shell_v1 *layer_shell_from_resource(struct wl_resource *)\x00")).as_ptr());
    };
    return wl_resource_get_user_data(resource) as *mut wlr_layer_shell_v1;
}
unsafe extern "C" fn layer_surface_from_resource(mut resource:
                                                     *mut wl_resource)
 -> *mut wlr_layer_surface_v1 {
    if wl_resource_instance_of(resource, &zwlr_layer_surface_v1_interface,
                               &layer_surface_implementation as
                                   *const zwlr_layer_surface_v1_interface as
                                   *const libc::c_void) != 0 {
    } else {
        __assert_fail(b"wl_resource_instance_of(resource, &zwlr_layer_surface_v1_interface, &layer_surface_implementation)\x00"
                          as *const u8 as *const libc::c_char,
                      b"../types/wlr_layer_shell_v1.c\x00" as *const u8 as
                          *const libc::c_char, 32i32 as libc::c_uint,
                      (*::std::mem::transmute::<&[u8; 79],
                                                &[libc::c_char; 79]>(b"struct wlr_layer_surface_v1 *layer_surface_from_resource(struct wl_resource *)\x00")).as_ptr());
    };
    return wl_resource_get_user_data(resource) as *mut wlr_layer_surface_v1;
}
#[no_mangle]
pub unsafe extern "C" fn wlr_surface_is_layer_surface(mut surface:
                                                          *mut wlr_surface)
 -> bool {
    return (*surface).role == &layer_surface_role as *const wlr_surface_role;
}
#[no_mangle]
pub unsafe extern "C" fn wlr_layer_surface_v1_from_wlr_surface(mut surface:
                                                                   *mut wlr_surface)
 -> *mut wlr_layer_surface_v1 {
    if wlr_surface_is_layer_surface(surface) as libc::c_int != 0 {
    } else {
        __assert_fail(b"wlr_surface_is_layer_surface(surface)\x00" as
                          *const u8 as *const libc::c_char,
                      b"../types/wlr_layer_shell_v1.c\x00" as *const u8 as
                          *const libc::c_char, 44i32 as libc::c_uint,
                      (*::std::mem::transmute::<&[u8; 89],
                                                &[libc::c_char; 89]>(b"struct wlr_layer_surface_v1 *wlr_layer_surface_v1_from_wlr_surface(struct wlr_surface *)\x00")).as_ptr());
    };
    return (*surface).role_data as *mut wlr_layer_surface_v1;
}
unsafe extern "C" fn layer_surface_configure_destroy(mut configure:
                                                         *mut wlr_layer_surface_v1_configure) {
    if configure.is_null() { return }
    wl_list_remove(&mut (*configure).link);
    free(configure as *mut libc::c_void);
}
unsafe extern "C" fn layer_surface_handle_ack_configure(mut client:
                                                            *mut wl_client,
                                                        mut resource:
                                                            *mut wl_resource,
                                                        mut serial:
                                                            uint32_t) {
    let mut surface: *mut wlr_layer_surface_v1 =
        layer_surface_from_resource(resource);
    let mut found: bool = 0i32 != 0;
    let mut configure: *mut wlr_layer_surface_v1_configure =
        0 as *mut wlr_layer_surface_v1_configure;
    let mut tmp: *mut wlr_layer_surface_v1_configure =
        0 as *mut wlr_layer_surface_v1_configure;
    if surface.is_null() || (*surface).closed as libc::c_int != 0 { return }
    configure =
        ((*surface).configure_list.next as *mut libc::c_char).offset(-0) as
            *mut wlr_layer_surface_v1_configure;
    tmp =
        ((*configure).link.next as *mut libc::c_char).offset(-0) as
            *mut wlr_layer_surface_v1_configure;
    while &mut (*configure).link as *mut wl_list !=
              &mut (*surface).configure_list as *mut wl_list {
        if (*configure).serial < serial {
            layer_surface_configure_destroy(configure);
            configure = tmp;
            tmp =
                ((*configure).link.next as *mut libc::c_char).offset(-0) as
                    *mut wlr_layer_surface_v1_configure
        } else {
            if !((*configure).serial == serial) { break ; }
            found = 1i32 != 0;
            break ;
        }
    }
    if !found {
        wl_resource_post_error(resource,
                               ZWLR_LAYER_SURFACE_V1_ERROR_INVALID_SURFACE_STATE
                                   as libc::c_int as uint32_t,
                               b"wrong configure serial: %u\x00" as *const u8
                                   as *const libc::c_char, serial);
        return
    }
    if !(*surface).acked_configure.is_null() {
        layer_surface_configure_destroy((*surface).acked_configure);
    }
    (*surface).acked_configure = configure;
    wl_list_remove(&mut (*configure).link);
    wl_list_init(&mut (*configure).link);
}
unsafe extern "C" fn layer_surface_handle_set_size(mut client: *mut wl_client,
                                                   mut resource:
                                                       *mut wl_resource,
                                                   mut width: uint32_t,
                                                   mut height: uint32_t) {
    let mut surface: *mut wlr_layer_surface_v1 =
        layer_surface_from_resource(resource);
    if surface.is_null() { return }
    (*surface).client_pending.desired_width = width;
    (*surface).client_pending.desired_height = height;
}
unsafe extern "C" fn layer_surface_handle_set_anchor(mut client:
                                                         *mut wl_client,
                                                     mut resource:
                                                         *mut wl_resource,
                                                     mut anchor: uint32_t) {
    let max_anchor: uint32_t =
        (ZWLR_LAYER_SURFACE_V1_ANCHOR_TOP as libc::c_int |
             ZWLR_LAYER_SURFACE_V1_ANCHOR_BOTTOM as libc::c_int |
             ZWLR_LAYER_SURFACE_V1_ANCHOR_LEFT as libc::c_int |
             ZWLR_LAYER_SURFACE_V1_ANCHOR_RIGHT as libc::c_int) as uint32_t;
    if anchor > max_anchor {
        wl_resource_post_error(resource,
                               ZWLR_LAYER_SURFACE_V1_ERROR_INVALID_ANCHOR as
                                   libc::c_int as uint32_t,
                               b"invalid anchor %d\x00" as *const u8 as
                                   *const libc::c_char, anchor);
    }
    let mut surface: *mut wlr_layer_surface_v1 =
        layer_surface_from_resource(resource);
    if surface.is_null() { return }
    (*surface).client_pending.anchor = anchor;
}
unsafe extern "C" fn layer_surface_handle_set_exclusive_zone(mut client:
                                                                 *mut wl_client,
                                                             mut resource:
                                                                 *mut wl_resource,
                                                             mut zone:
                                                                 int32_t) {
    let mut surface: *mut wlr_layer_surface_v1 =
        layer_surface_from_resource(resource);
    if surface.is_null() { return }
    (*surface).client_pending.exclusive_zone = zone;
}
unsafe extern "C" fn layer_surface_handle_set_margin(mut client:
                                                         *mut wl_client,
                                                     mut resource:
                                                         *mut wl_resource,
                                                     mut top: int32_t,
                                                     mut right: int32_t,
                                                     mut bottom: int32_t,
                                                     mut left: int32_t) {
    let mut surface: *mut wlr_layer_surface_v1 =
        layer_surface_from_resource(resource);
    if surface.is_null() { return }
    (*surface).client_pending.margin.top = top as uint32_t;
    (*surface).client_pending.margin.right = right as uint32_t;
    (*surface).client_pending.margin.bottom = bottom as uint32_t;
    (*surface).client_pending.margin.left = left as uint32_t;
}
unsafe extern "C" fn layer_surface_handle_set_keyboard_interactivity(mut client:
                                                                         *mut wl_client,
                                                                     mut resource:
                                                                         *mut wl_resource,
                                                                     mut interactive:
                                                                         uint32_t) {
    let mut surface: *mut wlr_layer_surface_v1 =
        layer_surface_from_resource(resource);
    if surface.is_null() { return }
    (*surface).client_pending.keyboard_interactive = interactive != 0;
}
unsafe extern "C" fn layer_surface_handle_get_popup(mut client:
                                                        *mut wl_client,
                                                    mut layer_resource:
                                                        *mut wl_resource,
                                                    mut popup_resource:
                                                        *mut wl_resource) {
    let mut parent: *mut wlr_layer_surface_v1 =
        layer_surface_from_resource(layer_resource);
    let mut popup_surface: *mut wlr_xdg_surface =
        wlr_xdg_surface_from_popup_resource(popup_resource);
    if parent.is_null() { return }
    if (*popup_surface).role as libc::c_uint ==
           WLR_XDG_SURFACE_ROLE_POPUP as libc::c_int as libc::c_uint {
    } else {
        __assert_fail(b"popup_surface->role == WLR_XDG_SURFACE_ROLE_POPUP\x00"
                          as *const u8 as *const libc::c_char,
                      b"../types/wlr_layer_shell_v1.c\x00" as *const u8 as
                          *const libc::c_char, 169i32 as libc::c_uint,
                      (*::std::mem::transmute::<&[u8; 100],
                                                &[libc::c_char; 100]>(b"void layer_surface_handle_get_popup(struct wl_client *, struct wl_resource *, struct wl_resource *)\x00")).as_ptr());
    };
    let mut popup: *mut wlr_xdg_popup = (*popup_surface).c2rust_unnamed.popup;
    (*popup).parent = (*parent).surface;
    wl_list_insert(&mut (*parent).popups, &mut (*popup).link);
    wlr_signal_emit_safe(&mut (*parent).events.new_popup,
                         popup as *mut libc::c_void);
}
unsafe extern "C" fn layer_surface_set_layer(mut client: *mut wl_client,
                                             mut surface_resource:
                                                 *mut wl_resource,
                                             mut layer: uint32_t) {
    let mut surface: *mut wlr_layer_surface_v1 =
        layer_surface_from_resource(surface_resource);
    if surface.is_null() { return }
    if layer >
           ZWLR_LAYER_SHELL_V1_LAYER_OVERLAY as libc::c_int as libc::c_uint {
        wl_resource_post_error((*surface).resource,
                               ZWLR_LAYER_SHELL_V1_ERROR_INVALID_LAYER as
                                   libc::c_int as uint32_t,
                               b"Invalid layer %d\x00" as *const u8 as
                                   *const libc::c_char, layer);
        return
    }
    (*surface).client_pending.layer = layer as zwlr_layer_shell_v1_layer;
}
static mut layer_surface_implementation: zwlr_layer_surface_v1_interface =
    {
    
        {
            let mut init =
                zwlr_layer_surface_v1_interface{set_size:
                                                    Some(layer_surface_handle_set_size
                                                             as
                                                             unsafe extern "C" fn(_:
                                                                                      *mut wl_client,
                                                                                  _:
                                                                                      *mut wl_resource,
                                                                                  _:
                                                                                      uint32_t,
                                                                                  _:
                                                                                      uint32_t)
                                                                 -> ()),
                                                set_anchor:
                                                    Some(layer_surface_handle_set_anchor
                                                             as
                                                             unsafe extern "C" fn(_:
                                                                                      *mut wl_client,
                                                                                  _:
                                                                                      *mut wl_resource,
                                                                                  _:
                                                                                      uint32_t)
                                                                 -> ()),
                                                set_exclusive_zone:
                                                    Some(layer_surface_handle_set_exclusive_zone
                                                             as
                                                             unsafe extern "C" fn(_:
                                                                                      *mut wl_client,
                                                                                  _:
                                                                                      *mut wl_resource,
                                                                                  _:
                                                                                      int32_t)
                                                                 -> ()),
                                                set_margin:
                                                    Some(layer_surface_handle_set_margin
                                                             as
                                                             unsafe extern "C" fn(_:
                                                                                      *mut wl_client,
                                                                                  _:
                                                                                      *mut wl_resource,
                                                                                  _:
                                                                                      int32_t,
                                                                                  _:
                                                                                      int32_t,
                                                                                  _:
                                                                                      int32_t,
                                                                                  _:
                                                                                      int32_t)
                                                                 -> ()),
                                                set_keyboard_interactivity:
                                                    Some(layer_surface_handle_set_keyboard_interactivity
                                                             as
                                                             unsafe extern "C" fn(_:
                                                                                      *mut wl_client,
                                                                                  _:
                                                                                      *mut wl_resource,
                                                                                  _:
                                                                                      uint32_t)
                                                                 -> ()),
                                                get_popup:
                                                    Some(layer_surface_handle_get_popup
                                                             as
                                                             unsafe extern "C" fn(_:
                                                                                      *mut wl_client,
                                                                                  _:
                                                                                      *mut wl_resource,
                                                                                  _:
                                                                                      *mut wl_resource)
                                                                 -> ()),
                                                ack_configure:
                                                    Some(layer_surface_handle_ack_configure
                                                             as
                                                             unsafe extern "C" fn(_:
                                                                                      *mut wl_client,
                                                                                  _:
                                                                                      *mut wl_resource,
                                                                                  _:
                                                                                      uint32_t)
                                                                 -> ()),
                                                destroy:
                                                    Some(resource_handle_destroy
                                                             as
                                                             unsafe extern "C" fn(_:
                                                                                      *mut wl_client,
                                                                                  _:
                                                                                      *mut wl_resource)
                                                                 -> ()),
                                                set_layer:
                                                    Some(layer_surface_set_layer
                                                             as
                                                             unsafe extern "C" fn(_:
                                                                                      *mut wl_client,
                                                                                  _:
                                                                                      *mut wl_resource,
                                                                                  _:
                                                                                      uint32_t)
                                                                 -> ()),};
            init
        }
};
unsafe extern "C" fn layer_surface_unmap(mut surface:
                                             *mut wlr_layer_surface_v1) {
    // TODO: probably need to ungrab before this event
    wlr_signal_emit_safe(&mut (*surface).events.unmap,
                         surface as *mut libc::c_void);
    let mut popup: *mut wlr_xdg_popup = 0 as *mut wlr_xdg_popup;
    let mut popup_tmp: *mut wlr_xdg_popup = 0 as *mut wlr_xdg_popup;
    popup =
        ((*surface).popups.next as *mut libc::c_char).offset(-8) as
            *mut wlr_xdg_popup;
    popup_tmp =
        ((*popup).link.next as *mut libc::c_char).offset(-8) as
            *mut wlr_xdg_popup;
    while &mut (*popup).link as *mut wl_list !=
              &mut (*surface).popups as *mut wl_list {
        wlr_xdg_popup_destroy((*popup).base);
        popup = popup_tmp;
        popup_tmp =
            ((*popup).link.next as *mut libc::c_char).offset(-8) as
                *mut wlr_xdg_popup
    }
    let mut configure: *mut wlr_layer_surface_v1_configure =
        0 as *mut wlr_layer_surface_v1_configure;
    let mut tmp: *mut wlr_layer_surface_v1_configure =
        0 as *mut wlr_layer_surface_v1_configure;
    configure =
        ((*surface).configure_list.next as *mut libc::c_char).offset(-0) as
            *mut wlr_layer_surface_v1_configure;
    tmp =
        ((*configure).link.next as *mut libc::c_char).offset(-0) as
            *mut wlr_layer_surface_v1_configure;
    while &mut (*configure).link as *mut wl_list !=
              &mut (*surface).configure_list as *mut wl_list {
        layer_surface_configure_destroy(configure);
        configure = tmp;
        tmp =
            ((*configure).link.next as *mut libc::c_char).offset(-0) as
                *mut wlr_layer_surface_v1_configure
    }
    (*surface).mapped = 0i32 != 0;
    (*surface).configured = (*surface).mapped;
    (*surface).configure_serial = 0i32 as uint32_t;
    (*surface).configure_next_serial = 0i32 as uint32_t;
}
unsafe extern "C" fn layer_surface_destroy(mut surface:
                                               *mut wlr_layer_surface_v1) {
    if (*surface).configured as libc::c_int != 0 &&
           (*surface).mapped as libc::c_int != 0 {
        layer_surface_unmap(surface);
    }
    wlr_signal_emit_safe(&mut (*surface).events.destroy,
                         surface as *mut libc::c_void);
    wl_resource_set_user_data((*surface).resource, 0 as *mut libc::c_void);
    (*(*surface).surface).role_data = 0 as *mut libc::c_void;
    wl_list_remove(&mut (*surface).surface_destroy.link);
    wl_list_remove(&mut (*surface).link);
    free((*surface).namespace as *mut libc::c_void);
    free(surface as *mut libc::c_void);
}
unsafe extern "C" fn layer_surface_resource_destroy(mut resource:
                                                        *mut wl_resource) {
    let mut surface: *mut wlr_layer_surface_v1 =
        layer_surface_from_resource(resource);
    if !surface.is_null() { layer_surface_destroy(surface); };
}
unsafe extern "C" fn layer_surface_state_changed(mut surface:
                                                     *mut wlr_layer_surface_v1)
 -> bool {
    let mut state: *mut wlr_layer_surface_v1_state =
        0 as *mut wlr_layer_surface_v1_state;
    if wl_list_empty(&mut (*surface).configure_list) != 0 {
        if !(*surface).acked_configure.is_null() {
            state = &mut (*(*surface).acked_configure).state
        } else if !(*surface).configured {
            return 1i32 != 0
        } else { state = &mut (*surface).current }
    } else {
        let mut configure: *mut wlr_layer_surface_v1_configure =
            ((*surface).configure_list.prev as *mut libc::c_char).offset(-0)
                as *mut wlr_layer_surface_v1_configure;
        state = &mut (*configure).state
    }
    let mut changed: bool =
        (*state).actual_width != (*surface).server_pending.actual_width ||
            (*state).actual_height != (*surface).server_pending.actual_height;
    return changed;
}
#[no_mangle]
pub unsafe extern "C" fn wlr_layer_surface_v1_configure(mut surface:
                                                            *mut wlr_layer_surface_v1,
                                                        mut width: uint32_t,
                                                        mut height:
                                                            uint32_t) {
    (*surface).server_pending.actual_width = width;
    (*surface).server_pending.actual_height = height;
    if layer_surface_state_changed(surface) {
        let mut display: *mut wl_display =
            wl_client_get_display(wl_resource_get_client((*surface).resource));
        let mut configure: *mut wlr_layer_surface_v1_configure =
            calloc(1i32 as libc::c_ulong,
                   ::std::mem::size_of::<wlr_layer_surface_v1_configure>() as
                       libc::c_ulong) as *mut wlr_layer_surface_v1_configure;
        if configure.is_null() {
            wl_client_post_no_memory(wl_resource_get_client((*surface).resource));
            return
        }
        (*surface).configure_next_serial = wl_display_next_serial(display);
        wl_list_insert((*surface).configure_list.prev,
                       &mut (*configure).link);
        (*configure).state.actual_width = width;
        (*configure).state.actual_height = height;
        (*configure).serial = (*surface).configure_next_serial;
        zwlr_layer_surface_v1_send_configure((*surface).resource,
                                             (*configure).serial,
                                             (*configure).state.actual_width,
                                             (*configure).state.actual_height);
    };
}
#[no_mangle]
pub unsafe extern "C" fn wlr_layer_surface_v1_close(mut surface:
                                                        *mut wlr_layer_surface_v1) {
    if (*surface).closed { return }
    (*surface).closed = 1i32 != 0;
    layer_surface_unmap(surface);
    zwlr_layer_surface_v1_send_closed((*surface).resource);
}
unsafe extern "C" fn layer_surface_role_commit(mut wlr_surface:
                                                   *mut wlr_surface) {
    let mut surface: *mut wlr_layer_surface_v1 =
        wlr_layer_surface_v1_from_wlr_surface(wlr_surface);
    if surface.is_null() { return }
    if (*surface).closed {
        // Ignore commits after the compositor has closed it
        return
    }
    if !(*surface).acked_configure.is_null() {
        let mut configure: *mut wlr_layer_surface_v1_configure =
            (*surface).acked_configure;
        (*surface).configured = 1i32 != 0;
        (*surface).configure_serial = (*configure).serial;
        (*surface).current.actual_width = (*configure).state.actual_width;
        (*surface).current.actual_height = (*configure).state.actual_height;
        layer_surface_configure_destroy(configure);
        (*surface).acked_configure = 0 as *mut wlr_layer_surface_v1_configure
    }
    if wlr_surface_has_buffer((*surface).surface) as libc::c_int != 0 &&
           !(*surface).configured {
        wl_resource_post_error((*surface).resource,
                               ZWLR_LAYER_SHELL_V1_ERROR_ALREADY_CONSTRUCTED
                                   as libc::c_int as uint32_t,
                               b"layer_surface has never been configured\x00"
                                   as *const u8 as *const libc::c_char);
        return
    }
    (*surface).current.anchor = (*surface).client_pending.anchor;
    (*surface).current.exclusive_zone =
        (*surface).client_pending.exclusive_zone;
    (*surface).current.margin = (*surface).client_pending.margin;
    (*surface).current.keyboard_interactive =
        (*surface).client_pending.keyboard_interactive;
    (*surface).current.desired_width =
        (*surface).client_pending.desired_width;
    (*surface).current.desired_height =
        (*surface).client_pending.desired_height;
    (*surface).current.layer = (*surface).client_pending.layer;
    if !(*surface).added {
        (*surface).added = 1i32 != 0;
        wlr_signal_emit_safe(&mut (*(*surface).shell).events.new_surface,
                             surface as *mut libc::c_void);
        // either the compositor found a suitable output or it must
		// have closed the surface
        if !(*surface).output.is_null() ||
               (*surface).closed as libc::c_int != 0 {
        } else {
            __assert_fail(b"surface->output || surface->closed\x00" as
                              *const u8 as *const libc::c_char,
                          b"../types/wlr_layer_shell_v1.c\x00" as *const u8 as
                              *const libc::c_char, 343i32 as libc::c_uint,
                          (*::std::mem::transmute::<&[u8; 53],
                                                    &[libc::c_char; 53]>(b"void layer_surface_role_commit(struct wlr_surface *)\x00")).as_ptr());
        };
    }
    if (*surface).configured as libc::c_int != 0 &&
           wlr_surface_has_buffer((*surface).surface) as libc::c_int != 0 &&
           !(*surface).mapped {
        (*surface).mapped = 1i32 != 0;
        wlr_signal_emit_safe(&mut (*surface).events.map,
                             surface as *mut libc::c_void);
    }
    if (*surface).configured as libc::c_int != 0 &&
           !wlr_surface_has_buffer((*surface).surface) &&
           (*surface).mapped as libc::c_int != 0 {
        layer_surface_unmap(surface);
    };
}
static mut layer_surface_role: wlr_surface_role =
    {
    
        {
            let mut init =
                wlr_surface_role{name:
                                     b"zwlr_layer_surface_v1\x00" as *const u8
                                         as *const libc::c_char,
                                 commit:
                                     Some(layer_surface_role_commit as
                                              unsafe extern "C" fn(_:
                                                                       *mut wlr_surface)
                                                  -> ()),
                                 precommit: None,};
            init
        }
};
unsafe extern "C" fn handle_surface_destroyed(mut listener: *mut wl_listener,
                                              mut data: *mut libc::c_void) {
    let mut layer_surface: *mut wlr_layer_surface_v1 =
        (listener as *mut libc::c_char).offset(-256) as
            *mut wlr_layer_surface_v1;
    layer_surface_destroy(layer_surface);
}
unsafe extern "C" fn layer_shell_handle_get_layer_surface(mut wl_client:
                                                              *mut wl_client,
                                                          mut client_resource:
                                                              *mut wl_resource,
                                                          mut id: uint32_t,
                                                          mut surface_resource:
                                                              *mut wl_resource,
                                                          mut output_resource:
                                                              *mut wl_resource,
                                                          mut layer: uint32_t,
                                                          mut namespace:
                                                              *const libc::c_char) {
    let mut shell: *mut wlr_layer_shell_v1 =
        layer_shell_from_resource(client_resource);
    let mut wlr_surface: *mut wlr_surface =
        wlr_surface_from_resource(surface_resource);
    let mut surface: *mut wlr_layer_surface_v1 =
        calloc(1i32 as libc::c_ulong,
               ::std::mem::size_of::<wlr_layer_surface_v1>() as libc::c_ulong)
            as *mut wlr_layer_surface_v1;
    if surface.is_null() { wl_client_post_no_memory(wl_client); return }
    if !wlr_surface_set_role(wlr_surface, &layer_surface_role,
                             surface as *mut libc::c_void, client_resource,
                             ZWLR_LAYER_SHELL_V1_ERROR_ROLE as libc::c_int as
                                 uint32_t) {
        free(surface as *mut libc::c_void);
        return
    }
    (*surface).shell = shell;
    (*surface).surface = wlr_surface;
    if !output_resource.is_null() {
        (*surface).output = wlr_output_from_resource(output_resource)
    }
    (*surface).client_pending.layer = layer as zwlr_layer_shell_v1_layer;
    (*surface).current.layer = (*surface).client_pending.layer;
    if layer >
           ZWLR_LAYER_SHELL_V1_LAYER_OVERLAY as libc::c_int as libc::c_uint {
        free(surface as *mut libc::c_void);
        wl_resource_post_error(client_resource,
                               ZWLR_LAYER_SHELL_V1_ERROR_INVALID_LAYER as
                                   libc::c_int as uint32_t,
                               b"Invalid layer %d\x00" as *const u8 as
                                   *const libc::c_char, layer);
        return
    }
    (*surface).namespace = strdup(namespace);
    if (*surface).namespace.is_null() {
        free(surface as *mut libc::c_void);
        wl_client_post_no_memory(wl_client);
        return
    }
    (*surface).resource =
        wl_resource_create(wl_client, &zwlr_layer_surface_v1_interface,
                           wl_resource_get_version(client_resource), id);
    if (*surface).resource.is_null() {
        free((*surface).namespace as *mut libc::c_void);
        free(surface as *mut libc::c_void);
        wl_client_post_no_memory(wl_client);
        return
    }
    wl_list_init(&mut (*surface).configure_list);
    wl_list_init(&mut (*surface).popups);
    wl_signal_init(&mut (*surface).events.destroy);
    wl_signal_init(&mut (*surface).events.map);
    wl_signal_init(&mut (*surface).events.unmap);
    wl_signal_init(&mut (*surface).events.new_popup);
    wl_signal_add(&mut (*(*surface).surface).events.destroy,
                  &mut (*surface).surface_destroy);
    (*surface).surface_destroy.notify =
        Some(handle_surface_destroyed as
                 unsafe extern "C" fn(_: *mut wl_listener,
                                      _: *mut libc::c_void) -> ());
    _wlr_log(WLR_DEBUG,
             b"[%s:%d] new layer_surface %p (res %p)\x00" as *const u8 as
                 *const libc::c_char,
             b"../types/wlr_layer_shell_v1.c\x00" as *const u8 as
                 *const libc::c_char, 434i32, surface, (*surface).resource);
    wl_resource_set_implementation((*surface).resource,
                                   &layer_surface_implementation as
                                       *const zwlr_layer_surface_v1_interface
                                       as *const libc::c_void,
                                   surface as *mut libc::c_void,
                                   Some(layer_surface_resource_destroy as
                                            unsafe extern "C" fn(_:
                                                                     *mut wl_resource)
                                                -> ()));
    wl_list_insert(&mut (*shell).surfaces, &mut (*surface).link);
}
static mut layer_shell_implementation: zwlr_layer_shell_v1_interface =
    {
    
        {
            let mut init =
                zwlr_layer_shell_v1_interface{get_layer_surface:
                                                  Some(layer_shell_handle_get_layer_surface
                                                           as
                                                           unsafe extern "C" fn(_:
                                                                                    *mut wl_client,
                                                                                _:
                                                                                    *mut wl_resource,
                                                                                _:
                                                                                    uint32_t,
                                                                                _:
                                                                                    *mut wl_resource,
                                                                                _:
                                                                                    *mut wl_resource,
                                                                                _:
                                                                                    uint32_t,
                                                                                _:
                                                                                    *const libc::c_char)
                                                               -> ()),};
            init
        }
};
unsafe extern "C" fn layer_shell_bind(mut wl_client: *mut wl_client,
                                      mut data: *mut libc::c_void,
                                      mut version: uint32_t,
                                      mut id: uint32_t) {
    let mut layer_shell: *mut wlr_layer_shell_v1 =
        data as *mut wlr_layer_shell_v1;
    if !wl_client.is_null() && !layer_shell.is_null() {
    } else {
        __assert_fail(b"wl_client && layer_shell\x00" as *const u8 as
                          *const libc::c_char,
                      b"../types/wlr_layer_shell_v1.c\x00" as *const u8 as
                          *const libc::c_char, 447i32 as libc::c_uint,
                      (*::std::mem::transmute::<&[u8; 70],
                                                &[libc::c_char; 70]>(b"void layer_shell_bind(struct wl_client *, void *, uint32_t, uint32_t)\x00")).as_ptr());
    };
    let mut resource: *mut wl_resource =
        wl_resource_create(wl_client, &zwlr_layer_shell_v1_interface,
                           version as libc::c_int, id);
    if resource.is_null() { wl_client_post_no_memory(wl_client); return }
    wl_resource_set_implementation(resource,
                                   &layer_shell_implementation as
                                       *const zwlr_layer_shell_v1_interface as
                                       *const libc::c_void,
                                   layer_shell as *mut libc::c_void, None);
}
unsafe extern "C" fn handle_display_destroy(mut listener: *mut wl_listener,
                                            mut data: *mut libc::c_void) {
    let mut layer_shell: *mut wlr_layer_shell_v1 =
        (listener as *mut libc::c_char).offset(-24) as
            *mut wlr_layer_shell_v1;
    wlr_signal_emit_safe(&mut (*layer_shell).events.destroy,
                         layer_shell as *mut libc::c_void);
    wl_list_remove(&mut (*layer_shell).display_destroy.link);
    wl_global_destroy((*layer_shell).global);
    free(layer_shell as *mut libc::c_void);
}
#[no_mangle]
pub unsafe extern "C" fn wlr_layer_shell_v1_create(mut display:
                                                       *mut wl_display)
 -> *mut wlr_layer_shell_v1 {
    let mut layer_shell: *mut wlr_layer_shell_v1 =
        calloc(1i32 as libc::c_ulong,
               ::std::mem::size_of::<wlr_layer_shell_v1>() as libc::c_ulong)
            as *mut wlr_layer_shell_v1;
    if layer_shell.is_null() { return 0 as *mut wlr_layer_shell_v1 }
    wl_list_init(&mut (*layer_shell).surfaces);
    let mut global: *mut wl_global =
        wl_global_create(display, &zwlr_layer_shell_v1_interface, 2i32,
                         layer_shell as *mut libc::c_void,
                         Some(layer_shell_bind as
                                  unsafe extern "C" fn(_: *mut wl_client,
                                                       _: *mut libc::c_void,
                                                       _: uint32_t,
                                                       _: uint32_t) -> ()));
    if global.is_null() {
        free(layer_shell as *mut libc::c_void);
        return 0 as *mut wlr_layer_shell_v1
    }
    (*layer_shell).global = global;
    wl_signal_init(&mut (*layer_shell).events.new_surface);
    wl_signal_init(&mut (*layer_shell).events.destroy);
    (*layer_shell).display_destroy.notify =
        Some(handle_display_destroy as
                 unsafe extern "C" fn(_: *mut wl_listener,
                                      _: *mut libc::c_void) -> ());
    wl_display_add_destroy_listener(display,
                                    &mut (*layer_shell).display_destroy);
    return layer_shell;
}
unsafe extern "C" fn layer_surface_iterator(mut surface: *mut wlr_surface,
                                            mut sx: libc::c_int,
                                            mut sy: libc::c_int,
                                            mut data: *mut libc::c_void) {
    let mut iter_data: *mut layer_surface_iterator_data =
        data as *mut layer_surface_iterator_data;
    (*iter_data).user_iterator.expect("non-null function pointer")(surface,
                                                                   (*iter_data).x
                                                                       + sx,
                                                                   (*iter_data).y
                                                                       + sy,
                                                                   (*iter_data).user_data);
}
unsafe extern "C" fn xdg_surface_for_each_surface(mut surface:
                                                      *mut wlr_xdg_surface,
                                                  mut x: libc::c_int,
                                                  mut y: libc::c_int,
                                                  mut iterator:
                                                      wlr_surface_iterator_func_t,
                                                  mut user_data:
                                                      *mut libc::c_void) {
    let mut data: layer_surface_iterator_data =
        {
            let mut init =
                layer_surface_iterator_data{user_iterator: iterator,
                                            user_data: user_data,
                                            x: x,
                                            y: y,};
            init
        };
    wlr_surface_for_each_surface((*surface).surface,
                                 Some(layer_surface_iterator as
                                          unsafe extern "C" fn(_:
                                                                   *mut wlr_surface,
                                                               _: libc::c_int,
                                                               _: libc::c_int,
                                                               _:
                                                                   *mut libc::c_void)
                                              -> ()),
                                 &mut data as *mut layer_surface_iterator_data
                                     as *mut libc::c_void);
    let mut popup_state: *mut wlr_xdg_popup = 0 as *mut wlr_xdg_popup;
    popup_state =
        ((*surface).popups.next as *mut libc::c_char).offset(-8) as
            *mut wlr_xdg_popup;
    while &mut (*popup_state).link as *mut wl_list !=
              &mut (*surface).popups as *mut wl_list {
        let mut popup: *mut wlr_xdg_surface = (*popup_state).base;
        if (*popup).configured {
            let mut popup_sx: libc::c_double =
                ((*popup_state).geometry.x -
                     (*(*popup_state).base).geometry.x) as libc::c_double;
            let mut popup_sy: libc::c_double =
                ((*popup_state).geometry.y -
                     (*(*popup_state).base).geometry.y) as libc::c_double;
            xdg_surface_for_each_surface(popup,
                                         (x as libc::c_double + popup_sx) as
                                             libc::c_int,
                                         (y as libc::c_double + popup_sy) as
                                             libc::c_int, iterator,
                                         user_data);
        }
        popup_state =
            ((*popup_state).link.next as *mut libc::c_char).offset(-8) as
                *mut wlr_xdg_popup
    };
}
unsafe extern "C" fn layer_surface_for_each_surface(mut surface:
                                                        *mut wlr_layer_surface_v1,
                                                    mut x: libc::c_int,
                                                    mut y: libc::c_int,
                                                    mut iterator:
                                                        wlr_surface_iterator_func_t,
                                                    mut user_data:
                                                        *mut libc::c_void) {
    let mut data: layer_surface_iterator_data =
        {
            let mut init =
                layer_surface_iterator_data{user_iterator: iterator,
                                            user_data: user_data,
                                            x: x,
                                            y: y,};
            init
        };
    wlr_surface_for_each_surface((*surface).surface,
                                 Some(layer_surface_iterator as
                                          unsafe extern "C" fn(_:
                                                                   *mut wlr_surface,
                                                               _: libc::c_int,
                                                               _: libc::c_int,
                                                               _:
                                                                   *mut libc::c_void)
                                              -> ()),
                                 &mut data as *mut layer_surface_iterator_data
                                     as *mut libc::c_void);
    let mut popup_state: *mut wlr_xdg_popup = 0 as *mut wlr_xdg_popup;
    popup_state =
        ((*surface).popups.next as *mut libc::c_char).offset(-8) as
            *mut wlr_xdg_popup;
    while &mut (*popup_state).link as *mut wl_list !=
              &mut (*surface).popups as *mut wl_list {
        let mut popup: *mut wlr_xdg_surface = (*popup_state).base;
        if (*popup).configured {
            let mut popup_sx: libc::c_double = 0.;
            let mut popup_sy: libc::c_double = 0.;
            popup_sx =
                ((*(*popup).c2rust_unnamed.popup).geometry.x -
                     (*popup).geometry.x) as libc::c_double;
            popup_sy =
                ((*(*popup).c2rust_unnamed.popup).geometry.y -
                     (*popup).geometry.y) as libc::c_double;
            xdg_surface_for_each_surface(popup, popup_sx as libc::c_int,
                                         popup_sy as libc::c_int, iterator,
                                         user_data);
        }
        popup_state =
            ((*popup_state).link.next as *mut libc::c_char).offset(-8) as
                *mut wlr_xdg_popup
    };
}
#[no_mangle]
pub unsafe extern "C" fn wlr_layer_surface_v1_for_each_surface(mut surface:
                                                                   *mut wlr_layer_surface_v1,
                                                               mut iterator:
                                                                   wlr_surface_iterator_func_t,
                                                               mut user_data:
                                                                   *mut libc::c_void) {
    layer_surface_for_each_surface(surface, 0i32, 0i32, iterator, user_data);
}
/*
 * This an unstable interface of wlroots. No guarantees are made regarding the
 * future consistency of this API.
 */
/* *
 * wlr_layer_shell_v1 allows clients to arrange themselves in "layers" on the
 * desktop in accordance with the wlr-layer-shell protocol. When a client is
 * added, the new_surface signal will be raised and passed a reference to our
 * wlr_layer_surface_v1. At this time, the client will have configured the
 * surface as it desires, including information like desired anchors and
 * margins. The compositor should use this information to decide how to arrange
 * the layer on-screen, then determine the dimensions of the layer and call
 * wlr_layer_surface_v1_configure. The client will then attach a buffer and
 * commit the surface, at which point the wlr_layer_surface_v1 map signal is
 * raised and the compositor should begin rendering the surface.
 */
// wl_layer_surface
// struct wlr_layer_surface_v1 *
		// Note: the output may be NULL. In this case, it is your
		// responsibility to assign an output before returning.
// wlr_layer_surface_v1::configure_list
// wlr_layer_shell_v1::surfaces
// wlr_xdg_popup::link
/* *
 * Notifies the layer surface to configure itself with this width/height. The
 * layer_surface will signal its map event when the surface is ready to assume
 * this size.
 */
/* *
 * Unmaps this layer surface and notifies the client that it has been closed.
 */
/* Calls the iterator function for each sub-surface and popup of this surface */
/* *
 * Find a surface within this layer-surface tree at the given surface-local
 * coordinates. Returns the surface and coordinates in the leaf surface
 * coordinate system or NULL if no surface is found at that location.
 */
#[no_mangle]
pub unsafe extern "C" fn wlr_layer_surface_v1_surface_at(mut surface:
                                                             *mut wlr_layer_surface_v1,
                                                         mut sx:
                                                             libc::c_double,
                                                         mut sy:
                                                             libc::c_double,
                                                         mut sub_x:
                                                             *mut libc::c_double,
                                                         mut sub_y:
                                                             *mut libc::c_double)
 -> *mut wlr_surface {
    let mut popup_state: *mut wlr_xdg_popup = 0 as *mut wlr_xdg_popup;
    popup_state =
        ((*surface).popups.next as *mut libc::c_char).offset(-8) as
            *mut wlr_xdg_popup;
    while &mut (*popup_state).link as *mut wl_list !=
              &mut (*surface).popups as *mut wl_list {
        let mut popup: *mut wlr_xdg_surface = (*popup_state).base;
        let mut popup_sx: libc::c_double =
            ((*popup_state).geometry.x - (*popup).geometry.x) as
                libc::c_double;
        let mut popup_sy: libc::c_double =
            ((*popup_state).geometry.y - (*popup).geometry.y) as
                libc::c_double;
        let mut sub: *mut wlr_surface =
            wlr_xdg_surface_surface_at(popup, sx - popup_sx, sy - popup_sy,
                                       sub_x, sub_y);
        if !sub.is_null() { return sub }
        popup_state =
            ((*popup_state).link.next as *mut libc::c_char).offset(-8) as
                *mut wlr_xdg_popup
    }
    return wlr_surface_surface_at((*surface).surface, sx, sy, sub_x, sub_y);
}
