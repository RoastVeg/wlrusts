use libc;
extern "C" {
    pub type wl_event_source;
    pub type wl_display;
    /* Generated by wayland-scanner 1.17.0 */
    pub type wl_client;
    pub type wl_global;
    /*
 * This an unstable interface of wlroots. No guarantees are made regarding the
 * future consistency of this API.
 */
    pub type wlr_backend_impl;
    pub type wlr_texture;
    pub type wlr_surface;
    #[no_mangle]
    fn __assert_fail(__assertion: *const libc::c_char,
                     __file: *const libc::c_char, __line: libc::c_uint,
                     __function: *const libc::c_char) -> !;
    #[no_mangle]
    fn calloc(_: libc::c_ulong, _: libc::c_ulong) -> *mut libc::c_void;
    #[no_mangle]
    fn free(__ptr: *mut libc::c_void);
    #[no_mangle]
    fn lseek(__fd: libc::c_int, __offset: __off64_t, __whence: libc::c_int)
     -> __off64_t;
    #[no_mangle]
    fn wlr_output_lock_software_cursors(output: *mut wlr_output, lock: bool);
    #[no_mangle]
    fn wlr_output_lock_attach_render(output: *mut wlr_output, lock: bool);
    #[no_mangle]
    fn wlr_output_from_resource(resource: *mut wl_resource)
     -> *mut wlr_output;
    #[no_mangle]
    fn wlr_output_export_dmabuf(output: *mut wlr_output,
                                attribs: *mut wlr_dmabuf_attributes) -> bool;
    #[no_mangle]
    fn wl_list_init(list: *mut wl_list);
    #[no_mangle]
    fn wl_list_insert(list: *mut wl_list, elm: *mut wl_list);
    #[no_mangle]
    fn wl_list_remove(elm: *mut wl_list);
    #[no_mangle]
    fn wl_display_add_destroy_listener(display: *mut wl_display,
                                       listener: *mut wl_listener);
    #[no_mangle]
    fn wl_global_create(display: *mut wl_display,
                        interface: *const wl_interface, version: libc::c_int,
                        data: *mut libc::c_void, bind: wl_global_bind_func_t)
     -> *mut wl_global;
    #[no_mangle]
    fn wl_global_destroy(global: *mut wl_global);
    #[no_mangle]
    fn wl_client_post_no_memory(client: *mut wl_client);
    #[no_mangle]
    fn wl_resource_post_event(resource: *mut wl_resource, opcode: uint32_t,
                              _: ...);
    #[no_mangle]
    fn wl_resource_post_no_memory(resource: *mut wl_resource);
    #[no_mangle]
    fn wl_resource_create(client: *mut wl_client,
                          interface: *const wl_interface,
                          version: libc::c_int, id: uint32_t)
     -> *mut wl_resource;
    #[no_mangle]
    fn wl_resource_set_implementation(resource: *mut wl_resource,
                                      implementation: *const libc::c_void,
                                      data: *mut libc::c_void,
                                      destroy: wl_resource_destroy_func_t);
    #[no_mangle]
    fn wl_resource_destroy(resource: *mut wl_resource);
    #[no_mangle]
    fn wl_resource_set_user_data(resource: *mut wl_resource,
                                 data: *mut libc::c_void);
    #[no_mangle]
    fn wl_resource_get_user_data(resource: *mut wl_resource)
     -> *mut libc::c_void;
    #[no_mangle]
    fn wl_resource_get_version(resource: *mut wl_resource) -> libc::c_int;
    #[no_mangle]
    fn wl_resource_instance_of(resource: *mut wl_resource,
                               interface: *const wl_interface,
                               implementation: *const libc::c_void)
     -> libc::c_int;
    /* *
 * Closes all file descriptors in the DMA-BUF attributes.
 */
    #[no_mangle]
    fn wlr_dmabuf_attributes_finish(attribs: *mut wlr_dmabuf_attributes);
    #[no_mangle]
    fn wlr_signal_emit_safe(signal: *mut wl_signal, data: *mut libc::c_void);
    /* *
 * @page page_iface_zwlr_export_dmabuf_manager_v1 zwlr_export_dmabuf_manager_v1
 * @section page_iface_zwlr_export_dmabuf_manager_v1_desc Description
 *
 * This object is a manager with which to start capturing from sources.
 * @section page_iface_zwlr_export_dmabuf_manager_v1_api API
 * See @ref iface_zwlr_export_dmabuf_manager_v1.
 */
/* *
 * @defgroup iface_zwlr_export_dmabuf_manager_v1 The zwlr_export_dmabuf_manager_v1 interface
 *
 * This object is a manager with which to start capturing from sources.
 */
    #[no_mangle]
    static zwlr_export_dmabuf_manager_v1_interface: wl_interface;
    /* *
 * @page page_iface_zwlr_export_dmabuf_frame_v1 zwlr_export_dmabuf_frame_v1
 * @section page_iface_zwlr_export_dmabuf_frame_v1_desc Description
 *
 * This object represents a single DMA-BUF frame.
 *
 * If the capture is successful, the compositor will first send a "frame"
 * event, followed by one or several "object". When the frame is available
 * for readout, the "ready" event is sent.
 *
 * If the capture failed, the "cancel" event is sent. This can happen anytime
 * before the "ready" event.
 *
 * Once either a "ready" or a "cancel" event is received, the client should
 * destroy the frame. Once an "object" event is received, the client is
 * responsible for closing the associated file descriptor.
 *
 * All frames are read-only and may not be written into or altered.
 * @section page_iface_zwlr_export_dmabuf_frame_v1_api API
 * See @ref iface_zwlr_export_dmabuf_frame_v1.
 */
/* *
 * @defgroup iface_zwlr_export_dmabuf_frame_v1 The zwlr_export_dmabuf_frame_v1 interface
 *
 * This object represents a single DMA-BUF frame.
 *
 * If the capture is successful, the compositor will first send a "frame"
 * event, followed by one or several "object". When the frame is available
 * for readout, the "ready" event is sent.
 *
 * If the capture failed, the "cancel" event is sent. This can happen anytime
 * before the "ready" event.
 *
 * Once either a "ready" or a "cancel" event is received, the client should
 * destroy the frame. Once an "object" event is received, the client is
 * responsible for closing the associated file descriptor.
 *
 * All frames are read-only and may not be written into or altered.
 */
    #[no_mangle]
    static zwlr_export_dmabuf_frame_v1_interface: wl_interface;
}
pub type size_t = libc::c_ulong;
pub type __uint16_t = libc::c_ushort;
pub type __int32_t = libc::c_int;
pub type __uint32_t = libc::c_uint;
pub type __uint64_t = libc::c_ulong;
pub type __off64_t = libc::c_long;
pub type __time_t = libc::c_long;
pub type __syscall_slong_t = libc::c_long;
pub type off_t = __off64_t;
pub type time_t = __time_t;
pub type int32_t = __int32_t;
pub type uint16_t = __uint16_t;
pub type uint32_t = __uint32_t;
pub type uint64_t = __uint64_t;

#[repr(C)]#[derive(Copy, Clone)]
pub struct wl_object {
    pub interface: *const wl_interface,
    pub implementation: *const libc::c_void,
    pub id: uint32_t,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct wl_interface {
    pub name: *const libc::c_char,
    pub version: libc::c_int,
    pub method_count: libc::c_int,
    pub methods: *const wl_message,
    pub event_count: libc::c_int,
    pub events: *const wl_message,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct wl_message {
    pub name: *const libc::c_char,
    pub signature: *const libc::c_char,
    pub types: *mut *const wl_interface,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct wl_list {
    pub prev: *mut wl_list,
    pub next: *mut wl_list,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct wl_listener {
    pub link: wl_list,
    pub notify: wl_notify_func_t,
}
pub type wl_notify_func_t
    =
    Option<unsafe extern "C" fn(_: *mut wl_listener, _: *mut libc::c_void)
               -> ()>;
pub type wl_global_bind_func_t
    =
    Option<unsafe extern "C" fn(_: *mut wl_client, _: *mut libc::c_void,
                                _: uint32_t, _: uint32_t) -> ()>;

#[repr(C)]#[derive(Copy, Clone)]
pub struct wl_resource {
    pub object: wl_object,
    pub destroy: wl_resource_destroy_func_t,
    pub link: wl_list,
    pub destroy_signal: wl_signal,
    pub client: *mut wl_client,
    pub data: *mut libc::c_void,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct wl_signal {
    pub listener_list: wl_list,
}
pub type wl_resource_destroy_func_t
    =
    Option<unsafe extern "C" fn(_: *mut wl_resource) -> ()>;
/*
 * 32 bit regions
 */

#[repr(C)]#[derive(Copy, Clone)]
pub struct pixman_region32_data {
    pub size: libc::c_long,
    pub numRects: libc::c_long,
}
pub type pixman_region32_data_t = pixman_region32_data;

#[repr(C)]#[derive(Copy, Clone)]
pub struct pixman_box32 {
    pub x1: int32_t,
    pub y1: int32_t,
    pub x2: int32_t,
    pub y2: int32_t,
}
pub type pixman_box32_t = pixman_box32;

#[repr(C)]#[derive(Copy, Clone)]
pub struct pixman_region32 {
    pub extents: pixman_box32_t,
    pub data: *mut pixman_region32_data_t,
}
pub type pixman_region32_t = pixman_region32;

#[repr(C)]#[derive(Copy, Clone)]
pub struct wlr_dmabuf_attributes {
    pub width: int32_t,
    pub height: int32_t,
    pub format: uint32_t,
    pub flags: uint32_t,
    pub modifier: uint64_t,
    pub n_planes: libc::c_int,
    pub offset: [uint32_t; 4],
    pub stride: [uint32_t; 4],
    pub fd: [libc::c_int; 4],
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct wlr_backend {
    pub impl_0: *const crate::src::backend::backend::wlr_backend_impl,
    pub events: C2RustUnnamed,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct C2RustUnnamed {
    pub destroy: wl_signal,
    pub new_input: wl_signal,
    pub new_output: wl_signal,
}
pub type wl_output_subpixel = libc::c_uint;
pub const WL_OUTPUT_SUBPIXEL_VERTICAL_BGR: wl_output_subpixel = 5;
pub const WL_OUTPUT_SUBPIXEL_VERTICAL_RGB: wl_output_subpixel = 4;
pub const WL_OUTPUT_SUBPIXEL_HORIZONTAL_BGR: wl_output_subpixel = 3;
pub const WL_OUTPUT_SUBPIXEL_HORIZONTAL_RGB: wl_output_subpixel = 2;
pub const WL_OUTPUT_SUBPIXEL_NONE: wl_output_subpixel = 1;
pub const WL_OUTPUT_SUBPIXEL_UNKNOWN: wl_output_subpixel = 0;
pub type wl_output_transform = libc::c_uint;
pub const WL_OUTPUT_TRANSFORM_FLIPPED_270: wl_output_transform = 7;
pub const WL_OUTPUT_TRANSFORM_FLIPPED_180: wl_output_transform = 6;
pub const WL_OUTPUT_TRANSFORM_FLIPPED_90: wl_output_transform = 5;
pub const WL_OUTPUT_TRANSFORM_FLIPPED: wl_output_transform = 4;
pub const WL_OUTPUT_TRANSFORM_270: wl_output_transform = 3;
pub const WL_OUTPUT_TRANSFORM_180: wl_output_transform = 2;
pub const WL_OUTPUT_TRANSFORM_90: wl_output_transform = 1;
pub const WL_OUTPUT_TRANSFORM_NORMAL: wl_output_transform = 0;

#[repr(C)]#[derive(Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct wlr_buffer {
    pub resource: *mut wl_resource,
    pub texture: *mut crate::src::backend::drm::atomic::wlr_texture,
    pub released: bool,
    pub n_refs: size_t,
    pub resource_destroy: wl_listener,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct wlr_output_mode {
    pub width: int32_t,
    pub height: int32_t,
    pub refresh: int32_t,
    pub preferred: bool,
    pub link: wl_list,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct wlr_output_cursor {
    pub output: *mut wlr_output,
    pub x: libc::c_double,
    pub y: libc::c_double,
    pub enabled: bool,
    pub visible: bool,
    pub width: uint32_t,
    pub height: uint32_t,
    pub hotspot_x: int32_t,
    pub hotspot_y: int32_t,
    pub link: wl_list,
    pub texture: *mut crate::src::backend::drm::atomic::wlr_texture,
    pub surface: *mut crate::src::types::data_device::wlr_data_device::wlr_surface,
    pub surface_commit: wl_listener,
    pub surface_destroy: wl_listener,
    pub events: C2RustUnnamed_0,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct C2RustUnnamed_0 {
    pub destroy: wl_signal,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct wlr_output {
    pub impl_0: *const wlr_output_impl,
    pub backend: *mut wlr_backend,
    pub display: *mut wl_display,
    pub global: *mut wl_global,
    pub resources: wl_list,
    pub name: [libc::c_char; 24],
    pub make: [libc::c_char; 56],
    pub model: [libc::c_char; 16],
    pub serial: [libc::c_char; 16],
    pub phys_width: int32_t,
    pub phys_height: int32_t,
    pub modes: wl_list,
    pub current_mode: *mut wlr_output_mode,
    pub width: int32_t,
    pub height: int32_t,
    pub refresh: int32_t,
    pub enabled: bool,
    pub scale: libc::c_float,
    pub subpixel: wl_output_subpixel,
    pub transform: wl_output_transform,
    pub needs_frame: bool,
    pub damage: pixman_region32_t,
    pub frame_pending: bool,
    pub transform_matrix: [libc::c_float; 9],
    pub pending: wlr_output_state,
    pub commit_seq: uint32_t,
    pub events: C2RustUnnamed_1,
    pub idle_frame: *mut wl_event_source,
    pub idle_done: *mut wl_event_source,
    pub attach_render_locks: libc::c_int,
    pub cursors: wl_list,
    pub hardware_cursor: *mut wlr_output_cursor,
    pub software_cursor_locks: libc::c_int,
    pub display_destroy: wl_listener,
    pub data: *mut libc::c_void,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct C2RustUnnamed_1 {
    pub frame: wl_signal,
    pub needs_frame: wl_signal,
    pub precommit: wl_signal,
    pub commit: wl_signal,
    pub present: wl_signal,
    pub enable: wl_signal,
    pub mode: wl_signal,
    pub scale: wl_signal,
    pub transform: wl_signal,
    pub destroy: wl_signal,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct wlr_output_state {
    pub committed: uint32_t,
    pub damage: pixman_region32_t,
    pub buffer_type: wlr_output_state_buffer_type,
    pub buffer: *mut wlr_buffer,
}
pub type wlr_output_state_buffer_type = libc::c_uint;
pub const WLR_OUTPUT_STATE_BUFFER_SCANOUT: wlr_output_state_buffer_type = 1;
pub const WLR_OUTPUT_STATE_BUFFER_RENDER: wlr_output_state_buffer_type = 0;

#[repr(C)]#[derive(Copy, Clone)]
pub struct wlr_output_impl {
    pub enable: Option<unsafe extern "C" fn(_: *mut wlr_output, _: bool)
                           -> bool>,
    pub set_mode: Option<unsafe extern "C" fn(_: *mut wlr_output,
                                              _: *mut wlr_output_mode)
                             -> bool>,
    pub set_custom_mode: Option<unsafe extern "C" fn(_: *mut wlr_output,
                                                     _: int32_t, _: int32_t,
                                                     _: int32_t) -> bool>,
    pub set_cursor: Option<unsafe extern "C" fn(_: *mut wlr_output,
                                                _: *mut crate::src::backend::drm::atomic::wlr_texture,
                                                _: int32_t,
                                                _: wl_output_transform,
                                                _: int32_t, _: int32_t,
                                                _: bool) -> bool>,
    pub move_cursor: Option<unsafe extern "C" fn(_: *mut wlr_output,
                                                 _: libc::c_int,
                                                 _: libc::c_int) -> bool>,
    pub destroy: Option<unsafe extern "C" fn(_: *mut wlr_output) -> ()>,
    pub attach_render: Option<unsafe extern "C" fn(_: *mut wlr_output,
                                                   _: *mut libc::c_int)
                                  -> bool>,
    pub commit: Option<unsafe extern "C" fn(_: *mut wlr_output) -> bool>,
    pub set_gamma: Option<unsafe extern "C" fn(_: *mut wlr_output, _: size_t,
                                               _: *const uint16_t,
                                               _: *const uint16_t,
                                               _: *const uint16_t) -> bool>,
    pub get_gamma_size: Option<unsafe extern "C" fn(_: *mut wlr_output)
                                   -> size_t>,
    pub export_dmabuf: Option<unsafe extern "C" fn(_: *mut wlr_output,
                                                   _:
                                                       *mut wlr_dmabuf_attributes)
                                  -> bool>,
    pub schedule_frame: Option<unsafe extern "C" fn(_: *mut wlr_output)
                                   -> bool>,
    pub attach_buffer: Option<unsafe extern "C" fn(_: *mut wlr_output,
                                                   _: *mut wlr_buffer)
                                  -> bool>,
}
pub type wlr_output_state_field = libc::c_uint;
pub const WLR_OUTPUT_STATE_DAMAGE: wlr_output_state_field = 2;
pub const WLR_OUTPUT_STATE_BUFFER: wlr_output_state_field = 1;

#[repr(C)]#[derive(Copy, Clone)]
pub struct wlr_output_event_precommit {
    pub output: *mut wlr_output,
    pub when: *mut timespec,
}
/*
 * This an unstable interface of wlroots. No guarantees are made regarding the
 * future consistency of this API.
 */

#[repr(C)]#[derive(Copy, Clone)]
pub struct wlr_export_dmabuf_manager_v1 {
    pub global: *mut wl_global,
    pub frames: wl_list,
    pub display_destroy: wl_listener,
    pub events: C2RustUnnamed_2,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct C2RustUnnamed_2 {
    pub destroy: wl_signal,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct wlr_export_dmabuf_frame_v1 {
    pub resource: *mut wl_resource,
    pub manager: *mut wlr_export_dmabuf_manager_v1,
    pub link: wl_list,
    pub attribs: wlr_dmabuf_attributes,
    pub output: *mut wlr_output,
    pub cursor_locked: bool,
    pub output_precommit: wl_listener,
}
/* *
 * @ingroup iface_zwlr_export_dmabuf_manager_v1
 * @struct zwlr_export_dmabuf_manager_v1_interface
 */

#[repr(C)]#[derive(Copy, Clone)]
pub struct zwlr_export_dmabuf_manager_v1_interface {
    pub capture_output: Option<unsafe extern "C" fn(_: *mut wl_client,
                                                    _: *mut wl_resource,
                                                    _: uint32_t, _: int32_t,
                                                    _: *mut wl_resource)
                                   -> ()>,
    pub destroy: Option<unsafe extern "C" fn(_: *mut wl_client,
                                             _: *mut wl_resource) -> ()>,
}
/* *
	 * clients should copy frame before processing
	 */
pub const ZWLR_EXPORT_DMABUF_FRAME_V1_FLAGS_TRANSIENT:
          zwlr_export_dmabuf_frame_v1_flags =
    1;
/* *
	 * temporary error, source will produce more frames
	 */
pub const ZWLR_EXPORT_DMABUF_FRAME_V1_CANCEL_REASON_TEMPORARY:
          zwlr_export_dmabuf_frame_v1_cancel_reason =
    0;
/* *
	 * fatal error, source will not produce frames
	 */
pub const ZWLR_EXPORT_DMABUF_FRAME_V1_CANCEL_REASON_PERMANENT:
          zwlr_export_dmabuf_frame_v1_cancel_reason =
    1;
/* ZWLR_EXPORT_DMABUF_FRAME_V1_CANCEL_REASON_ENUM */
/* *
 * @ingroup iface_zwlr_export_dmabuf_frame_v1
 * @struct zwlr_export_dmabuf_frame_v1_interface
 */

#[repr(C)]#[derive(Copy, Clone)]
pub struct zwlr_export_dmabuf_frame_v1_interface {
    pub destroy: Option<unsafe extern "C" fn(_: *mut wl_client,
                                             _: *mut wl_resource) -> ()>,
}
/* *
 * @ingroup iface_zwlr_export_dmabuf_manager_v1
 */
/* *
 * @ingroup iface_zwlr_export_dmabuf_manager_v1
 */
/* *
 * @ingroup iface_zwlr_export_dmabuf_frame_v1
 * frame flags
 *
 * Special flags that should be respected by the client.
 */
pub type zwlr_export_dmabuf_frame_v1_flags = libc::c_uint;
/* ZWLR_EXPORT_DMABUF_FRAME_V1_FLAGS_ENUM */
/* *
 * @ingroup iface_zwlr_export_dmabuf_frame_v1
 * cancel reason
 *
 * Indicates reason for cancelling the frame.
 */
pub type zwlr_export_dmabuf_frame_v1_cancel_reason = libc::c_uint;
/* *
	 * temporary error, source will produce more frames
	 */
pub const ZWLR_EXPORT_DMABUF_FRAME_V1_CANCEL_REASON_RESIZING:
          zwlr_export_dmabuf_frame_v1_cancel_reason =
    2;
#[inline]
unsafe extern "C" fn wl_signal_init(mut signal: *mut wl_signal) {
    wl_list_init(&mut (*signal).listener_list);
}
#[inline]
unsafe extern "C" fn wl_signal_add(mut signal: *mut wl_signal,
                                   mut listener: *mut wl_listener) {
    wl_list_insert((*signal).listener_list.prev, &mut (*listener).link);
}
/* *
 * @ingroup iface_zwlr_export_dmabuf_frame_v1
 */
/* *
 * @ingroup iface_zwlr_export_dmabuf_frame_v1
 */
/* *
 * @ingroup iface_zwlr_export_dmabuf_frame_v1
 */
/* *
 * @ingroup iface_zwlr_export_dmabuf_frame_v1
 */
/* *
 * @ingroup iface_zwlr_export_dmabuf_frame_v1
 */
/* *
 * @ingroup iface_zwlr_export_dmabuf_frame_v1
 * Sends an frame event to the client owning the resource.
 * @param resource_ The client's resource
 * @param width frame width in pixels
 * @param height frame height in pixels
 * @param offset_x crop offset for the x axis
 * @param offset_y crop offset for the y axis
 * @param buffer_flags flags which indicate properties (invert, interlacing),                     has the same values as zwp_linux_buffer_params_v1:flags
 * @param flags indicates special frame features
 * @param format format of the frame (DRM_FORMAT_*)
 * @param mod_high drm format modifier, high
 * @param mod_low drm format modifier, low
 * @param num_objects indicates how many objects (FDs) the frame has (max 4)
 */
#[inline]
unsafe extern "C" fn zwlr_export_dmabuf_frame_v1_send_frame(mut resource_:
                                                                *mut wl_resource,
                                                            mut width:
                                                                uint32_t,
                                                            mut height:
                                                                uint32_t,
                                                            mut offset_x:
                                                                uint32_t,
                                                            mut offset_y:
                                                                uint32_t,
                                                            mut buffer_flags:
                                                                uint32_t,
                                                            mut flags:
                                                                uint32_t,
                                                            mut format:
                                                                uint32_t,
                                                            mut mod_high:
                                                                uint32_t,
                                                            mut mod_low:
                                                                uint32_t,
                                                            mut num_objects:
                                                                uint32_t) {
    wl_resource_post_event(resource_, 0i32 as uint32_t, width, height,
                           offset_x, offset_y, buffer_flags, flags, format,
                           mod_high, mod_low, num_objects);
}
/* *
 * @ingroup iface_zwlr_export_dmabuf_frame_v1
 * Sends an object event to the client owning the resource.
 * @param resource_ The client's resource
 * @param index index of the current object
 * @param fd fd of the current object
 * @param size size in bytes for the current object
 * @param offset starting point for the data in the object's fd
 * @param stride line size in bytes
 * @param plane_index index of the the plane the data in the object applies to
 */
#[inline]
unsafe extern "C" fn zwlr_export_dmabuf_frame_v1_send_object(mut resource_:
                                                                 *mut wl_resource,
                                                             mut index:
                                                                 uint32_t,
                                                             mut fd: int32_t,
                                                             mut size:
                                                                 uint32_t,
                                                             mut offset:
                                                                 uint32_t,
                                                             mut stride:
                                                                 uint32_t,
                                                             mut plane_index:
                                                                 uint32_t) {
    wl_resource_post_event(resource_, 1i32 as uint32_t, index, fd, size,
                           offset, stride, plane_index);
}
/* *
 * @ingroup iface_zwlr_export_dmabuf_frame_v1
 * Sends an ready event to the client owning the resource.
 * @param resource_ The client's resource
 * @param tv_sec_hi high 32 bits of the seconds part of the timestamp
 * @param tv_sec_lo low 32 bits of the seconds part of the timestamp
 * @param tv_nsec nanoseconds part of the timestamp
 */
#[inline]
unsafe extern "C" fn zwlr_export_dmabuf_frame_v1_send_ready(mut resource_:
                                                                *mut wl_resource,
                                                            mut tv_sec_hi:
                                                                uint32_t,
                                                            mut tv_sec_lo:
                                                                uint32_t,
                                                            mut tv_nsec:
                                                                uint32_t) {
    wl_resource_post_event(resource_, 2i32 as uint32_t, tv_sec_hi, tv_sec_lo,
                           tv_nsec);
}
/* *
 * @ingroup iface_zwlr_export_dmabuf_frame_v1
 * Sends an cancel event to the client owning the resource.
 * @param resource_ The client's resource
 * @param reason indicates a reason for cancelling this frame capture
 */
#[inline]
unsafe extern "C" fn zwlr_export_dmabuf_frame_v1_send_cancel(mut resource_:
                                                                 *mut wl_resource,
                                                             mut reason:
                                                                 uint32_t) {
    wl_resource_post_event(resource_, 3i32 as uint32_t, reason);
}
unsafe extern "C" fn frame_from_resource(mut resource: *mut wl_resource)
 -> *mut wlr_export_dmabuf_frame_v1 {
    if wl_resource_instance_of(resource,
                               &zwlr_export_dmabuf_frame_v1_interface,
                               &frame_impl as
                                   *const zwlr_export_dmabuf_frame_v1_interface
                                   as *const libc::c_void) != 0 {
    } else {
        __assert_fail(b"wl_resource_instance_of(resource, &zwlr_export_dmabuf_frame_v1_interface, &frame_impl)\x00"
                          as *const u8 as *const libc::c_char,
                      b"../types/wlr_export_dmabuf_v1.c\x00" as *const u8 as
                          *const libc::c_char, 20i32 as libc::c_uint,
                      (*::std::mem::transmute::<&[u8; 77],
                                                &[libc::c_char; 77]>(b"struct wlr_export_dmabuf_frame_v1 *frame_from_resource(struct wl_resource *)\x00")).as_ptr());
    };
    return wl_resource_get_user_data(resource) as
               *mut wlr_export_dmabuf_frame_v1;
}
unsafe extern "C" fn frame_handle_destroy(mut client: *mut wl_client,
                                          mut resource: *mut wl_resource) {
    wl_resource_destroy(resource);
}
static mut frame_impl: zwlr_export_dmabuf_frame_v1_interface =
    {
    
        {
            let mut init =
                zwlr_export_dmabuf_frame_v1_interface{destroy:
                                                          Some(frame_handle_destroy
                                                                   as
                                                                   unsafe extern "C" fn(_:
                                                                                            *mut wl_client,
                                                                                        _:
                                                                                            *mut wl_resource)
                                                                       ->
                                                                           ()),};
            init
        }
};
unsafe extern "C" fn frame_destroy(mut frame:
                                       *mut wlr_export_dmabuf_frame_v1) {
    if frame.is_null() { return }
    if !(*frame).output.is_null() {
        wlr_output_lock_attach_render((*frame).output, 0i32 != 0);
        if (*frame).cursor_locked {
            wlr_output_lock_software_cursors((*frame).output, 0i32 != 0);
        }
    }
    wl_list_remove(&mut (*frame).link);
    wl_list_remove(&mut (*frame).output_precommit.link);
    wlr_dmabuf_attributes_finish(&mut (*frame).attribs);
    // Make the frame resource inert
    wl_resource_set_user_data((*frame).resource, 0 as *mut libc::c_void);
    free(frame as *mut libc::c_void);
}
unsafe extern "C" fn frame_handle_resource_destroy(mut resource:
                                                       *mut wl_resource) {
    let mut frame: *mut wlr_export_dmabuf_frame_v1 =
        frame_from_resource(resource);
    frame_destroy(frame);
}
unsafe extern "C" fn frame_output_handle_precommit(mut listener:
                                                       *mut wl_listener,
                                                   mut data:
                                                       *mut libc::c_void) {
    let mut frame: *mut wlr_export_dmabuf_frame_v1 =
        (listener as *mut libc::c_char).offset(-128) as
            *mut wlr_export_dmabuf_frame_v1;
    let mut event: *mut wlr_output_event_precommit =
        data as *mut wlr_output_event_precommit;
    if (*(*event).output).pending.committed &
           WLR_OUTPUT_STATE_BUFFER as libc::c_int as libc::c_uint == 0 {
        return
    }
    wl_list_remove(&mut (*frame).output_precommit.link);
    wl_list_init(&mut (*frame).output_precommit.link);
    let mut tv_sec: time_t = (*(*event).when).tv_sec;
    let mut tv_sec_hi: uint32_t =
        if ::std::mem::size_of::<time_t>() as libc::c_ulong >
               4i32 as libc::c_ulong {
            (tv_sec) >> 32i32
        } else { 0i32 as libc::c_long } as uint32_t;
    let mut tv_sec_lo: uint32_t =
        (tv_sec & 0xffffffffu32 as libc::c_long) as uint32_t;
    zwlr_export_dmabuf_frame_v1_send_ready((*frame).resource, tv_sec_hi,
                                           tv_sec_lo,
                                           (*(*event).when).tv_nsec as
                                               uint32_t);
    frame_destroy(frame);
}
unsafe extern "C" fn manager_from_resource(mut resource: *mut wl_resource)
 -> *mut wlr_export_dmabuf_manager_v1 {
    if wl_resource_instance_of(resource,
                               &zwlr_export_dmabuf_manager_v1_interface,
                               &manager_impl as
                                   *const zwlr_export_dmabuf_manager_v1_interface
                                   as *const libc::c_void) != 0 {
    } else {
        __assert_fail(b"wl_resource_instance_of(resource, &zwlr_export_dmabuf_manager_v1_interface, &manager_impl)\x00"
                          as *const u8 as *const libc::c_char,
                      b"../types/wlr_export_dmabuf_v1.c\x00" as *const u8 as
                          *const libc::c_char, 83i32 as libc::c_uint,
                      (*::std::mem::transmute::<&[u8; 81],
                                                &[libc::c_char; 81]>(b"struct wlr_export_dmabuf_manager_v1 *manager_from_resource(struct wl_resource *)\x00")).as_ptr());
    };
    return wl_resource_get_user_data(resource) as
               *mut wlr_export_dmabuf_manager_v1;
}
unsafe extern "C" fn manager_handle_capture_output(mut client: *mut wl_client,
                                                   mut manager_resource:
                                                       *mut wl_resource,
                                                   mut id: uint32_t,
                                                   mut overlay_cursor:
                                                       int32_t,
                                                   mut output_resource:
                                                       *mut wl_resource) {
    let mut manager: *mut wlr_export_dmabuf_manager_v1 =
        manager_from_resource(manager_resource);
    let mut output: *mut wlr_output =
        wlr_output_from_resource(output_resource);
    let mut frame: *mut wlr_export_dmabuf_frame_v1 =
        calloc(1i32 as libc::c_ulong,
               ::std::mem::size_of::<wlr_export_dmabuf_frame_v1>() as
                   libc::c_ulong) as *mut wlr_export_dmabuf_frame_v1;
    if frame.is_null() {
        wl_resource_post_no_memory(manager_resource);
        return
    }
    (*frame).manager = manager;
    (*frame).output = output;
    wl_list_init(&mut (*frame).output_precommit.link);
    let mut version: uint32_t =
        wl_resource_get_version(manager_resource) as uint32_t;
    (*frame).resource =
        wl_resource_create(client, &zwlr_export_dmabuf_frame_v1_interface,
                           version as libc::c_int, id);
    if (*frame).resource.is_null() {
        wl_client_post_no_memory(client);
        free(frame as *mut libc::c_void);
        return
    }
    wl_resource_set_implementation((*frame).resource,
                                   &frame_impl as
                                       *const zwlr_export_dmabuf_frame_v1_interface
                                       as *const libc::c_void,
                                   frame as *mut libc::c_void,
                                   Some(frame_handle_resource_destroy as
                                            unsafe extern "C" fn(_:
                                                                     *mut wl_resource)
                                                -> ()));
    wl_list_insert(&mut (*manager).frames, &mut (*frame).link);
    if output.is_null() || !(*output).enabled ||
           (*(*output).impl_0).export_dmabuf.is_none() {
        zwlr_export_dmabuf_frame_v1_send_cancel((*frame).resource,
                                                ZWLR_EXPORT_DMABUF_FRAME_V1_CANCEL_REASON_PERMANENT
                                                    as libc::c_int as
                                                    uint32_t);
        frame_destroy(frame);
        return
    }
    let mut attribs: *mut wlr_dmabuf_attributes = &mut (*frame).attribs;
    if !wlr_output_export_dmabuf(output, attribs) {
        zwlr_export_dmabuf_frame_v1_send_cancel((*frame).resource,
                                                ZWLR_EXPORT_DMABUF_FRAME_V1_CANCEL_REASON_TEMPORARY
                                                    as libc::c_int as
                                                    uint32_t);
        frame_destroy(frame);
        return
    }
    wlr_output_lock_attach_render((*frame).output, 1i32 != 0);
    if overlay_cursor != 0 {
        wlr_output_lock_software_cursors((*frame).output, 1i32 != 0);
        (*frame).cursor_locked = 1i32 != 0
    }
    let mut frame_flags: uint32_t =
        ZWLR_EXPORT_DMABUF_FRAME_V1_FLAGS_TRANSIENT as libc::c_int as
            uint32_t;
    let mut mod_high: uint32_t = ((*attribs).modifier >> 32i32) as uint32_t;
    let mut mod_low: uint32_t =
        ((*attribs).modifier & 0xffffffffu32 as libc::c_ulong) as uint32_t;
    zwlr_export_dmabuf_frame_v1_send_frame((*frame).resource,
                                           (*output).width as uint32_t,
                                           (*output).height as uint32_t,
                                           0i32 as uint32_t, 0i32 as uint32_t,
                                           (*attribs).flags, frame_flags,
                                           (*attribs).format, mod_high,
                                           mod_low,
                                           (*attribs).n_planes as uint32_t);
    let mut i: libc::c_int = 0i32;
    while i < (*attribs).n_planes {
        let mut size: off_t =
            lseek((*attribs).fd[i as usize], 0i32 as __off64_t, 2i32);
        zwlr_export_dmabuf_frame_v1_send_object((*frame).resource,
                                                i as uint32_t,
                                                (*attribs).fd[i as usize],
                                                size as uint32_t,
                                                (*attribs).offset[i as usize],
                                                (*attribs).stride[i as usize],
                                                i as uint32_t);
        i += 1
    }
    wl_list_remove(&mut (*frame).output_precommit.link);
    wl_signal_add(&mut (*output).events.precommit,
                  &mut (*frame).output_precommit);
    (*frame).output_precommit.notify =
        Some(frame_output_handle_precommit as
                 unsafe extern "C" fn(_: *mut wl_listener,
                                      _: *mut libc::c_void) -> ());
}
unsafe extern "C" fn manager_handle_destroy(mut client: *mut wl_client,
                                            mut manager_resource:
                                                *mut wl_resource) {
    wl_resource_destroy(manager_resource);
}
static mut manager_impl: zwlr_export_dmabuf_manager_v1_interface =
    {
    
        {
            let mut init =
                zwlr_export_dmabuf_manager_v1_interface{capture_output:
                                                            Some(manager_handle_capture_output
                                                                     as
                                                                     unsafe extern "C" fn(_:
                                                                                              *mut wl_client,
                                                                                          _:
                                                                                              *mut wl_resource,
                                                                                          _:
                                                                                              uint32_t,
                                                                                          _:
                                                                                              int32_t,
                                                                                          _:
                                                                                              *mut wl_resource)
                                                                         ->
                                                                             ()),
                                                        destroy:
                                                            Some(manager_handle_destroy
                                                                     as
                                                                     unsafe extern "C" fn(_:
                                                                                              *mut wl_client,
                                                                                          _:
                                                                                              *mut wl_resource)
                                                                         ->
                                                                             ()),};
            init
        }
};
unsafe extern "C" fn manager_bind(mut client: *mut wl_client,
                                  mut data: *mut libc::c_void,
                                  mut version: uint32_t, mut id: uint32_t) {
    let mut manager: *mut wlr_export_dmabuf_manager_v1 =
        data as *mut wlr_export_dmabuf_manager_v1;
    let mut resource: *mut wl_resource =
        wl_resource_create(client, &zwlr_export_dmabuf_manager_v1_interface,
                           version as libc::c_int, id);
    if resource.is_null() { wl_client_post_no_memory(client); return }
    wl_resource_set_implementation(resource,
                                   &manager_impl as
                                       *const zwlr_export_dmabuf_manager_v1_interface
                                       as *const libc::c_void,
                                   manager as *mut libc::c_void, None);
}
unsafe extern "C" fn handle_display_destroy(mut listener: *mut wl_listener,
                                            mut data: *mut libc::c_void) {
    let mut manager: *mut wlr_export_dmabuf_manager_v1 =
        (listener as *mut libc::c_char).offset(-24) as
            *mut wlr_export_dmabuf_manager_v1;
    wlr_signal_emit_safe(&mut (*manager).events.destroy,
                         manager as *mut libc::c_void);
    wl_list_remove(&mut (*manager).display_destroy.link);
    wl_global_destroy((*manager).global);
    free(manager as *mut libc::c_void);
}
#[no_mangle]
pub unsafe extern "C" fn wlr_export_dmabuf_manager_v1_create(mut display:
                                                                 *mut wl_display)
 -> *mut wlr_export_dmabuf_manager_v1 {
    let mut manager: *mut wlr_export_dmabuf_manager_v1 =
        calloc(1i32 as libc::c_ulong,
               ::std::mem::size_of::<wlr_export_dmabuf_manager_v1>() as
                   libc::c_ulong) as *mut wlr_export_dmabuf_manager_v1;
    if manager.is_null() { return 0 as *mut wlr_export_dmabuf_manager_v1 }
    wl_list_init(&mut (*manager).frames);
    wl_signal_init(&mut (*manager).events.destroy);
    (*manager).global =
        wl_global_create(display, &zwlr_export_dmabuf_manager_v1_interface,
                         1i32, manager as *mut libc::c_void,
                         Some(manager_bind as
                                  unsafe extern "C" fn(_: *mut wl_client,
                                                       _: *mut libc::c_void,
                                                       _: uint32_t,
                                                       _: uint32_t) -> ()));
    if (*manager).global.is_null() {
        free(manager as *mut libc::c_void);
        return 0 as *mut wlr_export_dmabuf_manager_v1
    }
    (*manager).display_destroy.notify =
        Some(handle_display_destroy as
                 unsafe extern "C" fn(_: *mut wl_listener,
                                      _: *mut libc::c_void) -> ());
    wl_display_add_destroy_listener(display, &mut (*manager).display_destroy);
    return manager;
}
