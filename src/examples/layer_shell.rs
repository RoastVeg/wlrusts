use libc;
extern "C" {
    pub type _IO_wide_data;
    pub type _IO_codecvt;
    pub type _IO_marker;
    pub type wl_proxy;
    pub type wl_display;
    pub type wl_buffer;
    pub type wl_callback;
    pub type wl_compositor;
    pub type wl_keyboard;
    /* Generated by wayland-scanner 1.17.0 */
    /* *
 * @page page_wlr_layer_shell_unstable_v1 The wlr_layer_shell_unstable_v1 protocol
 * @section page_ifaces_wlr_layer_shell_unstable_v1 Interfaces
 * - @subpage page_iface_zwlr_layer_shell_v1 - create surfaces that are layers of the desktop
 * - @subpage page_iface_zwlr_layer_surface_v1 - layer metadata interface
 * @section page_copyright_wlr_layer_shell_unstable_v1 Copyright
 * <pre>
 *
 * Copyright © 2017 Drew DeVault
 *
 * Permission to use, copy, modify, distribute, and sell this
 * software and its documentation for any purpose is hereby granted
 * without fee, provided that the above copyright notice appear in
 * all copies and that both that copyright notice and this permission
 * notice appear in supporting documentation, and that the name of
 * the copyright holders not be used in advertising or publicity
 * pertaining to distribution of the software without specific,
 * written prior permission.  The copyright holders make no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied
 * warranty.
 *
 * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
 * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
 * FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
 * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
 * ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
 * THIS SOFTWARE.
 * </pre>
 */
    /* Generated by wayland-scanner 1.17.0 */
    /* *
 * @page page_xdg_shell The xdg_shell protocol
 * @section page_ifaces_xdg_shell Interfaces
 * - @subpage page_iface_xdg_wm_base - create desktop-style surfaces
 * - @subpage page_iface_xdg_positioner - child surface positioner
 * - @subpage page_iface_xdg_surface - desktop user interface surface base interface
 * - @subpage page_iface_xdg_toplevel - toplevel surface
 * - @subpage page_iface_xdg_popup - short-lived, popup surfaces for menus
 * @section page_copyright_xdg_shell Copyright
 * <pre>
 *
 * Copyright © 2008-2013 Kristian Høgsberg
 * Copyright © 2013      Rafael Antognolli
 * Copyright © 2013      Jasper St. Pierre
 * Copyright © 2010-2013 Intel Corporation
 * Copyright © 2015-2017 Samsung Electronics Co., Ltd
 * Copyright © 2015-2017 Red Hat Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 * </pre>
 */
    pub type wl_output;
    pub type wl_pointer;
    pub type wl_registry;
    pub type wl_seat;
    pub type wl_shm;
    pub type wl_surface;
    pub type wl_egl_window;
    pub type xdg_popup;
    pub type xdg_surface;
    pub type zwlr_layer_shell_v1;
    pub type wl_cursor_theme;
    pub type zwlr_layer_surface_v1;
    pub type xdg_positioner;
    pub type xdg_wm_base;
    pub type wlr_egl_surface;
    #[no_mangle]
    fn __assert_fail(__assertion: *const libc::c_char,
                     __file: *const libc::c_char, __line: libc::c_uint,
                     __function: *const libc::c_char) -> !;
    #[no_mangle]
    fn glClear(mask: GLbitfield);
    #[no_mangle]
    fn glClearColor(red: GLfloat, green: GLfloat, blue: GLfloat,
                    alpha_0: GLfloat);
    #[no_mangle]
    fn glDisable(cap: GLenum);
    #[no_mangle]
    fn glEnable(cap: GLenum);
    #[no_mangle]
    fn glScissor(x: GLint, y: GLint, width_0: GLsizei, height_0: GLsizei);
    #[no_mangle]
    fn glViewport(x: GLint, y: GLint, width_0: GLsizei, height_0: GLsizei);
    #[no_mangle]
    static mut stderr: *mut FILE;
    #[no_mangle]
    fn fprintf(_: *mut FILE, _: *const libc::c_char, _: ...) -> libc::c_int;
    #[no_mangle]
    fn atof(__nptr: *const libc::c_char) -> libc::c_double;
    #[no_mangle]
    fn atoi(__nptr: *const libc::c_char) -> libc::c_int;
    #[no_mangle]
    fn strtol(_: *const libc::c_char, _: *mut *mut libc::c_char,
              _: libc::c_int) -> libc::c_long;
    #[no_mangle]
    fn strcmp(_: *const libc::c_char, _: *const libc::c_char) -> libc::c_int;
    #[no_mangle]
    fn clock_gettime(__clock_id: clockid_t, __tp: *mut timespec)
     -> libc::c_int;
    #[no_mangle]
    static mut optarg: *mut libc::c_char;
    #[no_mangle]
    fn getopt(___argc: libc::c_int, ___argv: *const *mut libc::c_char,
              __shortopts: *const libc::c_char) -> libc::c_int;
    #[no_mangle]
    fn wl_proxy_marshal(p: *mut wl_proxy, opcode: uint32_t, _: ...);
    #[no_mangle]
    fn wl_proxy_marshal_constructor(proxy: *mut wl_proxy, opcode: uint32_t,
                                    interface: *const wl_interface, _: ...)
     -> *mut wl_proxy;
    #[no_mangle]
    fn wl_proxy_marshal_constructor_versioned(proxy: *mut wl_proxy,
                                              opcode: uint32_t,
                                              interface: *const wl_interface,
                                              version: uint32_t, _: ...)
     -> *mut wl_proxy;
    #[no_mangle]
    fn wl_proxy_destroy(proxy: *mut wl_proxy);
    #[no_mangle]
    fn wl_proxy_add_listener(proxy: *mut wl_proxy,
                             implementation:
                                 *mut Option<unsafe extern "C" fn() -> ()>,
                             data: *mut libc::c_void) -> libc::c_int;
    #[no_mangle]
    fn wl_display_connect(name: *const libc::c_char) -> *mut wl_display;
    #[no_mangle]
    fn wl_display_dispatch(display_0: *mut wl_display) -> libc::c_int;
    #[no_mangle]
    fn wl_display_roundtrip(display_0: *mut wl_display) -> libc::c_int;
    #[no_mangle]
    static wl_registry_interface: wl_interface;
    #[no_mangle]
    static wl_callback_interface: wl_interface;
    #[no_mangle]
    static wl_compositor_interface: wl_interface;
    #[no_mangle]
    static wl_shm_interface: wl_interface;
    #[no_mangle]
    static wl_surface_interface: wl_interface;
    #[no_mangle]
    static wl_seat_interface: wl_interface;
    #[no_mangle]
    static wl_pointer_interface: wl_interface;
    #[no_mangle]
    static wl_keyboard_interface: wl_interface;
    #[no_mangle]
    static wl_output_interface: wl_interface;
    #[no_mangle]
    fn wl_cursor_theme_load(name: *const libc::c_char, size: libc::c_int,
                            shm_0: *mut wl_shm) -> *mut wl_cursor_theme;
    #[no_mangle]
    fn wl_cursor_theme_destroy(theme: *mut wl_cursor_theme);
    #[no_mangle]
    fn wl_cursor_theme_get_cursor(theme: *mut wl_cursor_theme,
                                  name: *const libc::c_char)
     -> *mut wl_cursor;
    #[no_mangle]
    fn wl_cursor_image_get_buffer(image: *mut wl_cursor_image)
     -> *mut wl_buffer;
    #[no_mangle]
    fn wl_egl_window_create(surface: *mut wl_surface, width_0: libc::c_int,
                            height_0: libc::c_int) -> *mut wl_egl_window;
    #[no_mangle]
    fn wl_egl_window_destroy(egl_window_0: *mut wl_egl_window);
    #[no_mangle]
    fn wl_egl_window_resize(egl_window_0: *mut wl_egl_window,
                            width_0: libc::c_int, height_0: libc::c_int,
                            dx: libc::c_int, dy: libc::c_int);
    #[no_mangle]
    fn eglSwapBuffers(dpy: EGLDisplay, surface: EGLSurface) -> EGLBoolean;
    #[no_mangle]
    fn eglMakeCurrent(dpy: EGLDisplay, draw_0: EGLSurface, read: EGLSurface,
                      ctx: EGLContext) -> EGLBoolean;
    /*
 * This an unstable interface of wlroots. No guarantees are made regarding the
 * future consistency of this API.
 */
    // TODO: Allocate and return a wlr_egl
/* *
 * Initializes an EGL context for the given platform and remote display.
 * Will attempt to load all possibly required api functions.
 */
    /* *
 * Frees all related EGL resources, makes the context not-current and
 * unbinds a bound wayland display.
 */
    /* *
 * Binds the given display to the EGL instance.
 * This will allow clients to create EGL surfaces from wayland ones and render
 * to it.
 */
    /* *
 * Returns a surface for the given native window
 * The window must match the remote display the wlr_egl was created with.
 */
    /* *
 * Creates an EGL image from the given wl_drm buffer resource.
 */
    /* *
 * Creates an EGL image from the given dmabuf attributes. Check usability
 * of the dmabuf with wlr_egl_check_import_dmabuf once first.
 */
    /* *
 * Get the available dmabuf formats
 */
    /* *
 * Destroys an EGL image created with the given wlr_egl.
 */
    #[no_mangle]
    fn wlr_egl_destroy_surface(egl_0: *mut wlr_egl, surface: EGLSurface)
     -> bool;
    #[no_mangle]
    fn wlr_egl_create_surface(egl_0: *mut wlr_egl, window: *mut libc::c_void)
     -> EGLSurface;
    #[no_mangle]
    fn wlr_egl_init(egl_0: *mut wlr_egl, platform: EGLenum,
                    remote_display: *mut libc::c_void,
                    config_attribs: *mut EGLint, visual_id: EGLint) -> bool;
    // Will log all messages less than or equal to `verbosity`
// If `callback` is NULL, wlr will use its default logger.
// The function can be called multiple times to update the verbosity or
// callback function.
    #[no_mangle]
    fn wlr_log_init(verbosity: wlr_log_importance, callback: wlr_log_func_t);
    #[no_mangle]
    fn _wlr_log(verbosity: wlr_log_importance, format: *const libc::c_char,
                _: ...);
    /* *
 * @page page_iface_zwlr_layer_shell_v1 zwlr_layer_shell_v1
 * @section page_iface_zwlr_layer_shell_v1_desc Description
 *
 * Clients can use this interface to assign the surface_layer role to
 * wl_surfaces. Such surfaces are assigned to a "layer" of the output and
 * rendered with a defined z-depth respective to each other. They may also be
 * anchored to the edges and corners of a screen and specify input handling
 * semantics. This interface should be suitable for the implementation of
 * many desktop shell components, and a broad number of other applications
 * that interact with the desktop.
 * @section page_iface_zwlr_layer_shell_v1_api API
 * See @ref iface_zwlr_layer_shell_v1.
 */
/* *
 * @defgroup iface_zwlr_layer_shell_v1 The zwlr_layer_shell_v1 interface
 *
 * Clients can use this interface to assign the surface_layer role to
 * wl_surfaces. Such surfaces are assigned to a "layer" of the output and
 * rendered with a defined z-depth respective to each other. They may also be
 * anchored to the edges and corners of a screen and specify input handling
 * semantics. This interface should be suitable for the implementation of
 * many desktop shell components, and a broad number of other applications
 * that interact with the desktop.
 */
    #[no_mangle]
    static zwlr_layer_shell_v1_interface: wl_interface;
    /* *
 * @page page_iface_zwlr_layer_surface_v1 zwlr_layer_surface_v1
 * @section page_iface_zwlr_layer_surface_v1_desc Description
 *
 * An interface that may be implemented by a wl_surface, for surfaces that
 * are designed to be rendered as a layer of a stacked desktop-like
 * environment.
 *
 * Layer surface state (layer, size, anchor, exclusive zone,
 * margin, interactivity) is double-buffered, and will be applied at the
 * time wl_surface.commit of the corresponding wl_surface is called.
 * @section page_iface_zwlr_layer_surface_v1_api API
 * See @ref iface_zwlr_layer_surface_v1.
 */
/* *
 * @defgroup iface_zwlr_layer_surface_v1 The zwlr_layer_surface_v1 interface
 *
 * An interface that may be implemented by a wl_surface, for surfaces that
 * are designed to be rendered as a layer of a stacked desktop-like
 * environment.
 *
 * Layer surface state (layer, size, anchor, exclusive zone,
 * margin, interactivity) is double-buffered, and will be applied at the
 * time wl_surface.commit of the corresponding wl_surface is called.
 */
    #[no_mangle]
    static zwlr_layer_surface_v1_interface: wl_interface;
    /* *
 * @page page_iface_xdg_wm_base xdg_wm_base
 * @section page_iface_xdg_wm_base_desc Description
 *
 * The xdg_wm_base interface is exposed as a global object enabling clients
 * to turn their wl_surfaces into windows in a desktop environment. It
 * defines the basic functionality needed for clients and the compositor to
 * create windows that can be dragged, resized, maximized, etc, as well as
 * creating transient windows such as popup menus.
 * @section page_iface_xdg_wm_base_api API
 * See @ref iface_xdg_wm_base.
 */
/* *
 * @defgroup iface_xdg_wm_base The xdg_wm_base interface
 *
 * The xdg_wm_base interface is exposed as a global object enabling clients
 * to turn their wl_surfaces into windows in a desktop environment. It
 * defines the basic functionality needed for clients and the compositor to
 * create windows that can be dragged, resized, maximized, etc, as well as
 * creating transient windows such as popup menus.
 */
    #[no_mangle]
    static xdg_wm_base_interface: wl_interface;
    /* *
 * @page page_iface_xdg_positioner xdg_positioner
 * @section page_iface_xdg_positioner_desc Description
 *
 * The xdg_positioner provides a collection of rules for the placement of a
 * child surface relative to a parent surface. Rules can be defined to ensure
 * the child surface remains within the visible area's borders, and to
 * specify how the child surface changes its position, such as sliding along
 * an axis, or flipping around a rectangle. These positioner-created rules are
 * constrained by the requirement that a child surface must intersect with or
 * be at least partially adjacent to its parent surface.
 *
 * See the various requests for details about possible rules.
 *
 * At the time of the request, the compositor makes a copy of the rules
 * specified by the xdg_positioner. Thus, after the request is complete the
 * xdg_positioner object can be destroyed or reused; further changes to the
 * object will have no effect on previous usages.
 *
 * For an xdg_positioner object to be considered complete, it must have a
 * non-zero size set by set_size, and a non-zero anchor rectangle set by
 * set_anchor_rect. Passing an incomplete xdg_positioner object when
 * positioning a surface raises an error.
 * @section page_iface_xdg_positioner_api API
 * See @ref iface_xdg_positioner.
 */
/* *
 * @defgroup iface_xdg_positioner The xdg_positioner interface
 *
 * The xdg_positioner provides a collection of rules for the placement of a
 * child surface relative to a parent surface. Rules can be defined to ensure
 * the child surface remains within the visible area's borders, and to
 * specify how the child surface changes its position, such as sliding along
 * an axis, or flipping around a rectangle. These positioner-created rules are
 * constrained by the requirement that a child surface must intersect with or
 * be at least partially adjacent to its parent surface.
 *
 * See the various requests for details about possible rules.
 *
 * At the time of the request, the compositor makes a copy of the rules
 * specified by the xdg_positioner. Thus, after the request is complete the
 * xdg_positioner object can be destroyed or reused; further changes to the
 * object will have no effect on previous usages.
 *
 * For an xdg_positioner object to be considered complete, it must have a
 * non-zero size set by set_size, and a non-zero anchor rectangle set by
 * set_anchor_rect. Passing an incomplete xdg_positioner object when
 * positioning a surface raises an error.
 */
    #[no_mangle]
    static xdg_positioner_interface: wl_interface;
    /* *
 * @page page_iface_xdg_surface xdg_surface
 * @section page_iface_xdg_surface_desc Description
 *
 * An interface that may be implemented by a wl_surface, for
 * implementations that provide a desktop-style user interface.
 *
 * It provides a base set of functionality required to construct user
 * interface elements requiring management by the compositor, such as
 * toplevel windows, menus, etc. The types of functionality are split into
 * xdg_surface roles.
 *
 * Creating an xdg_surface does not set the role for a wl_surface. In order
 * to map an xdg_surface, the client must create a role-specific object
 * using, e.g., get_toplevel, get_popup. The wl_surface for any given
 * xdg_surface can have at most one role, and may not be assigned any role
 * not based on xdg_surface.
 *
 * A role must be assigned before any other requests are made to the
 * xdg_surface object.
 *
 * The client must call wl_surface.commit on the corresponding wl_surface
 * for the xdg_surface state to take effect.
 *
 * Creating an xdg_surface from a wl_surface which has a buffer attached or
 * committed is a client error, and any attempts by a client to attach or
 * manipulate a buffer prior to the first xdg_surface.configure call must
 * also be treated as errors.
 *
 * Mapping an xdg_surface-based role surface is defined as making it
 * possible for the surface to be shown by the compositor. Note that
 * a mapped surface is not guaranteed to be visible once it is mapped.
 *
 * For an xdg_surface to be mapped by the compositor, the following
 * conditions must be met:
 * (1) the client has assigned an xdg_surface-based role to the surface
 * (2) the client has set and committed the xdg_surface state and the
 * role-dependent state to the surface
 * (3) the client has committed a buffer to the surface
 *
 * A newly-unmapped surface is considered to have met condition (1) out
 * of the 3 required conditions for mapping a surface if its role surface
 * has not been destroyed.
 * @section page_iface_xdg_surface_api API
 * See @ref iface_xdg_surface.
 */
/* *
 * @defgroup iface_xdg_surface The xdg_surface interface
 *
 * An interface that may be implemented by a wl_surface, for
 * implementations that provide a desktop-style user interface.
 *
 * It provides a base set of functionality required to construct user
 * interface elements requiring management by the compositor, such as
 * toplevel windows, menus, etc. The types of functionality are split into
 * xdg_surface roles.
 *
 * Creating an xdg_surface does not set the role for a wl_surface. In order
 * to map an xdg_surface, the client must create a role-specific object
 * using, e.g., get_toplevel, get_popup. The wl_surface for any given
 * xdg_surface can have at most one role, and may not be assigned any role
 * not based on xdg_surface.
 *
 * A role must be assigned before any other requests are made to the
 * xdg_surface object.
 *
 * The client must call wl_surface.commit on the corresponding wl_surface
 * for the xdg_surface state to take effect.
 *
 * Creating an xdg_surface from a wl_surface which has a buffer attached or
 * committed is a client error, and any attempts by a client to attach or
 * manipulate a buffer prior to the first xdg_surface.configure call must
 * also be treated as errors.
 *
 * Mapping an xdg_surface-based role surface is defined as making it
 * possible for the surface to be shown by the compositor. Note that
 * a mapped surface is not guaranteed to be visible once it is mapped.
 *
 * For an xdg_surface to be mapped by the compositor, the following
 * conditions must be met:
 * (1) the client has assigned an xdg_surface-based role to the surface
 * (2) the client has set and committed the xdg_surface state and the
 * role-dependent state to the surface
 * (3) the client has committed a buffer to the surface
 *
 * A newly-unmapped surface is considered to have met condition (1) out
 * of the 3 required conditions for mapping a surface if its role surface
 * has not been destroyed.
 */
    #[no_mangle]
    static xdg_surface_interface: wl_interface;
    /* *
 * @page page_iface_xdg_popup xdg_popup
 * @section page_iface_xdg_popup_desc Description
 *
 * A popup surface is a short-lived, temporary surface. It can be used to
 * implement for example menus, popovers, tooltips and other similar user
 * interface concepts.
 *
 * A popup can be made to take an explicit grab. See xdg_popup.grab for
 * details.
 *
 * When the popup is dismissed, a popup_done event will be sent out, and at
 * the same time the surface will be unmapped. See the xdg_popup.popup_done
 * event for details.
 *
 * Explicitly destroying the xdg_popup object will also dismiss the popup and
 * unmap the surface. Clients that want to dismiss the popup when another
 * surface of their own is clicked should dismiss the popup using the destroy
 * request.
 *
 * A newly created xdg_popup will be stacked on top of all previously created
 * xdg_popup surfaces associated with the same xdg_toplevel.
 *
 * The parent of an xdg_popup must be mapped (see the xdg_surface
 * description) before the xdg_popup itself.
 *
 * The x and y arguments passed when creating the popup object specify
 * where the top left of the popup should be placed, relative to the
 * local surface coordinates of the parent surface. See
 * xdg_surface.get_popup. An xdg_popup must intersect with or be at least
 * partially adjacent to its parent surface.
 *
 * The client must call wl_surface.commit on the corresponding wl_surface
 * for the xdg_popup state to take effect.
 * @section page_iface_xdg_popup_api API
 * See @ref iface_xdg_popup.
 */
/* *
 * @defgroup iface_xdg_popup The xdg_popup interface
 *
 * A popup surface is a short-lived, temporary surface. It can be used to
 * implement for example menus, popovers, tooltips and other similar user
 * interface concepts.
 *
 * A popup can be made to take an explicit grab. See xdg_popup.grab for
 * details.
 *
 * When the popup is dismissed, a popup_done event will be sent out, and at
 * the same time the surface will be unmapped. See the xdg_popup.popup_done
 * event for details.
 *
 * Explicitly destroying the xdg_popup object will also dismiss the popup and
 * unmap the surface. Clients that want to dismiss the popup when another
 * surface of their own is clicked should dismiss the popup using the destroy
 * request.
 *
 * A newly created xdg_popup will be stacked on top of all previously created
 * xdg_popup surfaces associated with the same xdg_toplevel.
 *
 * The parent of an xdg_popup must be mapped (see the xdg_surface
 * description) before the xdg_popup itself.
 *
 * The x and y arguments passed when creating the popup object specify
 * where the top left of the popup should be placed, relative to the
 * local surface coordinates of the parent surface. See
 * xdg_surface.get_popup. An xdg_popup must intersect with or be at least
 * partially adjacent to its parent surface.
 *
 * The client must call wl_surface.commit on the corresponding wl_surface
 * for the xdg_popup state to take effect.
 */
    #[no_mangle]
    static xdg_popup_interface: wl_interface;
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct __va_list_tag {
    pub gp_offset: libc::c_uint,
    pub fp_offset: libc::c_uint,
    pub overflow_arg_area: *mut libc::c_void,
    pub reg_save_area: *mut libc::c_void,
}
pub type __int32_t = libc::c_int;
pub type __uint32_t = libc::c_uint;
pub type __uint64_t = libc::c_ulong;
pub type __off_t = libc::c_long;
pub type __off64_t = libc::c_long;
pub type __time_t = libc::c_long;
pub type __clockid_t = libc::c_int;
pub type __syscall_slong_t = libc::c_long;
pub type int32_t = __int32_t;
pub type uint32_t = __uint32_t;
pub type uint64_t = __uint64_t;
pub type khronos_int32_t = int32_t;
pub type khronos_float_t = libc::c_float;
pub type GLenum = libc::c_uint;
pub type GLfloat = khronos_float_t;
pub type GLbitfield = libc::c_uint;
pub type GLint = libc::c_int;
pub type GLsizei = libc::c_int;
pub type size_t = libc::c_ulong;
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct _IO_FILE {
    pub _flags: libc::c_int,
    pub _IO_read_ptr: *mut libc::c_char,
    pub _IO_read_end: *mut libc::c_char,
    pub _IO_read_base: *mut libc::c_char,
    pub _IO_write_base: *mut libc::c_char,
    pub _IO_write_ptr: *mut libc::c_char,
    pub _IO_write_end: *mut libc::c_char,
    pub _IO_buf_base: *mut libc::c_char,
    pub _IO_buf_end: *mut libc::c_char,
    pub _IO_save_base: *mut libc::c_char,
    pub _IO_backup_base: *mut libc::c_char,
    pub _IO_save_end: *mut libc::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: libc::c_int,
    pub _flags2: libc::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: libc::c_ushort,
    pub _vtable_offset: libc::c_schar,
    pub _shortbuf: [libc::c_char; 1],
    pub _lock: *mut libc::c_void,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut libc::c_void,
    pub __pad5: size_t,
    pub _mode: libc::c_int,
    pub _unused2: [libc::c_char; 20],
}
pub type _IO_lock_t = ();
pub type FILE = _IO_FILE;
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
pub type clockid_t = __clockid_t;
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wl_message {
    pub name: *const libc::c_char,
    pub signature: *const libc::c_char,
    pub types: *mut *const wl_interface,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wl_interface {
    pub name: *const libc::c_char,
    pub version: libc::c_int,
    pub method_count: libc::c_int,
    pub methods: *const wl_message,
    pub event_count: libc::c_int,
    pub events: *const wl_message,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wl_list {
    pub prev: *mut wl_list,
    pub next: *mut wl_list,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wl_array {
    pub size: size_t,
    pub alloc: size_t,
    pub data: *mut libc::c_void,
}
pub type wl_fixed_t = int32_t;
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wl_listener {
    pub link: wl_list,
    pub notify: wl_notify_func_t,
}
pub type wl_notify_func_t
    =
    Option<unsafe extern "C" fn(_: *mut wl_listener, _: *mut libc::c_void)
               -> ()>;
pub type wlr_log_func_t
    =
    Option<unsafe extern "C" fn(_: wlr_log_importance, _: *const libc::c_char,
                                _: ::std::ffi::VaList) -> ()>;
/*
 * This is a stable interface of wlroots. Future changes will be limited to:
 *
 * - New functions
 * - New struct members
 * - New enum members
 *
 * Note that wlroots does not make an ABI compatibility promise - in the future,
 * the layout and size of structs used by wlroots may change, requiring code
 * depending on this header to be recompiled (but not edited).
 *
 * Breaking changes are announced by email and follow a 1-year deprecation
 * schedule. Send an email to ~sircmpwn/wlroots-announce+subscribe@lists.sr.ht
 * to receive these announcements.
 */
pub type wlr_log_importance = libc::c_uint;
pub const WLR_LOG_IMPORTANCE_LAST: wlr_log_importance = 4;
pub const WLR_DEBUG: wlr_log_importance = 3;
pub const WLR_INFO: wlr_log_importance = 2;
pub const WLR_ERROR: wlr_log_importance = 1;
pub const WLR_SILENT: wlr_log_importance = 0;
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wl_cursor {
    pub image_count: libc::c_uint,
    pub images: *mut *mut wl_cursor_image,
    pub name: *mut libc::c_char,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wl_cursor_image {
    pub width: uint32_t,
    pub height: uint32_t,
    pub hotspot_x: uint32_t,
    pub hotspot_y: uint32_t,
    pub delay: uint32_t,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wl_registry_listener {
    pub global: Option<unsafe extern "C" fn(_: *mut libc::c_void,
                                            _: *mut wl_registry, _: uint32_t,
                                            _: *const libc::c_char,
                                            _: uint32_t) -> ()>,
    pub global_remove: Option<unsafe extern "C" fn(_: *mut libc::c_void,
                                                   _: *mut wl_registry,
                                                   _: uint32_t) -> ()>,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wl_callback_listener {
    pub done: Option<unsafe extern "C" fn(_: *mut libc::c_void,
                                          _: *mut wl_callback, _: uint32_t)
                         -> ()>,
}
pub type wl_shm_format = libc::c_uint;
pub const WL_SHM_FORMAT_YVU444: wl_shm_format = 875714137;
pub const WL_SHM_FORMAT_YUV444: wl_shm_format = 875713881;
pub const WL_SHM_FORMAT_YVU422: wl_shm_format = 909203033;
pub const WL_SHM_FORMAT_YUV422: wl_shm_format = 909202777;
pub const WL_SHM_FORMAT_YVU420: wl_shm_format = 842094169;
pub const WL_SHM_FORMAT_YUV420: wl_shm_format = 842093913;
pub const WL_SHM_FORMAT_YVU411: wl_shm_format = 825316953;
pub const WL_SHM_FORMAT_YUV411: wl_shm_format = 825316697;
pub const WL_SHM_FORMAT_YVU410: wl_shm_format = 961893977;
pub const WL_SHM_FORMAT_YUV410: wl_shm_format = 961959257;
pub const WL_SHM_FORMAT_NV61: wl_shm_format = 825644622;
pub const WL_SHM_FORMAT_NV16: wl_shm_format = 909203022;
pub const WL_SHM_FORMAT_NV21: wl_shm_format = 825382478;
pub const WL_SHM_FORMAT_NV12: wl_shm_format = 842094158;
pub const WL_SHM_FORMAT_AYUV: wl_shm_format = 1448433985;
pub const WL_SHM_FORMAT_VYUY: wl_shm_format = 1498765654;
pub const WL_SHM_FORMAT_UYVY: wl_shm_format = 1498831189;
pub const WL_SHM_FORMAT_YVYU: wl_shm_format = 1431918169;
pub const WL_SHM_FORMAT_YUYV: wl_shm_format = 1448695129;
pub const WL_SHM_FORMAT_BGRA1010102: wl_shm_format = 808665410;
pub const WL_SHM_FORMAT_RGBA1010102: wl_shm_format = 808665426;
pub const WL_SHM_FORMAT_ABGR2101010: wl_shm_format = 808665665;
pub const WL_SHM_FORMAT_ARGB2101010: wl_shm_format = 808669761;
pub const WL_SHM_FORMAT_BGRX1010102: wl_shm_format = 808671298;
pub const WL_SHM_FORMAT_RGBX1010102: wl_shm_format = 808671314;
pub const WL_SHM_FORMAT_XBGR2101010: wl_shm_format = 808665688;
pub const WL_SHM_FORMAT_XRGB2101010: wl_shm_format = 808669784;
pub const WL_SHM_FORMAT_BGRA8888: wl_shm_format = 875708738;
pub const WL_SHM_FORMAT_RGBA8888: wl_shm_format = 875708754;
pub const WL_SHM_FORMAT_ABGR8888: wl_shm_format = 875708993;
pub const WL_SHM_FORMAT_BGRX8888: wl_shm_format = 875714626;
pub const WL_SHM_FORMAT_RGBX8888: wl_shm_format = 875714642;
pub const WL_SHM_FORMAT_XBGR8888: wl_shm_format = 875709016;
pub const WL_SHM_FORMAT_BGR888: wl_shm_format = 875710274;
pub const WL_SHM_FORMAT_RGB888: wl_shm_format = 875710290;
pub const WL_SHM_FORMAT_BGR565: wl_shm_format = 909199170;
pub const WL_SHM_FORMAT_RGB565: wl_shm_format = 909199186;
pub const WL_SHM_FORMAT_BGRA5551: wl_shm_format = 892420418;
pub const WL_SHM_FORMAT_RGBA5551: wl_shm_format = 892420434;
pub const WL_SHM_FORMAT_ABGR1555: wl_shm_format = 892420673;
pub const WL_SHM_FORMAT_ARGB1555: wl_shm_format = 892424769;
pub const WL_SHM_FORMAT_BGRX5551: wl_shm_format = 892426306;
pub const WL_SHM_FORMAT_RGBX5551: wl_shm_format = 892426322;
pub const WL_SHM_FORMAT_XBGR1555: wl_shm_format = 892420696;
pub const WL_SHM_FORMAT_XRGB1555: wl_shm_format = 892424792;
pub const WL_SHM_FORMAT_BGRA4444: wl_shm_format = 842088770;
pub const WL_SHM_FORMAT_RGBA4444: wl_shm_format = 842088786;
pub const WL_SHM_FORMAT_ABGR4444: wl_shm_format = 842089025;
pub const WL_SHM_FORMAT_ARGB4444: wl_shm_format = 842093121;
pub const WL_SHM_FORMAT_BGRX4444: wl_shm_format = 842094658;
pub const WL_SHM_FORMAT_RGBX4444: wl_shm_format = 842094674;
pub const WL_SHM_FORMAT_XBGR4444: wl_shm_format = 842089048;
pub const WL_SHM_FORMAT_XRGB4444: wl_shm_format = 842093144;
pub const WL_SHM_FORMAT_BGR233: wl_shm_format = 944916290;
pub const WL_SHM_FORMAT_RGB332: wl_shm_format = 943867730;
pub const WL_SHM_FORMAT_C8: wl_shm_format = 538982467;
pub const WL_SHM_FORMAT_XRGB8888: wl_shm_format = 1;
pub const WL_SHM_FORMAT_ARGB8888: wl_shm_format = 0;
pub type wl_seat_capability = libc::c_uint;
pub const WL_SEAT_CAPABILITY_TOUCH: wl_seat_capability = 4;
pub const WL_SEAT_CAPABILITY_KEYBOARD: wl_seat_capability = 2;
pub const WL_SEAT_CAPABILITY_POINTER: wl_seat_capability = 1;
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wl_seat_listener {
    pub capabilities: Option<unsafe extern "C" fn(_: *mut libc::c_void,
                                                  _: *mut wl_seat,
                                                  _: uint32_t) -> ()>,
    pub name: Option<unsafe extern "C" fn(_: *mut libc::c_void,
                                          _: *mut wl_seat,
                                          _: *const libc::c_char) -> ()>,
}
pub type wl_pointer_button_state = libc::c_uint;
pub const WL_POINTER_BUTTON_STATE_PRESSED: wl_pointer_button_state = 1;
pub const WL_POINTER_BUTTON_STATE_RELEASED: wl_pointer_button_state = 0;
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wl_pointer_listener {
    pub enter: Option<unsafe extern "C" fn(_: *mut libc::c_void,
                                           _: *mut wl_pointer, _: uint32_t,
                                           _: *mut wl_surface, _: wl_fixed_t,
                                           _: wl_fixed_t) -> ()>,
    pub leave: Option<unsafe extern "C" fn(_: *mut libc::c_void,
                                           _: *mut wl_pointer, _: uint32_t,
                                           _: *mut wl_surface) -> ()>,
    pub motion: Option<unsafe extern "C" fn(_: *mut libc::c_void,
                                            _: *mut wl_pointer, _: uint32_t,
                                            _: wl_fixed_t, _: wl_fixed_t)
                           -> ()>,
    pub button: Option<unsafe extern "C" fn(_: *mut libc::c_void,
                                            _: *mut wl_pointer, _: uint32_t,
                                            _: uint32_t, _: uint32_t,
                                            _: uint32_t) -> ()>,
    pub axis: Option<unsafe extern "C" fn(_: *mut libc::c_void,
                                          _: *mut wl_pointer, _: uint32_t,
                                          _: uint32_t, _: wl_fixed_t) -> ()>,
    pub frame: Option<unsafe extern "C" fn(_: *mut libc::c_void,
                                           _: *mut wl_pointer) -> ()>,
    pub axis_source: Option<unsafe extern "C" fn(_: *mut libc::c_void,
                                                 _: *mut wl_pointer,
                                                 _: uint32_t) -> ()>,
    pub axis_stop: Option<unsafe extern "C" fn(_: *mut libc::c_void,
                                               _: *mut wl_pointer,
                                               _: uint32_t, _: uint32_t)
                              -> ()>,
    pub axis_discrete: Option<unsafe extern "C" fn(_: *mut libc::c_void,
                                                   _: *mut wl_pointer,
                                                   _: uint32_t, _: int32_t)
                                  -> ()>,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wl_keyboard_listener {
    pub keymap: Option<unsafe extern "C" fn(_: *mut libc::c_void,
                                            _: *mut wl_keyboard, _: uint32_t,
                                            _: int32_t, _: uint32_t) -> ()>,
    pub enter: Option<unsafe extern "C" fn(_: *mut libc::c_void,
                                           _: *mut wl_keyboard, _: uint32_t,
                                           _: *mut wl_surface,
                                           _: *mut wl_array) -> ()>,
    pub leave: Option<unsafe extern "C" fn(_: *mut libc::c_void,
                                           _: *mut wl_keyboard, _: uint32_t,
                                           _: *mut wl_surface) -> ()>,
    pub key: Option<unsafe extern "C" fn(_: *mut libc::c_void,
                                         _: *mut wl_keyboard, _: uint32_t,
                                         _: uint32_t, _: uint32_t,
                                         _: uint32_t) -> ()>,
    pub modifiers: Option<unsafe extern "C" fn(_: *mut libc::c_void,
                                               _: *mut wl_keyboard,
                                               _: uint32_t, _: uint32_t,
                                               _: uint32_t, _: uint32_t,
                                               _: uint32_t) -> ()>,
    pub repeat_info: Option<unsafe extern "C" fn(_: *mut libc::c_void,
                                                 _: *mut wl_keyboard,
                                                 _: int32_t, _: int32_t)
                                -> ()>,
}
pub type EGLint = khronos_int32_t;
pub type EGLBoolean = libc::c_uint;
pub type EGLDisplay = *mut libc::c_void;
pub type EGLConfig = *mut libc::c_void;
pub type EGLSurface = *mut libc::c_void;
pub type EGLContext = *mut libc::c_void;
pub type EGLenum = libc::c_uint;
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wlr_drm_format {
    pub format: uint32_t,
    pub len: size_t,
    pub cap: size_t,
    pub modifiers: [uint64_t; 0],
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wlr_drm_format_set {
    pub len: size_t,
    pub cap: size_t,
    pub formats: *mut *mut wlr_drm_format,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wlr_egl {
    pub platform: EGLenum,
    pub display: EGLDisplay,
    pub config: EGLConfig,
    pub context: EGLContext,
    pub exts_str: *const libc::c_char,
    pub exts: C2RustUnnamed,
    pub wl_display: *mut wl_display,
    pub dmabuf_formats: wlr_drm_format_set,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct C2RustUnnamed {
    pub bind_wayland_display_wl: bool,
    pub buffer_age_ext: bool,
    pub image_base_khr: bool,
    pub image_dma_buf_export_mesa: bool,
    pub image_dmabuf_import_ext: bool,
    pub image_dmabuf_import_modifiers_ext: bool,
    pub swap_buffers_with_damage_ext: bool,
    pub swap_buffers_with_damage_khr: bool,
}
/* ZWLR_LAYER_SHELL_V1_ERROR_ENUM */
/* *
 * @ingroup iface_zwlr_layer_shell_v1
 * available layers for surfaces
 *
 * These values indicate which layers a surface can be rendered in. They
 * are ordered by z depth, bottom-most first. Traditional shell surfaces
 * will typically be rendered between the bottom and top layers.
 * Fullscreen shell surfaces are typically rendered at the top layer.
 * Multiple surfaces can share a single layer, and ordering within a
 * single layer is undefined.
 */
pub type zwlr_layer_shell_v1_layer = libc::c_uint;
pub const ZWLR_LAYER_SHELL_V1_LAYER_OVERLAY: zwlr_layer_shell_v1_layer = 3;
pub const ZWLR_LAYER_SHELL_V1_LAYER_TOP: zwlr_layer_shell_v1_layer = 2;
pub const ZWLR_LAYER_SHELL_V1_LAYER_BOTTOM: zwlr_layer_shell_v1_layer = 1;
pub const ZWLR_LAYER_SHELL_V1_LAYER_BACKGROUND: zwlr_layer_shell_v1_layer = 0;
/* ZWLR_LAYER_SURFACE_V1_ERROR_ENUM */
pub type zwlr_layer_surface_v1_anchor = libc::c_uint;
/* *
	 * the right edge of the anchor rectangle
	 */
pub const ZWLR_LAYER_SURFACE_V1_ANCHOR_RIGHT: zwlr_layer_surface_v1_anchor =
    8;
/* *
	 * the left edge of the anchor rectangle
	 */
pub const ZWLR_LAYER_SURFACE_V1_ANCHOR_LEFT: zwlr_layer_surface_v1_anchor = 4;
/* *
	 * the bottom edge of the anchor rectangle
	 */
pub const ZWLR_LAYER_SURFACE_V1_ANCHOR_BOTTOM: zwlr_layer_surface_v1_anchor =
    2;
/* *
	 * the top edge of the anchor rectangle
	 */
pub const ZWLR_LAYER_SURFACE_V1_ANCHOR_TOP: zwlr_layer_surface_v1_anchor = 1;
/* ZWLR_LAYER_SURFACE_V1_ANCHOR_ENUM */
/* *
 * @ingroup iface_zwlr_layer_surface_v1
 * @struct zwlr_layer_surface_v1_listener
 */
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct zwlr_layer_surface_v1_listener {
    pub configure: Option<unsafe extern "C" fn(_: *mut libc::c_void,
                                               _: *mut zwlr_layer_surface_v1,
                                               _: uint32_t, _: uint32_t,
                                               _: uint32_t) -> ()>,
    pub closed: Option<unsafe extern "C" fn(_: *mut libc::c_void,
                                            _: *mut zwlr_layer_surface_v1)
                           -> ()>,
}
/* XDG_POSITIONER_ERROR_ENUM */
pub type xdg_positioner_anchor = libc::c_uint;
pub const XDG_POSITIONER_ANCHOR_BOTTOM_RIGHT: xdg_positioner_anchor = 8;
pub const XDG_POSITIONER_ANCHOR_TOP_RIGHT: xdg_positioner_anchor = 7;
pub const XDG_POSITIONER_ANCHOR_BOTTOM_LEFT: xdg_positioner_anchor = 6;
pub const XDG_POSITIONER_ANCHOR_TOP_LEFT: xdg_positioner_anchor = 5;
pub const XDG_POSITIONER_ANCHOR_RIGHT: xdg_positioner_anchor = 4;
pub const XDG_POSITIONER_ANCHOR_LEFT: xdg_positioner_anchor = 3;
pub const XDG_POSITIONER_ANCHOR_BOTTOM: xdg_positioner_anchor = 2;
pub const XDG_POSITIONER_ANCHOR_TOP: xdg_positioner_anchor = 1;
pub const XDG_POSITIONER_ANCHOR_NONE: xdg_positioner_anchor = 0;
/* XDG_SURFACE_ERROR_ENUM */
/* *
 * @ingroup iface_xdg_surface
 * @struct xdg_surface_listener
 */
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct xdg_surface_listener {
    pub configure: Option<unsafe extern "C" fn(_: *mut libc::c_void,
                                               _: *mut xdg_surface,
                                               _: uint32_t) -> ()>,
}
/* XDG_POPUP_ERROR_ENUM */
/* *
 * @ingroup iface_xdg_popup
 * @struct xdg_popup_listener
 */
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct xdg_popup_listener {
    pub configure: Option<unsafe extern "C" fn(_: *mut libc::c_void,
                                               _: *mut xdg_popup, _: int32_t,
                                               _: int32_t, _: int32_t,
                                               _: int32_t) -> ()>,
    pub popup_done: Option<unsafe extern "C" fn(_: *mut libc::c_void,
                                                _: *mut xdg_popup) -> ()>,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct C2RustUnnamed_0 {
    pub last_frame: timespec,
    pub color: [libc::c_float; 3],
    pub dec: libc::c_int,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct C2RustUnnamed_1 {
    pub name: *const libc::c_char,
    pub value: uint32_t,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct C2RustUnnamed_2 {
    pub name: *const libc::c_char,
    pub value: zwlr_layer_shell_v1_layer,
}
#[inline]
unsafe extern "C" fn wl_fixed_to_int(mut f: wl_fixed_t) -> libc::c_int {
    return f / 256i32;
}
#[inline]
unsafe extern "C" fn wl_display_get_registry(mut wl_display: *mut wl_display)
 -> *mut wl_registry {
    let mut registry: *mut wl_proxy = 0 as *mut wl_proxy;
    registry =
        wl_proxy_marshal_constructor(wl_display as *mut wl_proxy,
                                     1i32 as uint32_t,
                                     &wl_registry_interface as
                                         *const wl_interface,
                                     0 as *mut libc::c_void);
    return registry as *mut wl_registry;
}
#[inline]
unsafe extern "C" fn wl_registry_add_listener(mut wl_registry:
                                                  *mut wl_registry,
                                              mut listener:
                                                  *const wl_registry_listener,
                                              mut data: *mut libc::c_void)
 -> libc::c_int {
    return wl_proxy_add_listener(wl_registry as *mut wl_proxy,
                                 listener as
                                     *mut Option<unsafe extern "C" fn()
                                                     -> ()>, data);
}
#[inline]
unsafe extern "C" fn wl_registry_bind(mut wl_registry: *mut wl_registry,
                                      mut name: uint32_t,
                                      mut interface: *const wl_interface,
                                      mut version: uint32_t)
 -> *mut libc::c_void {
    let mut id: *mut wl_proxy = 0 as *mut wl_proxy;
    id =
        wl_proxy_marshal_constructor_versioned(wl_registry as *mut wl_proxy,
                                               0i32 as uint32_t, interface,
                                               version, name,
                                               (*interface).name, version,
                                               0 as *mut libc::c_void);
    return id as *mut libc::c_void;
}
#[inline]
unsafe extern "C" fn wl_callback_add_listener(mut wl_callback:
                                                  *mut wl_callback,
                                              mut listener:
                                                  *const wl_callback_listener,
                                              mut data: *mut libc::c_void)
 -> libc::c_int {
    return wl_proxy_add_listener(wl_callback as *mut wl_proxy,
                                 listener as
                                     *mut Option<unsafe extern "C" fn()
                                                     -> ()>, data);
}
#[inline]
unsafe extern "C" fn wl_callback_destroy(mut wl_callback: *mut wl_callback) {
    wl_proxy_destroy(wl_callback as *mut wl_proxy);
}
#[inline]
unsafe extern "C" fn wl_compositor_create_surface(mut wl_compositor:
                                                      *mut wl_compositor)
 -> *mut wl_surface {
    let mut id: *mut wl_proxy = 0 as *mut wl_proxy;
    id =
        wl_proxy_marshal_constructor(wl_compositor as *mut wl_proxy,
                                     0i32 as uint32_t,
                                     &wl_surface_interface as
                                         *const wl_interface,
                                     0 as *mut libc::c_void);
    return id as *mut wl_surface;
}
#[inline]
unsafe extern "C" fn wl_surface_destroy(mut wl_surface_0: *mut wl_surface) {
    wl_proxy_marshal(wl_surface_0 as *mut wl_proxy, 0i32 as uint32_t);
    wl_proxy_destroy(wl_surface_0 as *mut wl_proxy);
}
#[inline]
unsafe extern "C" fn wl_surface_attach(mut wl_surface_0: *mut wl_surface,
                                       mut buffer: *mut wl_buffer,
                                       mut x: int32_t, mut y: int32_t) {
    wl_proxy_marshal(wl_surface_0 as *mut wl_proxy, 1i32 as uint32_t, buffer,
                     x, y);
}
#[inline]
unsafe extern "C" fn wl_surface_damage(mut wl_surface_0: *mut wl_surface,
                                       mut x: int32_t, mut y: int32_t,
                                       mut width_0: int32_t,
                                       mut height_0: int32_t) {
    wl_proxy_marshal(wl_surface_0 as *mut wl_proxy, 2i32 as uint32_t, x, y,
                     width_0, height_0);
}
#[inline]
unsafe extern "C" fn wl_surface_frame(mut wl_surface_0: *mut wl_surface)
 -> *mut wl_callback {
    let mut callback: *mut wl_proxy = 0 as *mut wl_proxy;
    callback =
        wl_proxy_marshal_constructor(wl_surface_0 as *mut wl_proxy,
                                     3i32 as uint32_t,
                                     &wl_callback_interface as
                                         *const wl_interface,
                                     0 as *mut libc::c_void);
    return callback as *mut wl_callback;
}
#[inline]
unsafe extern "C" fn wl_surface_commit(mut wl_surface_0: *mut wl_surface) {
    wl_proxy_marshal(wl_surface_0 as *mut wl_proxy, 6i32 as uint32_t);
}
#[inline]
unsafe extern "C" fn wl_seat_add_listener(mut wl_seat: *mut wl_seat,
                                          mut listener:
                                              *const wl_seat_listener,
                                          mut data: *mut libc::c_void)
 -> libc::c_int {
    return wl_proxy_add_listener(wl_seat as *mut wl_proxy,
                                 listener as
                                     *mut Option<unsafe extern "C" fn()
                                                     -> ()>, data);
}
#[inline]
unsafe extern "C" fn wl_seat_get_pointer(mut wl_seat: *mut wl_seat)
 -> *mut wl_pointer {
    let mut id: *mut wl_proxy = 0 as *mut wl_proxy;
    id =
        wl_proxy_marshal_constructor(wl_seat as *mut wl_proxy,
                                     0i32 as uint32_t,
                                     &wl_pointer_interface as
                                         *const wl_interface,
                                     0 as *mut libc::c_void);
    return id as *mut wl_pointer;
}
#[inline]
unsafe extern "C" fn wl_seat_get_keyboard(mut wl_seat: *mut wl_seat)
 -> *mut wl_keyboard {
    let mut id: *mut wl_proxy = 0 as *mut wl_proxy;
    id =
        wl_proxy_marshal_constructor(wl_seat as *mut wl_proxy,
                                     1i32 as uint32_t,
                                     &wl_keyboard_interface as
                                         *const wl_interface,
                                     0 as *mut libc::c_void);
    return id as *mut wl_keyboard;
}
#[inline]
unsafe extern "C" fn wl_pointer_add_listener(mut wl_pointer: *mut wl_pointer,
                                             mut listener:
                                                 *const wl_pointer_listener,
                                             mut data: *mut libc::c_void)
 -> libc::c_int {
    return wl_proxy_add_listener(wl_pointer as *mut wl_proxy,
                                 listener as
                                     *mut Option<unsafe extern "C" fn()
                                                     -> ()>, data);
}
#[inline]
unsafe extern "C" fn wl_pointer_set_cursor(mut wl_pointer: *mut wl_pointer,
                                           mut serial: uint32_t,
                                           mut surface: *mut wl_surface,
                                           mut hotspot_x: int32_t,
                                           mut hotspot_y: int32_t) {
    wl_proxy_marshal(wl_pointer as *mut wl_proxy, 0i32 as uint32_t, serial,
                     surface, hotspot_x, hotspot_y);
}
#[inline]
unsafe extern "C" fn wl_keyboard_add_listener(mut wl_keyboard:
                                                  *mut wl_keyboard,
                                              mut listener:
                                                  *const wl_keyboard_listener,
                                              mut data: *mut libc::c_void)
 -> libc::c_int {
    return wl_proxy_add_listener(wl_keyboard as *mut wl_proxy,
                                 listener as
                                     *mut Option<unsafe extern "C" fn()
                                                     -> ()>, data);
}
/* *
 * @ingroup iface_zwlr_layer_shell_v1
 *
 * Create a layer surface for an existing surface. This assigns the role of
 * layer_surface, or raises a protocol error if another role is already
 * assigned.
 *
 * Creating a layer surface from a wl_surface which has a buffer attached
 * or committed is a client error, and any attempts by a client to attach
 * or manipulate a buffer prior to the first layer_surface.configure call
 * must also be treated as errors.
 *
 * You may pass NULL for output to allow the compositor to decide which
 * output to use. Generally this will be the one that the user most
 * recently interacted with.
 *
 * Clients can specify a namespace that defines the purpose of the layer
 * surface.
 */
#[inline]
unsafe extern "C" fn zwlr_layer_shell_v1_get_layer_surface(mut zwlr_layer_shell_v1:
                                                               *mut zwlr_layer_shell_v1,
                                                           mut surface:
                                                               *mut wl_surface,
                                                           mut output_0:
                                                               *mut wl_output,
                                                           mut layer_0:
                                                               uint32_t,
                                                           mut namespace:
                                                               *const libc::c_char)
 -> *mut zwlr_layer_surface_v1 {
    let mut id: *mut wl_proxy = 0 as *mut wl_proxy;
    id =
        wl_proxy_marshal_constructor(zwlr_layer_shell_v1 as *mut wl_proxy,
                                     0i32 as uint32_t,
                                     &zwlr_layer_surface_v1_interface as
                                         *const wl_interface,
                                     0 as *mut libc::c_void, surface,
                                     output_0, layer_0, namespace);
    return id as *mut zwlr_layer_surface_v1;
}
/* *
 * @ingroup iface_zwlr_layer_surface_v1
 */
#[inline]
unsafe extern "C" fn zwlr_layer_surface_v1_add_listener(mut zwlr_layer_surface_v1:
                                                            *mut zwlr_layer_surface_v1,
                                                        mut listener:
                                                            *const zwlr_layer_surface_v1_listener,
                                                        mut data:
                                                            *mut libc::c_void)
 -> libc::c_int {
    return wl_proxy_add_listener(zwlr_layer_surface_v1 as *mut wl_proxy,
                                 listener as
                                     *mut Option<unsafe extern "C" fn()
                                                     -> ()>, data);
}
/* *
 * @ingroup iface_zwlr_layer_surface_v1
 *
 * Sets the size of the surface in surface-local coordinates. The
 * compositor will display the surface centered with respect to its
 * anchors.
 *
 * If you pass 0 for either value, the compositor will assign it and
 * inform you of the assignment in the configure event. You must set your
 * anchor to opposite edges in the dimensions you omit; not doing so is a
 * protocol error. Both values are 0 by default.
 *
 * Size is double-buffered, see wl_surface.commit.
 */
#[inline]
unsafe extern "C" fn zwlr_layer_surface_v1_set_size(mut zwlr_layer_surface_v1:
                                                        *mut zwlr_layer_surface_v1,
                                                    mut width_0: uint32_t,
                                                    mut height_0: uint32_t) {
    wl_proxy_marshal(zwlr_layer_surface_v1 as *mut wl_proxy, 0i32 as uint32_t,
                     width_0, height_0);
}
/* *
 * @ingroup iface_zwlr_layer_surface_v1
 *
 * Requests that the compositor anchor the surface to the specified edges
 * and corners. If two orthogonal edges are specified (e.g. 'top' and
 * 'left'), then the anchor point will be the intersection of the edges
 * (e.g. the top left corner of the output); otherwise the anchor point
 * will be centered on that edge, or in the center if none is specified.
 *
 * Anchor is double-buffered, see wl_surface.commit.
 */
#[inline]
unsafe extern "C" fn zwlr_layer_surface_v1_set_anchor(mut zwlr_layer_surface_v1:
                                                          *mut zwlr_layer_surface_v1,
                                                      mut anchor_0:
                                                          uint32_t) {
    wl_proxy_marshal(zwlr_layer_surface_v1 as *mut wl_proxy, 1i32 as uint32_t,
                     anchor_0);
}
/* *
 * @ingroup iface_zwlr_layer_surface_v1
 *
 * Requests that the compositor avoids occluding an area with other
 * surfaces. The compositor's use of this information is
 * implementation-dependent - do not assume that this region will not
 * actually be occluded.
 *
 * A positive value is only meaningful if the surface is anchored to one
 * edge or an edge and both perpendicular edges. If the surface is not
 * anchored, anchored to only two perpendicular edges (a corner), anchored
 * to only two parallel edges or anchored to all edges, a positive value
 * will be treated the same as zero.
 *
 * A positive zone is the distance from the edge in surface-local
 * coordinates to consider exclusive.
 *
 * Surfaces that do not wish to have an exclusive zone may instead specify
 * how they should interact with surfaces that do. If set to zero, the
 * surface indicates that it would like to be moved to avoid occluding
 * surfaces with a positive exclusive zone. If set to -1, the surface
 * indicates that it would not like to be moved to accommodate for other
 * surfaces, and the compositor should extend it all the way to the edges
 * it is anchored to.
 *
 * For example, a panel might set its exclusive zone to 10, so that
 * maximized shell surfaces are not shown on top of it. A notification
 * might set its exclusive zone to 0, so that it is moved to avoid
 * occluding the panel, but shell surfaces are shown underneath it. A
 * wallpaper or lock screen might set their exclusive zone to -1, so that
 * they stretch below or over the panel.
 *
 * The default value is 0.
 *
 * Exclusive zone is double-buffered, see wl_surface.commit.
 */
#[inline]
unsafe extern "C" fn zwlr_layer_surface_v1_set_exclusive_zone(mut zwlr_layer_surface_v1:
                                                                  *mut zwlr_layer_surface_v1,
                                                              mut zone:
                                                                  int32_t) {
    wl_proxy_marshal(zwlr_layer_surface_v1 as *mut wl_proxy, 2i32 as uint32_t,
                     zone);
}
/* *
 * @ingroup iface_zwlr_layer_surface_v1
 *
 * Requests that the surface be placed some distance away from the anchor
 * point on the output, in surface-local coordinates. Setting this value
 * for edges you are not anchored to has no effect.
 *
 * The exclusive zone includes the margin.
 *
 * Margin is double-buffered, see wl_surface.commit.
 */
#[inline]
unsafe extern "C" fn zwlr_layer_surface_v1_set_margin(mut zwlr_layer_surface_v1:
                                                          *mut zwlr_layer_surface_v1,
                                                      mut top: int32_t,
                                                      mut right: int32_t,
                                                      mut bottom: int32_t,
                                                      mut left: int32_t) {
    wl_proxy_marshal(zwlr_layer_surface_v1 as *mut wl_proxy, 3i32 as uint32_t,
                     top, right, bottom, left);
}
/* *
 * @ingroup iface_zwlr_layer_surface_v1
 *
 * Set to 1 to request that the seat send keyboard events to this layer
 * surface. For layers below the shell surface layer, the seat will use
 * normal focus semantics. For layers above the shell surface layers, the
 * seat will always give exclusive keyboard focus to the top-most layer
 * which has keyboard interactivity set to true.
 *
 * Layer surfaces receive pointer, touch, and tablet events normally. If
 * you do not want to receive them, set the input region on your surface
 * to an empty region.
 *
 * Events is double-buffered, see wl_surface.commit.
 */
#[inline]
unsafe extern "C" fn zwlr_layer_surface_v1_set_keyboard_interactivity(mut zwlr_layer_surface_v1:
                                                                          *mut zwlr_layer_surface_v1,
                                                                      mut keyboard_interactivity:
                                                                          uint32_t) {
    wl_proxy_marshal(zwlr_layer_surface_v1 as *mut wl_proxy, 4i32 as uint32_t,
                     keyboard_interactivity);
}
/* *
 * @ingroup iface_zwlr_layer_surface_v1
 *
 * This assigns an xdg_popup's parent to this layer_surface.  This popup
 * should have been created via xdg_surface::get_popup with the parent set
 * to NULL, and this request must be invoked before committing the popup's
 * initial state.
 *
 * See the documentation of xdg_popup for more details about what an
 * xdg_popup is and how it is used.
 */
#[inline]
unsafe extern "C" fn zwlr_layer_surface_v1_get_popup(mut zwlr_layer_surface_v1:
                                                         *mut zwlr_layer_surface_v1,
                                                     mut popup_0:
                                                         *mut xdg_popup) {
    wl_proxy_marshal(zwlr_layer_surface_v1 as *mut wl_proxy, 5i32 as uint32_t,
                     popup_0);
}
/* *
 * @ingroup iface_zwlr_layer_surface_v1
 *
 * When a configure event is received, if a client commits the
 * surface in response to the configure event, then the client
 * must make an ack_configure request sometime before the commit
 * request, passing along the serial of the configure event.
 *
 * If the client receives multiple configure events before it
 * can respond to one, it only has to ack the last configure event.
 *
 * A client is not required to commit immediately after sending
 * an ack_configure request - it may even ack_configure several times
 * before its next surface commit.
 *
 * A client may send multiple ack_configure requests before committing, but
 * only the last request sent before a commit indicates which configure
 * event the client really is responding to.
 */
#[inline]
unsafe extern "C" fn zwlr_layer_surface_v1_ack_configure(mut zwlr_layer_surface_v1:
                                                             *mut zwlr_layer_surface_v1,
                                                         mut serial:
                                                             uint32_t) {
    wl_proxy_marshal(zwlr_layer_surface_v1 as *mut wl_proxy, 6i32 as uint32_t,
                     serial);
}
/* *
 * @ingroup iface_zwlr_layer_surface_v1
 *
 * This request destroys the layer surface.
 */
#[inline]
unsafe extern "C" fn zwlr_layer_surface_v1_destroy(mut zwlr_layer_surface_v1:
                                                       *mut zwlr_layer_surface_v1) {
    wl_proxy_marshal(zwlr_layer_surface_v1 as *mut wl_proxy,
                     7i32 as uint32_t);
    wl_proxy_destroy(zwlr_layer_surface_v1 as *mut wl_proxy);
}
/* *
 * @ingroup iface_xdg_wm_base
 *
 * Create a positioner object. A positioner object is used to position
 * surfaces relative to some parent surface. See the interface description
 * and xdg_surface.get_popup for details.
 */
#[inline]
unsafe extern "C" fn xdg_wm_base_create_positioner(mut xdg_wm_base_0:
                                                       *mut xdg_wm_base)
 -> *mut xdg_positioner {
    let mut id: *mut wl_proxy = 0 as *mut wl_proxy;
    id =
        wl_proxy_marshal_constructor(xdg_wm_base_0 as *mut wl_proxy,
                                     1i32 as uint32_t,
                                     &xdg_positioner_interface as
                                         *const wl_interface,
                                     0 as *mut libc::c_void);
    return id as *mut xdg_positioner;
}
/* *
 * @ingroup iface_xdg_wm_base
 *
 * This creates an xdg_surface for the given surface. While xdg_surface
 * itself is not a role, the corresponding surface may only be assigned
 * a role extending xdg_surface, such as xdg_toplevel or xdg_popup.
 *
 * This creates an xdg_surface for the given surface. An xdg_surface is
 * used as basis to define a role to a given surface, such as xdg_toplevel
 * or xdg_popup. It also manages functionality shared between xdg_surface
 * based surface roles.
 *
 * See the documentation of xdg_surface for more details about what an
 * xdg_surface is and how it is used.
 */
#[inline]
unsafe extern "C" fn xdg_wm_base_get_xdg_surface(mut xdg_wm_base_0:
                                                     *mut xdg_wm_base,
                                                 mut surface: *mut wl_surface)
 -> *mut xdg_surface {
    let mut id: *mut wl_proxy = 0 as *mut wl_proxy;
    id =
        wl_proxy_marshal_constructor(xdg_wm_base_0 as *mut wl_proxy,
                                     2i32 as uint32_t,
                                     &xdg_surface_interface as
                                         *const wl_interface,
                                     0 as *mut libc::c_void, surface);
    return id as *mut xdg_surface;
}
/* *
 * @ingroup iface_xdg_positioner
 *
 * Notify the compositor that the xdg_positioner will no longer be used.
 */
#[inline]
unsafe extern "C" fn xdg_positioner_destroy(mut xdg_positioner:
                                                *mut xdg_positioner) {
    wl_proxy_marshal(xdg_positioner as *mut wl_proxy, 0i32 as uint32_t);
    wl_proxy_destroy(xdg_positioner as *mut wl_proxy);
}
/* *
 * @ingroup iface_xdg_positioner
 *
 * Set the size of the surface that is to be positioned with the positioner
 * object. The size is in surface-local coordinates and corresponds to the
 * window geometry. See xdg_surface.set_window_geometry.
 *
 * If a zero or negative size is set the invalid_input error is raised.
 */
#[inline]
unsafe extern "C" fn xdg_positioner_set_size(mut xdg_positioner:
                                                 *mut xdg_positioner,
                                             mut width_0: int32_t,
                                             mut height_0: int32_t) {
    wl_proxy_marshal(xdg_positioner as *mut wl_proxy, 1i32 as uint32_t,
                     width_0, height_0);
}
/* *
 * @ingroup iface_xdg_positioner
 *
 * Specify the anchor rectangle within the parent surface that the child
 * surface will be placed relative to. The rectangle is relative to the
 * window geometry as defined by xdg_surface.set_window_geometry of the
 * parent surface.
 *
 * When the xdg_positioner object is used to position a child surface, the
 * anchor rectangle may not extend outside the window geometry of the
 * positioned child's parent surface.
 *
 * If a negative size is set the invalid_input error is raised.
 */
#[inline]
unsafe extern "C" fn xdg_positioner_set_anchor_rect(mut xdg_positioner:
                                                        *mut xdg_positioner,
                                                    mut x: int32_t,
                                                    mut y: int32_t,
                                                    mut width_0: int32_t,
                                                    mut height_0: int32_t) {
    wl_proxy_marshal(xdg_positioner as *mut wl_proxy, 2i32 as uint32_t, x, y,
                     width_0, height_0);
}
/* *
 * @ingroup iface_xdg_positioner
 *
 * Defines the anchor point for the anchor rectangle. The specified anchor
 * is used derive an anchor point that the child surface will be
 * positioned relative to. If a corner anchor is set (e.g. 'top_left' or
 * 'bottom_right'), the anchor point will be at the specified corner;
 * otherwise, the derived anchor point will be centered on the specified
 * edge, or in the center of the anchor rectangle if no edge is specified.
 */
#[inline]
unsafe extern "C" fn xdg_positioner_set_anchor(mut xdg_positioner:
                                                   *mut xdg_positioner,
                                               mut anchor_0: uint32_t) {
    wl_proxy_marshal(xdg_positioner as *mut wl_proxy, 3i32 as uint32_t,
                     anchor_0);
}
/* *
 * @ingroup iface_xdg_positioner
 *
 * Specify the surface position offset relative to the position of the
 * anchor on the anchor rectangle and the anchor on the surface. For
 * example if the anchor of the anchor rectangle is at (x, y), the surface
 * has the gravity bottom|right, and the offset is (ox, oy), the calculated
 * surface position will be (x + ox, y + oy). The offset position of the
 * surface is the one used for constraint testing. See
 * set_constraint_adjustment.
 *
 * An example use case is placing a popup menu on top of a user interface
 * element, while aligning the user interface element of the parent surface
 * with some user interface element placed somewhere in the popup surface.
 */
#[inline]
unsafe extern "C" fn xdg_positioner_set_offset(mut xdg_positioner:
                                                   *mut xdg_positioner,
                                               mut x: int32_t,
                                               mut y: int32_t) {
    wl_proxy_marshal(xdg_positioner as *mut wl_proxy, 6i32 as uint32_t, x, y);
}
/* *
 * @ingroup iface_xdg_surface
 */
#[inline]
unsafe extern "C" fn xdg_surface_add_listener(mut xdg_surface:
                                                  *mut xdg_surface,
                                              mut listener:
                                                  *const xdg_surface_listener,
                                              mut data: *mut libc::c_void)
 -> libc::c_int {
    return wl_proxy_add_listener(xdg_surface as *mut wl_proxy,
                                 listener as
                                     *mut Option<unsafe extern "C" fn()
                                                     -> ()>, data);
}
/* *
 * @ingroup iface_xdg_surface
 *
 * This creates an xdg_popup object for the given xdg_surface and gives
 * the associated wl_surface the xdg_popup role.
 *
 * If null is passed as a parent, a parent surface must be specified using
 * some other protocol, before committing the initial state.
 *
 * See the documentation of xdg_popup for more details about what an
 * xdg_popup is and how it is used.
 */
#[inline]
unsafe extern "C" fn xdg_surface_get_popup(mut xdg_surface: *mut xdg_surface,
                                           mut parent: *mut xdg_surface,
                                           mut positioner:
                                               *mut xdg_positioner)
 -> *mut xdg_popup {
    let mut id: *mut wl_proxy = 0 as *mut wl_proxy;
    id =
        wl_proxy_marshal_constructor(xdg_surface as *mut wl_proxy,
                                     2i32 as uint32_t,
                                     &xdg_popup_interface as
                                         *const wl_interface,
                                     0 as *mut libc::c_void, parent,
                                     positioner);
    return id as *mut xdg_popup;
}
/* *
 * @ingroup iface_xdg_surface
 *
 * When a configure event is received, if a client commits the
 * surface in response to the configure event, then the client
 * must make an ack_configure request sometime before the commit
 * request, passing along the serial of the configure event.
 *
 * For instance, for toplevel surfaces the compositor might use this
 * information to move a surface to the top left only when the client has
 * drawn itself for the maximized or fullscreen state.
 *
 * If the client receives multiple configure events before it
 * can respond to one, it only has to ack the last configure event.
 *
 * A client is not required to commit immediately after sending
 * an ack_configure request - it may even ack_configure several times
 * before its next surface commit.
 *
 * A client may send multiple ack_configure requests before committing, but
 * only the last request sent before a commit indicates which configure
 * event the client really is responding to.
 */
#[inline]
unsafe extern "C" fn xdg_surface_ack_configure(mut xdg_surface:
                                                   *mut xdg_surface,
                                               mut serial: uint32_t) {
    wl_proxy_marshal(xdg_surface as *mut wl_proxy, 4i32 as uint32_t, serial);
}
/* *
 * @ingroup iface_xdg_popup
 */
#[inline]
unsafe extern "C" fn xdg_popup_add_listener(mut xdg_popup: *mut xdg_popup,
                                            mut listener:
                                                *const xdg_popup_listener,
                                            mut data: *mut libc::c_void)
 -> libc::c_int {
    return wl_proxy_add_listener(xdg_popup as *mut wl_proxy,
                                 listener as
                                     *mut Option<unsafe extern "C" fn()
                                                     -> ()>, data);
}
/* *
 * @ingroup iface_xdg_popup
 *
 * This destroys the popup. Explicitly destroying the xdg_popup
 * object will also dismiss the popup, and unmap the surface.
 *
 * If this xdg_popup is not the "topmost" popup, a protocol error
 * will be sent.
 */
#[inline]
unsafe extern "C" fn xdg_popup_destroy(mut xdg_popup: *mut xdg_popup) {
    wl_proxy_marshal(xdg_popup as *mut wl_proxy, 0i32 as uint32_t);
    wl_proxy_destroy(xdg_popup as *mut wl_proxy);
}
/* *
 * @ingroup iface_xdg_popup
 *
 * This request makes the created popup take an explicit grab. An explicit
 * grab will be dismissed when the user dismisses the popup, or when the
 * client destroys the xdg_popup. This can be done by the user clicking
 * outside the surface, using the keyboard, or even locking the screen
 * through closing the lid or a timeout.
 *
 * If the compositor denies the grab, the popup will be immediately
 * dismissed.
 *
 * This request must be used in response to some sort of user action like a
 * button press, key press, or touch down event. The serial number of the
 * event should be passed as 'serial'.
 *
 * The parent of a grabbing popup must either be an xdg_toplevel surface or
 * another xdg_popup with an explicit grab. If the parent is another
 * xdg_popup it means that the popups are nested, with this popup now being
 * the topmost popup.
 *
 * Nested popups must be destroyed in the reverse order they were created
 * in, e.g. the only popup you are allowed to destroy at all times is the
 * topmost one.
 *
 * When compositors choose to dismiss a popup, they may dismiss every
 * nested grabbing popup as well. When a compositor dismisses popups, it
 * will follow the same dismissing order as required from the client.
 *
 * The parent of a grabbing popup must either be another xdg_popup with an
 * active explicit grab, or an xdg_popup or xdg_toplevel, if there are no
 * explicit grabs already taken.
 *
 * If the topmost grabbing popup is destroyed, the grab will be returned to
 * the parent of the popup, if that parent previously had an explicit grab.
 *
 * If the parent is a grabbing popup which has already been dismissed, this
 * popup will be immediately dismissed. If the parent is a popup that did
 * not take an explicit grab, an error will be raised.
 *
 * During a popup grab, the client owning the grab will receive pointer
 * and touch events for all their surfaces as normal (similar to an
 * "owner-events" grab in X11 parlance), while the top most grabbing popup
 * will always have keyboard focus.
 */
#[inline]
unsafe extern "C" fn xdg_popup_grab(mut xdg_popup: *mut xdg_popup,
                                    mut seat_0: *mut wl_seat,
                                    mut serial: uint32_t) {
    wl_proxy_marshal(xdg_popup as *mut wl_proxy, 1i32 as uint32_t, seat_0,
                     serial);
}
static mut display: *mut wl_display =
    0 as *const wl_display as *mut wl_display;
static mut compositor: *mut wl_compositor =
    0 as *const wl_compositor as *mut wl_compositor;
static mut seat: *mut wl_seat = 0 as *const wl_seat as *mut wl_seat;
static mut shm: *mut wl_shm = 0 as *const wl_shm as *mut wl_shm;
static mut pointer: *mut wl_pointer =
    0 as *const wl_pointer as *mut wl_pointer;
static mut keyboard: *mut wl_keyboard =
    0 as *const wl_keyboard as *mut wl_keyboard;
static mut xdg_wm_base: *mut xdg_wm_base =
    0 as *const xdg_wm_base as *mut xdg_wm_base;
static mut layer_shell: *mut zwlr_layer_shell_v1 =
    0 as *const zwlr_layer_shell_v1 as *mut zwlr_layer_shell_v1;
#[no_mangle]
pub static mut layer_surface: *mut zwlr_layer_surface_v1 =
    0 as *const zwlr_layer_surface_v1 as *mut zwlr_layer_surface_v1;
static mut wl_output: *mut wl_output =
    0 as *const wl_output as *mut wl_output;
#[no_mangle]
pub static mut wl_surface: *mut wl_surface =
    0 as *const wl_surface as *mut wl_surface;
#[no_mangle]
pub static mut egl: wlr_egl =
    wlr_egl{platform: 0,
            display: 0 as *const libc::c_void as *mut libc::c_void,
            config: 0 as *const libc::c_void as *mut libc::c_void,
            context: 0 as *const libc::c_void as *mut libc::c_void,
            exts_str: 0 as *const libc::c_char,
            exts:
                C2RustUnnamed{bind_wayland_display_wl: false,
                              buffer_age_ext: false,
                              image_base_khr: false,
                              image_dma_buf_export_mesa: false,
                              image_dmabuf_import_ext: false,
                              image_dmabuf_import_modifiers_ext: false,
                              swap_buffers_with_damage_ext: false,
                              swap_buffers_with_damage_khr: false,},
            wl_display: 0 as *const wl_display as *mut wl_display,
            dmabuf_formats:
                wlr_drm_format_set{len: 0,
                                   cap: 0,
                                   formats:
                                       0 as *const *mut wlr_drm_format as
                                           *mut *mut wlr_drm_format,},};
#[no_mangle]
pub static mut egl_window: *mut wl_egl_window =
    0 as *const wl_egl_window as *mut wl_egl_window;
#[no_mangle]
pub static mut egl_surface: *mut wlr_egl_surface =
    0 as *const wlr_egl_surface as *mut wlr_egl_surface;
#[no_mangle]
pub static mut frame_callback: *mut wl_callback =
    0 as *const wl_callback as *mut wl_callback;
static mut output: uint32_t = 4294967295u32;
#[no_mangle]
pub static mut popup: *mut xdg_popup =
    0 as *const xdg_popup as *mut xdg_popup;
#[no_mangle]
pub static mut popup_wl_surface: *mut wl_surface =
    0 as *const wl_surface as *mut wl_surface;
#[no_mangle]
pub static mut popup_egl_window: *mut wl_egl_window =
    0 as *const wl_egl_window as *mut wl_egl_window;
static mut popup_width: uint32_t = 256i32 as uint32_t;
static mut popup_height: uint32_t = 256i32 as uint32_t;
#[no_mangle]
pub static mut popup_egl_surface: *mut wlr_egl_surface =
    0 as *const wlr_egl_surface as *mut wlr_egl_surface;
#[no_mangle]
pub static mut popup_frame_callback: *mut wl_callback =
    0 as *const wl_callback as *mut wl_callback;
#[no_mangle]
pub static mut popup_alpha: libc::c_float = 1.0f64 as libc::c_float;
#[no_mangle]
pub static mut popup_red: libc::c_float = 0.5f32;
static mut layer: uint32_t =
    ZWLR_LAYER_SHELL_V1_LAYER_BACKGROUND as libc::c_int as uint32_t;
static mut anchor: uint32_t = 0i32 as uint32_t;
static mut width: uint32_t = 256i32 as uint32_t;
static mut height: uint32_t = 256i32 as uint32_t;
static mut margin_top: int32_t = 0i32;
static mut alpha: libc::c_double = 1.0f64;
static mut run_display: bool = 1i32 != 0;
static mut animate: bool = 0i32 != 0;
static mut keyboard_interactive: bool = 0i32 != 0;
static mut frame: libc::c_double = 0i32 as libc::c_double;
static mut cur_x: libc::c_int = -1i32;
static mut cur_y: libc::c_int = -1i32;
static mut buttons: libc::c_int = 0i32;
#[no_mangle]
pub static mut cursor_image: *mut wl_cursor_image =
    0 as *const wl_cursor_image as *mut wl_cursor_image;
#[no_mangle]
pub static mut popup_cursor_image: *mut wl_cursor_image =
    0 as *const wl_cursor_image as *mut wl_cursor_image;
#[no_mangle]
pub static mut cursor_surface: *mut wl_surface =
    0 as *const wl_surface as *mut wl_surface;
#[no_mangle]
pub static mut input_surface: *mut wl_surface =
    0 as *const wl_surface as *mut wl_surface;
static mut demo: C2RustUnnamed_0 =
    C2RustUnnamed_0{last_frame: timespec{tv_sec: 0, tv_nsec: 0,},
                    color: [0.; 3],
                    dec: 0,};
unsafe extern "C" fn surface_frame_callback(mut data: *mut libc::c_void,
                                            mut cb: *mut wl_callback,
                                            mut time: uint32_t) {
    wl_callback_destroy(cb);
    frame_callback = 0 as *mut wl_callback;
    draw();
}
static mut frame_listener: wl_callback_listener =
    unsafe {
        {
            let mut init =
                wl_callback_listener{done:
                                         Some(surface_frame_callback as
                                                  unsafe extern "C" fn(_:
                                                                           *mut libc::c_void,
                                                                       _:
                                                                           *mut wl_callback,
                                                                       _:
                                                                           uint32_t)
                                                      -> ()),};
            init
        }
    };
unsafe extern "C" fn popup_surface_frame_callback(mut data: *mut libc::c_void,
                                                  mut cb: *mut wl_callback,
                                                  mut time: uint32_t) {
    wl_callback_destroy(cb);
    popup_frame_callback = 0 as *mut wl_callback;
    if !popup.is_null() { draw_popup(); };
}
static mut popup_frame_listener: wl_callback_listener =
    unsafe {
        {
            let mut init =
                wl_callback_listener{done:
                                         Some(popup_surface_frame_callback as
                                                  unsafe extern "C" fn(_:
                                                                           *mut libc::c_void,
                                                                       _:
                                                                           *mut wl_callback,
                                                                       _:
                                                                           uint32_t)
                                                      -> ()),};
            init
        }
    };
unsafe extern "C" fn draw() {
    eglMakeCurrent(egl.display, egl_surface as EGLSurface,
                   egl_surface as EGLSurface, egl.context);
    let mut ts: timespec = timespec{tv_sec: 0, tv_nsec: 0,};
    clock_gettime(1i32, &mut ts);
    let mut ms: libc::c_long =
        (ts.tv_sec - demo.last_frame.tv_sec) * 1000i32 as libc::c_long +
            (ts.tv_nsec - demo.last_frame.tv_nsec) /
                1000000i32 as libc::c_long;
    let mut inc: libc::c_int = (demo.dec + 1i32) % 3i32;
    if buttons == 0 {
        demo.color[inc as usize] += ms as libc::c_float / 2000.0f32;
        demo.color[demo.dec as usize] -= ms as libc::c_float / 2000.0f32;
        if demo.color[demo.dec as usize] < 0.0f32 {
            demo.color[inc as usize] = 1.0f32;
            demo.color[demo.dec as usize] = 0.0f32;
            demo.dec = inc
        }
    }
    if animate {
        frame += ms as libc::c_double / 50.0f64;
        let mut old_top: int32_t = margin_top;
        margin_top = -(20i32 - frame as libc::c_int % 20i32);
        if old_top != margin_top {
            zwlr_layer_surface_v1_set_margin(layer_surface, margin_top, 0i32,
                                             0i32, 0i32);
            wl_surface_commit(wl_surface);
        }
    }
    glViewport(0i32, 0i32, width as GLsizei, height as GLsizei);
    if buttons != 0 {
        glClearColor(1i32 as GLfloat, 1i32 as GLfloat, 1i32 as GLfloat,
                     alpha as GLfloat);
    } else {
        glClearColor(demo.color[0], demo.color[1], demo.color[2],
                     alpha as GLfloat);
    }
    glClear(0x4000i32 as GLbitfield);
    if cur_x != -1i32 && cur_y != -1i32 {
        glEnable(0xc11i32 as GLenum);
        glScissor(cur_x, height.wrapping_sub(cur_y as libc::c_uint) as GLint,
                  5i32, 5i32);
        glClearColor(0i32 as GLfloat, 0i32 as GLfloat, 0i32 as GLfloat,
                     1i32 as GLfloat);
        glClear(0x4000i32 as GLbitfield);
        glDisable(0xc11i32 as GLenum);
    }
    frame_callback = wl_surface_frame(wl_surface);
    wl_callback_add_listener(frame_callback, &mut frame_listener,
                             0 as *mut libc::c_void);
    eglSwapBuffers(egl.display, egl_surface as EGLSurface);
    demo.last_frame = ts;
}
unsafe extern "C" fn draw_popup() {
    static mut alpha_mod: libc::c_float = -0.01f64 as libc::c_float;
    eglMakeCurrent(egl.display, popup_egl_surface as EGLSurface,
                   popup_egl_surface as EGLSurface, egl.context);
    glViewport(0i32, 0i32, popup_width as GLsizei, popup_height as GLsizei);
    glClearColor(popup_red, 0.5f32, 0.5f32, popup_alpha);
    popup_alpha += alpha_mod;
    if (popup_alpha as libc::c_double) < 0.01f64 || popup_alpha >= 1.0f32 {
        alpha_mod = (alpha_mod as libc::c_double * -1.0f64) as libc::c_float
    }
    glClear(0x4000i32 as GLbitfield);
    popup_frame_callback = wl_surface_frame(popup_wl_surface);
    if !popup_frame_callback.is_null() {
    } else {
        __assert_fail(b"popup_frame_callback\x00" as *const u8 as
                          *const libc::c_char,
                      b"../examples/layer-shell.c\x00" as *const u8 as
                          *const libc::c_char, 163i32 as libc::c_uint,
                      (*::std::mem::transmute::<&[u8; 22],
                                                &[libc::c_char; 22]>(b"void draw_popup(void)\x00")).as_ptr());
    };
    wl_callback_add_listener(popup_frame_callback, &mut popup_frame_listener,
                             0 as *mut libc::c_void);
    eglSwapBuffers(egl.display, popup_egl_surface as EGLSurface);
    wl_surface_commit(popup_wl_surface);
}
unsafe extern "C" fn xdg_surface_handle_configure(mut data: *mut libc::c_void,
                                                  mut xdg_surface:
                                                      *mut xdg_surface,
                                                  mut serial: uint32_t) {
    xdg_surface_ack_configure(xdg_surface, serial);
}
static mut xdg_surface_listener: xdg_surface_listener =
    unsafe {
        {
            let mut init =
                xdg_surface_listener{configure:
                                         Some(xdg_surface_handle_configure as
                                                  unsafe extern "C" fn(_:
                                                                           *mut libc::c_void,
                                                                       _:
                                                                           *mut xdg_surface,
                                                                       _:
                                                                           uint32_t)
                                                      -> ()),};
            init
        }
    };
unsafe extern "C" fn xdg_popup_configure(mut data: *mut libc::c_void,
                                         mut xdg_popup: *mut xdg_popup,
                                         mut x: int32_t, mut y: int32_t,
                                         mut width_0: int32_t,
                                         mut height_0: int32_t) {
    _wlr_log(WLR_DEBUG,
             b"[%s:%d] Popup configured %dx%d@%d,%d\x00" as *const u8 as
                 *const libc::c_char,
             b"../examples/layer-shell.c\x00" as *const u8 as
                 *const libc::c_char, 181i32, width_0, height_0, x, y);
    popup_width = width_0 as uint32_t;
    popup_height = height_0 as uint32_t;
    if !popup_egl_window.is_null() {
        wl_egl_window_resize(popup_egl_window, width_0, height_0, 0i32, 0i32);
    };
}
unsafe extern "C" fn popup_destroy() {
    wlr_egl_destroy_surface(&mut egl, popup_egl_surface as EGLSurface);
    wl_egl_window_destroy(popup_egl_window);
    xdg_popup_destroy(popup);
    wl_surface_destroy(popup_wl_surface);
    popup_wl_surface = 0 as *mut wl_surface;
    popup = 0 as *mut xdg_popup;
    popup_egl_window = 0 as *mut wl_egl_window;
}
unsafe extern "C" fn xdg_popup_done(mut data: *mut libc::c_void,
                                    mut xdg_popup: *mut xdg_popup) {
    _wlr_log(WLR_DEBUG,
             b"[%s:%d] Popup done\x00" as *const u8 as *const libc::c_char,
             b"../examples/layer-shell.c\x00" as *const u8 as
                 *const libc::c_char, 200i32);
    popup_destroy();
}
static mut xdg_popup_listener: xdg_popup_listener =
    unsafe {
        {
            let mut init =
                xdg_popup_listener{configure:
                                       Some(xdg_popup_configure as
                                                unsafe extern "C" fn(_:
                                                                         *mut libc::c_void,
                                                                     _:
                                                                         *mut xdg_popup,
                                                                     _:
                                                                         int32_t,
                                                                     _:
                                                                         int32_t,
                                                                     _:
                                                                         int32_t,
                                                                     _:
                                                                         int32_t)
                                                    -> ()),
                                   popup_done:
                                       Some(xdg_popup_done as
                                                unsafe extern "C" fn(_:
                                                                         *mut libc::c_void,
                                                                     _:
                                                                         *mut xdg_popup)
                                                    -> ()),};
            init
        }
    };
unsafe extern "C" fn create_popup(mut serial: uint32_t) {
    if !popup.is_null() { return }
    let mut surface: *mut wl_surface =
        wl_compositor_create_surface(compositor);
    if !xdg_wm_base.is_null() && !surface.is_null() {
    } else {
        __assert_fail(b"xdg_wm_base && surface\x00" as *const u8 as
                          *const libc::c_char,
                      b"../examples/layer-shell.c\x00" as *const u8 as
                          *const libc::c_char, 214i32 as libc::c_uint,
                      (*::std::mem::transmute::<&[u8; 28],
                                                &[libc::c_char; 28]>(b"void create_popup(uint32_t)\x00")).as_ptr());
    };
    let mut xdg_surface: *mut xdg_surface =
        xdg_wm_base_get_xdg_surface(xdg_wm_base, surface);
    let mut xdg_positioner: *mut xdg_positioner =
        xdg_wm_base_create_positioner(xdg_wm_base);
    if !xdg_surface.is_null() && !xdg_positioner.is_null() {
    } else {
        __assert_fail(b"xdg_surface && xdg_positioner\x00" as *const u8 as
                          *const libc::c_char,
                      b"../examples/layer-shell.c\x00" as *const u8 as
                          *const libc::c_char, 219i32 as libc::c_uint,
                      (*::std::mem::transmute::<&[u8; 28],
                                                &[libc::c_char; 28]>(b"void create_popup(uint32_t)\x00")).as_ptr());
    };
    xdg_positioner_set_size(xdg_positioner, popup_width as int32_t,
                            popup_height as int32_t);
    xdg_positioner_set_offset(xdg_positioner, 0i32, 0i32);
    xdg_positioner_set_anchor_rect(xdg_positioner, cur_x, cur_y, 1i32, 1i32);
    xdg_positioner_set_anchor(xdg_positioner,
                              XDG_POSITIONER_ANCHOR_BOTTOM_RIGHT as
                                  libc::c_int as uint32_t);
    popup =
        xdg_surface_get_popup(xdg_surface, 0 as *mut xdg_surface,
                              xdg_positioner);
    xdg_popup_grab(popup, seat, serial);
    if !popup.is_null() {
    } else {
        __assert_fail(b"popup\x00" as *const u8 as *const libc::c_char,
                      b"../examples/layer-shell.c\x00" as *const u8 as
                          *const libc::c_char, 229i32 as libc::c_uint,
                      (*::std::mem::transmute::<&[u8; 28],
                                                &[libc::c_char; 28]>(b"void create_popup(uint32_t)\x00")).as_ptr());
    };
    zwlr_layer_surface_v1_get_popup(layer_surface, popup);
    xdg_surface_add_listener(xdg_surface, &xdg_surface_listener,
                             0 as *mut libc::c_void);
    xdg_popup_add_listener(popup, &xdg_popup_listener,
                           0 as *mut libc::c_void);
    wl_surface_commit(surface);
    wl_display_roundtrip(display);
    xdg_positioner_destroy(xdg_positioner);
    popup_wl_surface = surface;
    popup_egl_window =
        wl_egl_window_create(surface, popup_width as libc::c_int,
                             popup_height as libc::c_int);
    if !popup_egl_window.is_null() {
    } else {
        __assert_fail(b"popup_egl_window\x00" as *const u8 as
                          *const libc::c_char,
                      b"../examples/layer-shell.c\x00" as *const u8 as
                          *const libc::c_char, 243i32 as libc::c_uint,
                      (*::std::mem::transmute::<&[u8; 28],
                                                &[libc::c_char; 28]>(b"void create_popup(uint32_t)\x00")).as_ptr());
    };
    popup_egl_surface =
        wlr_egl_create_surface(&mut egl,
                               popup_egl_window as *mut libc::c_void) as
            *mut wlr_egl_surface;
    if !popup_egl_surface.is_null() {
    } else {
        __assert_fail(b"popup_egl_surface\x00" as *const u8 as
                          *const libc::c_char,
                      b"../examples/layer-shell.c\x00" as *const u8 as
                          *const libc::c_char, 245i32 as libc::c_uint,
                      (*::std::mem::transmute::<&[u8; 28],
                                                &[libc::c_char; 28]>(b"void create_popup(uint32_t)\x00")).as_ptr());
    };
    draw_popup();
}
unsafe extern "C" fn layer_surface_configure(mut data: *mut libc::c_void,
                                             mut surface:
                                                 *mut zwlr_layer_surface_v1,
                                             mut serial: uint32_t,
                                             mut w: uint32_t,
                                             mut h: uint32_t) {
    width = w;
    height = h;
    if !egl_window.is_null() {
        wl_egl_window_resize(egl_window, width as libc::c_int,
                             height as libc::c_int, 0i32, 0i32);
    }
    zwlr_layer_surface_v1_ack_configure(surface, serial);
}
unsafe extern "C" fn layer_surface_closed(mut data: *mut libc::c_void,
                                          mut surface:
                                              *mut zwlr_layer_surface_v1) {
    wlr_egl_destroy_surface(&mut egl, egl_surface as EGLSurface);
    wl_egl_window_destroy(egl_window);
    zwlr_layer_surface_v1_destroy(surface);
    wl_surface_destroy(wl_surface);
    run_display = 0i32 != 0;
}
#[no_mangle]
pub static mut layer_surface_listener: zwlr_layer_surface_v1_listener =
    unsafe {
        {
            let mut init =
                zwlr_layer_surface_v1_listener{configure:
                                                   Some(layer_surface_configure
                                                            as
                                                            unsafe extern "C" fn(_:
                                                                                     *mut libc::c_void,
                                                                                 _:
                                                                                     *mut zwlr_layer_surface_v1,
                                                                                 _:
                                                                                     uint32_t,
                                                                                 _:
                                                                                     uint32_t,
                                                                                 _:
                                                                                     uint32_t)
                                                                -> ()),
                                               closed:
                                                   Some(layer_surface_closed
                                                            as
                                                            unsafe extern "C" fn(_:
                                                                                     *mut libc::c_void,
                                                                                 _:
                                                                                     *mut zwlr_layer_surface_v1)
                                                                -> ()),};
            init
        }
    };
unsafe extern "C" fn wl_pointer_enter(mut data: *mut libc::c_void,
                                      mut wl_pointer: *mut wl_pointer,
                                      mut serial: uint32_t,
                                      mut surface: *mut wl_surface,
                                      mut surface_x: wl_fixed_t,
                                      mut surface_y: wl_fixed_t) {
    let mut image: *mut wl_cursor_image = 0 as *mut wl_cursor_image;
    if surface == popup_wl_surface {
        image = popup_cursor_image
    } else { image = cursor_image }
    wl_surface_attach(cursor_surface, wl_cursor_image_get_buffer(image), 0i32,
                      0i32);
    wl_surface_damage(cursor_surface, 1i32, 0i32, (*image).width as int32_t,
                      (*image).height as int32_t);
    wl_surface_commit(cursor_surface);
    wl_pointer_set_cursor(wl_pointer, serial, cursor_surface,
                          (*image).hotspot_x as int32_t,
                          (*image).hotspot_y as int32_t);
    input_surface = surface;
}
unsafe extern "C" fn wl_pointer_leave(mut data: *mut libc::c_void,
                                      mut wl_pointer: *mut wl_pointer,
                                      mut serial: uint32_t,
                                      mut surface: *mut wl_surface) {
    cur_y = -1i32;
    cur_x = cur_y;
    buttons = 0i32;
}
unsafe extern "C" fn wl_pointer_motion(mut data: *mut libc::c_void,
                                       mut wl_pointer: *mut wl_pointer,
                                       mut time: uint32_t,
                                       mut surface_x: wl_fixed_t,
                                       mut surface_y: wl_fixed_t) {
    cur_x = wl_fixed_to_int(surface_x);
    cur_y = wl_fixed_to_int(surface_y);
}
unsafe extern "C" fn wl_pointer_button(mut data: *mut libc::c_void,
                                       mut wl_pointer: *mut wl_pointer,
                                       mut serial: uint32_t,
                                       mut time: uint32_t,
                                       mut button: uint32_t,
                                       mut state: uint32_t) {
    if input_surface == wl_surface {
        if state ==
               WL_POINTER_BUTTON_STATE_PRESSED as libc::c_int as libc::c_uint
           {
            if button == 0x111i32 as libc::c_uint {
                if !popup_wl_surface.is_null() {
                    popup_destroy();
                } else { create_popup(serial); }
            } else { buttons += 1 }
        } else if button != 0x111i32 as libc::c_uint { buttons -= 1 }
    } else if input_surface == popup_wl_surface {
        if state ==
               WL_POINTER_BUTTON_STATE_PRESSED as libc::c_int as libc::c_uint
           {
            if button == 0x110i32 as libc::c_uint && popup_red <= 0.9f32 {
                popup_red =
                    (popup_red as libc::c_double + 0.1f64) as libc::c_float
            } else if button == 0x111i32 as libc::c_uint &&
                          popup_red >= 0.1f32 {
                popup_red =
                    (popup_red as libc::c_double - 0.1f64) as libc::c_float
            }
        }
    } else {
        if 0i32 != 0 &&
               !(b"Unknown surface\x00" as *const u8 as
                     *const libc::c_char).is_null() {
        } else {
            __assert_fail(b"false && \"Unknown surface\"\x00" as *const u8 as
                              *const libc::c_char,
                          b"../examples/layer-shell.c\x00" as *const u8 as
                              *const libc::c_char, 332i32 as libc::c_uint,
                          (*::std::mem::transmute::<&[u8; 92],
                                                    &[libc::c_char; 92]>(b"void wl_pointer_button(void *, struct wl_pointer *, uint32_t, uint32_t, uint32_t, uint32_t)\x00")).as_ptr());
        };
    };
}
unsafe extern "C" fn wl_pointer_axis(mut data: *mut libc::c_void,
                                     mut wl_pointer: *mut wl_pointer,
                                     mut time: uint32_t, mut axis: uint32_t,
                                     mut value: wl_fixed_t) {
    // Who cares
}
unsafe extern "C" fn wl_pointer_frame(mut data: *mut libc::c_void,
                                      mut wl_pointer: *mut wl_pointer) {
    // Who cares
}
unsafe extern "C" fn wl_pointer_axis_source(mut data: *mut libc::c_void,
                                            mut wl_pointer: *mut wl_pointer,
                                            mut axis_source: uint32_t) {
    // Who cares
}
unsafe extern "C" fn wl_pointer_axis_stop(mut data: *mut libc::c_void,
                                          mut wl_pointer: *mut wl_pointer,
                                          mut time: uint32_t,
                                          mut axis: uint32_t) {
    // Who cares
}
unsafe extern "C" fn wl_pointer_axis_discrete(mut data: *mut libc::c_void,
                                              mut wl_pointer: *mut wl_pointer,
                                              mut axis: uint32_t,
                                              mut discrete: int32_t) {
    // Who cares
}
#[no_mangle]
pub static mut pointer_listener: wl_pointer_listener =
    unsafe {
        {
            let mut init =
                wl_pointer_listener{enter:
                                        Some(wl_pointer_enter as
                                                 unsafe extern "C" fn(_:
                                                                          *mut libc::c_void,
                                                                      _:
                                                                          *mut wl_pointer,
                                                                      _:
                                                                          uint32_t,
                                                                      _:
                                                                          *mut wl_surface,
                                                                      _:
                                                                          wl_fixed_t,
                                                                      _:
                                                                          wl_fixed_t)
                                                     -> ()),
                                    leave:
                                        Some(wl_pointer_leave as
                                                 unsafe extern "C" fn(_:
                                                                          *mut libc::c_void,
                                                                      _:
                                                                          *mut wl_pointer,
                                                                      _:
                                                                          uint32_t,
                                                                      _:
                                                                          *mut wl_surface)
                                                     -> ()),
                                    motion:
                                        Some(wl_pointer_motion as
                                                 unsafe extern "C" fn(_:
                                                                          *mut libc::c_void,
                                                                      _:
                                                                          *mut wl_pointer,
                                                                      _:
                                                                          uint32_t,
                                                                      _:
                                                                          wl_fixed_t,
                                                                      _:
                                                                          wl_fixed_t)
                                                     -> ()),
                                    button:
                                        Some(wl_pointer_button as
                                                 unsafe extern "C" fn(_:
                                                                          *mut libc::c_void,
                                                                      _:
                                                                          *mut wl_pointer,
                                                                      _:
                                                                          uint32_t,
                                                                      _:
                                                                          uint32_t,
                                                                      _:
                                                                          uint32_t,
                                                                      _:
                                                                          uint32_t)
                                                     -> ()),
                                    axis:
                                        Some(wl_pointer_axis as
                                                 unsafe extern "C" fn(_:
                                                                          *mut libc::c_void,
                                                                      _:
                                                                          *mut wl_pointer,
                                                                      _:
                                                                          uint32_t,
                                                                      _:
                                                                          uint32_t,
                                                                      _:
                                                                          wl_fixed_t)
                                                     -> ()),
                                    frame:
                                        Some(wl_pointer_frame as
                                                 unsafe extern "C" fn(_:
                                                                          *mut libc::c_void,
                                                                      _:
                                                                          *mut wl_pointer)
                                                     -> ()),
                                    axis_source:
                                        Some(wl_pointer_axis_source as
                                                 unsafe extern "C" fn(_:
                                                                          *mut libc::c_void,
                                                                      _:
                                                                          *mut wl_pointer,
                                                                      _:
                                                                          uint32_t)
                                                     -> ()),
                                    axis_stop:
                                        Some(wl_pointer_axis_stop as
                                                 unsafe extern "C" fn(_:
                                                                          *mut libc::c_void,
                                                                      _:
                                                                          *mut wl_pointer,
                                                                      _:
                                                                          uint32_t,
                                                                      _:
                                                                          uint32_t)
                                                     -> ()),
                                    axis_discrete:
                                        Some(wl_pointer_axis_discrete as
                                                 unsafe extern "C" fn(_:
                                                                          *mut libc::c_void,
                                                                      _:
                                                                          *mut wl_pointer,
                                                                      _:
                                                                          uint32_t,
                                                                      _:
                                                                          int32_t)
                                                     -> ()),};
            init
        }
    };
unsafe extern "C" fn wl_keyboard_keymap(mut data: *mut libc::c_void,
                                        mut wl_keyboard: *mut wl_keyboard,
                                        mut format: uint32_t, mut fd: int32_t,
                                        mut size: uint32_t) {
    // Who cares
}
unsafe extern "C" fn wl_keyboard_enter(mut data: *mut libc::c_void,
                                       mut wl_keyboard: *mut wl_keyboard,
                                       mut serial: uint32_t,
                                       mut surface: *mut wl_surface,
                                       mut keys: *mut wl_array) {
    _wlr_log(WLR_DEBUG,
             b"[%s:%d] Keyboard enter\x00" as *const u8 as
                 *const libc::c_char,
             b"../examples/layer-shell.c\x00" as *const u8 as
                 *const libc::c_char, 379i32);
}
unsafe extern "C" fn wl_keyboard_leave(mut data: *mut libc::c_void,
                                       mut wl_keyboard: *mut wl_keyboard,
                                       mut serial: uint32_t,
                                       mut surface: *mut wl_surface) {
    _wlr_log(WLR_DEBUG,
             b"[%s:%d] Keyboard leave\x00" as *const u8 as
                 *const libc::c_char,
             b"../examples/layer-shell.c\x00" as *const u8 as
                 *const libc::c_char, 384i32);
}
unsafe extern "C" fn wl_keyboard_key(mut data: *mut libc::c_void,
                                     mut wl_keyboard: *mut wl_keyboard,
                                     mut serial: uint32_t, mut time: uint32_t,
                                     mut key: uint32_t, mut state: uint32_t) {
    _wlr_log(WLR_DEBUG,
             b"[%s:%d] Key event: %d %d\x00" as *const u8 as
                 *const libc::c_char,
             b"../examples/layer-shell.c\x00" as *const u8 as
                 *const libc::c_char, 389i32, key, state);
}
unsafe extern "C" fn wl_keyboard_modifiers(mut data: *mut libc::c_void,
                                           mut wl_keyboard: *mut wl_keyboard,
                                           mut serial: uint32_t,
                                           mut mods_depressed: uint32_t,
                                           mut mods_latched: uint32_t,
                                           mut mods_locked: uint32_t,
                                           mut group: uint32_t) {
    // Who cares
}
unsafe extern "C" fn wl_keyboard_repeat_info(mut data: *mut libc::c_void,
                                             mut wl_keyboard:
                                                 *mut wl_keyboard,
                                             mut rate: int32_t,
                                             mut delay: int32_t) {
    // Who cares
}
static mut keyboard_listener: wl_keyboard_listener =
    unsafe {
        {
            let mut init =
                wl_keyboard_listener{keymap:
                                         Some(wl_keyboard_keymap as
                                                  unsafe extern "C" fn(_:
                                                                           *mut libc::c_void,
                                                                       _:
                                                                           *mut wl_keyboard,
                                                                       _:
                                                                           uint32_t,
                                                                       _:
                                                                           int32_t,
                                                                       _:
                                                                           uint32_t)
                                                      -> ()),
                                     enter:
                                         Some(wl_keyboard_enter as
                                                  unsafe extern "C" fn(_:
                                                                           *mut libc::c_void,
                                                                       _:
                                                                           *mut wl_keyboard,
                                                                       _:
                                                                           uint32_t,
                                                                       _:
                                                                           *mut wl_surface,
                                                                       _:
                                                                           *mut wl_array)
                                                      -> ()),
                                     leave:
                                         Some(wl_keyboard_leave as
                                                  unsafe extern "C" fn(_:
                                                                           *mut libc::c_void,
                                                                       _:
                                                                           *mut wl_keyboard,
                                                                       _:
                                                                           uint32_t,
                                                                       _:
                                                                           *mut wl_surface)
                                                      -> ()),
                                     key:
                                         Some(wl_keyboard_key as
                                                  unsafe extern "C" fn(_:
                                                                           *mut libc::c_void,
                                                                       _:
                                                                           *mut wl_keyboard,
                                                                       _:
                                                                           uint32_t,
                                                                       _:
                                                                           uint32_t,
                                                                       _:
                                                                           uint32_t,
                                                                       _:
                                                                           uint32_t)
                                                      -> ()),
                                     modifiers:
                                         Some(wl_keyboard_modifiers as
                                                  unsafe extern "C" fn(_:
                                                                           *mut libc::c_void,
                                                                       _:
                                                                           *mut wl_keyboard,
                                                                       _:
                                                                           uint32_t,
                                                                       _:
                                                                           uint32_t,
                                                                       _:
                                                                           uint32_t,
                                                                       _:
                                                                           uint32_t,
                                                                       _:
                                                                           uint32_t)
                                                      -> ()),
                                     repeat_info:
                                         Some(wl_keyboard_repeat_info as
                                                  unsafe extern "C" fn(_:
                                                                           *mut libc::c_void,
                                                                       _:
                                                                           *mut wl_keyboard,
                                                                       _:
                                                                           int32_t,
                                                                       _:
                                                                           int32_t)
                                                      -> ()),};
            init
        }
    };
unsafe extern "C" fn seat_handle_capabilities(mut data: *mut libc::c_void,
                                              mut wl_seat: *mut wl_seat,
                                              mut caps: wl_seat_capability) {
    if caps as libc::c_uint &
           WL_SEAT_CAPABILITY_POINTER as libc::c_int as libc::c_uint != 0 {
        pointer = wl_seat_get_pointer(wl_seat);
        wl_pointer_add_listener(pointer, &mut pointer_listener,
                                0 as *mut libc::c_void);
    }
    if caps as libc::c_uint &
           WL_SEAT_CAPABILITY_KEYBOARD as libc::c_int as libc::c_uint != 0 {
        keyboard = wl_seat_get_keyboard(wl_seat);
        wl_keyboard_add_listener(keyboard, &mut keyboard_listener,
                                 0 as *mut libc::c_void);
    };
}
unsafe extern "C" fn seat_handle_name(mut data: *mut libc::c_void,
                                      mut wl_seat: *mut wl_seat,
                                      mut name: *const libc::c_char) {
    // Who cares
}
#[no_mangle]
pub static mut seat_listener: wl_seat_listener =
    unsafe {
        {
            let mut init =
                wl_seat_listener{capabilities:
                                     ::std::mem::transmute::<Option<unsafe extern "C" fn(_:
                                                                                             *mut libc::c_void,
                                                                                         _:
                                                                                             *mut wl_seat,
                                                                                         _:
                                                                                             wl_seat_capability)
                                                                        ->
                                                                            ()>,
                                                             Option<unsafe extern "C" fn(_:
                                                                                             *mut libc::c_void,
                                                                                         _:
                                                                                             *mut wl_seat,
                                                                                         _:
                                                                                             uint32_t)
                                                                        ->
                                                                            ()>>(Some(seat_handle_capabilities
                                                                                          as
                                                                                          unsafe extern "C" fn(_:
                                                                                                                   *mut libc::c_void,
                                                                                                               _:
                                                                                                                   *mut wl_seat,
                                                                                                               _:
                                                                                                                   wl_seat_capability)
                                                                                              ->
                                                                                                  ())),
                                 name:
                                     Some(seat_handle_name as
                                              unsafe extern "C" fn(_:
                                                                       *mut libc::c_void,
                                                                   _:
                                                                       *mut wl_seat,
                                                                   _:
                                                                       *const libc::c_char)
                                                  -> ()),};
            init
        }
    };
unsafe extern "C" fn handle_global(mut data: *mut libc::c_void,
                                   mut registry: *mut wl_registry,
                                   mut name: uint32_t,
                                   mut interface: *const libc::c_char,
                                   mut version: uint32_t) {
    if strcmp(interface, wl_compositor_interface.name) == 0i32 {
        compositor =
            wl_registry_bind(registry, name, &wl_compositor_interface,
                             1i32 as uint32_t) as *mut wl_compositor
    } else if strcmp(interface, wl_shm_interface.name) == 0i32 {
        shm =
            wl_registry_bind(registry, name, &wl_shm_interface,
                             1i32 as uint32_t) as *mut wl_shm
    } else if strcmp(interface,
                     b"wl_output\x00" as *const u8 as *const libc::c_char) ==
                  0i32 {
        if output != 4294967295u32 {
            if wl_output.is_null() {
                wl_output =
                    wl_registry_bind(registry, name, &wl_output_interface,
                                     1i32 as uint32_t) as *mut wl_output
            } else { output = output.wrapping_sub(1) }
        }
    } else if strcmp(interface, wl_seat_interface.name) == 0i32 {
        seat =
            wl_registry_bind(registry, name, &wl_seat_interface,
                             1i32 as uint32_t) as *mut wl_seat;
        wl_seat_add_listener(seat, &seat_listener, 0 as *mut libc::c_void);
    } else if strcmp(interface, zwlr_layer_shell_v1_interface.name) == 0i32 {
        layer_shell =
            wl_registry_bind(registry, name, &zwlr_layer_shell_v1_interface,
                             1i32 as uint32_t) as *mut zwlr_layer_shell_v1
    } else if strcmp(interface, xdg_wm_base_interface.name) == 0i32 {
        xdg_wm_base =
            wl_registry_bind(registry, name, &xdg_wm_base_interface,
                             1i32 as uint32_t) as *mut xdg_wm_base
    };
}
unsafe extern "C" fn handle_global_remove(mut data: *mut libc::c_void,
                                          mut registry: *mut wl_registry,
                                          mut name: uint32_t) {
    // who cares
}
static mut registry_listener: wl_registry_listener =
    unsafe {
        {
            let mut init =
                wl_registry_listener{global:
                                         Some(handle_global as
                                                  unsafe extern "C" fn(_:
                                                                           *mut libc::c_void,
                                                                       _:
                                                                           *mut wl_registry,
                                                                       _:
                                                                           uint32_t,
                                                                       _:
                                                                           *const libc::c_char,
                                                                       _:
                                                                           uint32_t)
                                                      -> ()),
                                     global_remove:
                                         Some(handle_global_remove as
                                                  unsafe extern "C" fn(_:
                                                                           *mut libc::c_void,
                                                                       _:
                                                                           *mut wl_registry,
                                                                       _:
                                                                           uint32_t)
                                                      -> ()),};
            init
        }
    };
unsafe fn main_0(mut argc: libc::c_int, mut argv: *mut *mut libc::c_char)
 -> libc::c_int {
    wlr_log_init(WLR_DEBUG, None);
    let mut namespace: [libc::c_char; 8] =
        *::std::mem::transmute::<&[u8; 8],
                                 &mut [libc::c_char; 8]>(b"wlroots\x00");
    let mut exclusive_zone: libc::c_int = 0i32;
    let mut margin_right: int32_t = 0i32;
    let mut margin_bottom: int32_t = 0i32;
    let mut margin_left: int32_t = 0i32;
    let mut found: bool = false;
    let mut c: libc::c_int = 0;
    loop  {
        c =
            getopt(argc, argv,
                   b"knw:h:o:l:a:x:m:t:\x00" as *const u8 as
                       *const libc::c_char);
        if !(c != -1i32) { break ; }
        match c {
            111 => { output = atoi(optarg) as uint32_t }
            119 => { width = atoi(optarg) as uint32_t }
            104 => { height = atoi(optarg) as uint32_t }
            120 => { exclusive_zone = atoi(optarg) }
            108 => {
                let mut layers: [C2RustUnnamed_2; 4] =
                    [{
                         let mut init =
                             C2RustUnnamed_2{name:
                                                 b"background\x00" as
                                                     *const u8 as
                                                     *const libc::c_char,
                                             value:
                                                 ZWLR_LAYER_SHELL_V1_LAYER_BACKGROUND,};
                         init
                     },
                     {
                         let mut init =
                             C2RustUnnamed_2{name:
                                                 b"bottom\x00" as *const u8 as
                                                     *const libc::c_char,
                                             value:
                                                 ZWLR_LAYER_SHELL_V1_LAYER_BOTTOM,};
                         init
                     },
                     {
                         let mut init =
                             C2RustUnnamed_2{name:
                                                 b"top\x00" as *const u8 as
                                                     *const libc::c_char,
                                             value:
                                                 ZWLR_LAYER_SHELL_V1_LAYER_TOP,};
                         init
                     },
                     {
                         let mut init =
                             C2RustUnnamed_2{name:
                                                 b"overlay\x00" as *const u8
                                                     as *const libc::c_char,
                                             value:
                                                 ZWLR_LAYER_SHELL_V1_LAYER_OVERLAY,};
                         init
                     }];
                found = 0i32 != 0;
                let mut i: size_t = 0i32 as size_t;
                while i <
                          (::std::mem::size_of::<[C2RustUnnamed_2; 4]>() as
                               libc::c_ulong).wrapping_div(::std::mem::size_of::<C2RustUnnamed_2>()
                                                               as
                                                               libc::c_ulong)
                      {
                    if strcmp(optarg, layers[i as usize].name) == 0i32 {
                        layer = layers[i as usize].value as uint32_t;
                        found = 1i32 != 0;
                        break ;
                    } else { i = i.wrapping_add(1) }
                }
                if !found {
                    fprintf(stderr,
                            b"invalid layer %s\n\x00" as *const u8 as
                                *const libc::c_char, optarg);
                    return 1i32
                }
            }
            97 => {
                let mut anchors: [C2RustUnnamed_1; 4] =
                    [{
                         let mut init =
                             C2RustUnnamed_1{name:
                                                 b"top\x00" as *const u8 as
                                                     *const libc::c_char,
                                             value:
                                                 ZWLR_LAYER_SURFACE_V1_ANCHOR_TOP
                                                     as libc::c_int as
                                                     uint32_t,};
                         init
                     },
                     {
                         let mut init =
                             C2RustUnnamed_1{name:
                                                 b"bottom\x00" as *const u8 as
                                                     *const libc::c_char,
                                             value:
                                                 ZWLR_LAYER_SURFACE_V1_ANCHOR_BOTTOM
                                                     as libc::c_int as
                                                     uint32_t,};
                         init
                     },
                     {
                         let mut init =
                             C2RustUnnamed_1{name:
                                                 b"left\x00" as *const u8 as
                                                     *const libc::c_char,
                                             value:
                                                 ZWLR_LAYER_SURFACE_V1_ANCHOR_LEFT
                                                     as libc::c_int as
                                                     uint32_t,};
                         init
                     },
                     {
                         let mut init =
                             C2RustUnnamed_1{name:
                                                 b"right\x00" as *const u8 as
                                                     *const libc::c_char,
                                             value:
                                                 ZWLR_LAYER_SURFACE_V1_ANCHOR_RIGHT
                                                     as libc::c_int as
                                                     uint32_t,};
                         init
                     }];
                found = 0i32 != 0;
                let mut i_0: size_t = 0i32 as size_t;
                while i_0 <
                          (::std::mem::size_of::<[C2RustUnnamed_1; 4]>() as
                               libc::c_ulong).wrapping_div(::std::mem::size_of::<C2RustUnnamed_1>()
                                                               as
                                                               libc::c_ulong)
                      {
                    if strcmp(optarg, anchors[i_0 as usize].name) == 0i32 {
                        anchor |= anchors[i_0 as usize].value;
                        found = 1i32 != 0;
                        break ;
                    } else { i_0 = i_0.wrapping_add(1) }
                }
                if !found {
                    fprintf(stderr,
                            b"invalid anchor %s\n\x00" as *const u8 as
                                *const libc::c_char, optarg);
                    return 1i32
                }
            }
            116 => { alpha = atof(optarg) }
            109 => {
                let mut endptr: *mut libc::c_char = optarg;
                margin_top = strtol(endptr, &mut endptr, 10i32) as int32_t;
                if *endptr as libc::c_int == ',' as i32 {
                } else {
                    __assert_fail(b"*endptr == \',\'\x00" as *const u8 as
                                      *const libc::c_char,
                                  b"../examples/layer-shell.c\x00" as
                                      *const u8 as *const libc::c_char,
                                  549i32 as libc::c_uint,
                                  (*::std::mem::transmute::<&[u8; 23],
                                                            &[libc::c_char; 23]>(b"int main(int, char **)\x00")).as_ptr());
                };
                margin_right =
                    strtol(endptr.offset(1), &mut endptr, 10i32) as int32_t;
                if *endptr as libc::c_int == ',' as i32 {
                } else {
                    __assert_fail(b"*endptr == \',\'\x00" as *const u8 as
                                      *const libc::c_char,
                                  b"../examples/layer-shell.c\x00" as
                                      *const u8 as *const libc::c_char,
                                  551i32 as libc::c_uint,
                                  (*::std::mem::transmute::<&[u8; 23],
                                                            &[libc::c_char; 23]>(b"int main(int, char **)\x00")).as_ptr());
                };
                margin_bottom =
                    strtol(endptr.offset(1), &mut endptr, 10i32) as int32_t;
                if *endptr as libc::c_int == ',' as i32 {
                } else {
                    __assert_fail(b"*endptr == \',\'\x00" as *const u8 as
                                      *const libc::c_char,
                                  b"../examples/layer-shell.c\x00" as
                                      *const u8 as *const libc::c_char,
                                  553i32 as libc::c_uint,
                                  (*::std::mem::transmute::<&[u8; 23],
                                                            &[libc::c_char; 23]>(b"int main(int, char **)\x00")).as_ptr());
                };
                margin_left =
                    strtol(endptr.offset(1), &mut endptr, 10i32) as int32_t;
                if *endptr == 0 {
                } else {
                    __assert_fail(b"!*endptr\x00" as *const u8 as
                                      *const libc::c_char,
                                  b"../examples/layer-shell.c\x00" as
                                      *const u8 as *const libc::c_char,
                                  555i32 as libc::c_uint,
                                  (*::std::mem::transmute::<&[u8; 23],
                                                            &[libc::c_char; 23]>(b"int main(int, char **)\x00")).as_ptr());
                };
            }
            110 => { animate = 1i32 != 0 }
            107 => { keyboard_interactive = 1i32 != 0 }
            _ => { }
        }
    }
    display = wl_display_connect(0 as *const libc::c_char);
    if display.is_null() {
        fprintf(stderr,
                b"Failed to create display\n\x00" as *const u8 as
                    *const libc::c_char);
        return 1i32
    }
    let mut registry: *mut wl_registry = wl_display_get_registry(display);
    wl_registry_add_listener(registry, &registry_listener,
                             0 as *mut libc::c_void);
    wl_display_roundtrip(display);
    if compositor.is_null() {
        fprintf(stderr,
                b"wl_compositor not available\n\x00" as *const u8 as
                    *const libc::c_char);
        return 1i32
    }
    if shm.is_null() {
        fprintf(stderr,
                b"wl_shm not available\n\x00" as *const u8 as
                    *const libc::c_char);
        return 1i32
    }
    if layer_shell.is_null() {
        fprintf(stderr,
                b"layer_shell not available\n\x00" as *const u8 as
                    *const libc::c_char);
        return 1i32
    }
    let mut cursor_theme: *mut wl_cursor_theme =
        wl_cursor_theme_load(0 as *const libc::c_char, 16i32, shm);
    if !cursor_theme.is_null() {
    } else {
        __assert_fail(b"cursor_theme\x00" as *const u8 as *const libc::c_char,
                      b"../examples/layer-shell.c\x00" as *const u8 as
                          *const libc::c_char, 594i32 as libc::c_uint,
                      (*::std::mem::transmute::<&[u8; 23],
                                                &[libc::c_char; 23]>(b"int main(int, char **)\x00")).as_ptr());
    };
    let mut cursor: *mut wl_cursor =
        wl_cursor_theme_get_cursor(cursor_theme,
                                   b"crosshair\x00" as *const u8 as
                                       *const libc::c_char);
    if cursor.is_null() {
        cursor =
            wl_cursor_theme_get_cursor(cursor_theme,
                                       b"left_ptr\x00" as *const u8 as
                                           *const libc::c_char)
    }
    if !cursor.is_null() {
    } else {
        __assert_fail(b"cursor\x00" as *const u8 as *const libc::c_char,
                      b"../examples/layer-shell.c\x00" as *const u8 as
                          *const libc::c_char, 600i32 as libc::c_uint,
                      (*::std::mem::transmute::<&[u8; 23],
                                                &[libc::c_char; 23]>(b"int main(int, char **)\x00")).as_ptr());
    };
    cursor_image = *(*cursor).images.offset(0);
    cursor =
        wl_cursor_theme_get_cursor(cursor_theme,
                                   b"tcross\x00" as *const u8 as
                                       *const libc::c_char);
    if cursor.is_null() {
        cursor =
            wl_cursor_theme_get_cursor(cursor_theme,
                                       b"left_ptr\x00" as *const u8 as
                                           *const libc::c_char)
    }
    if !cursor.is_null() {
    } else {
        __assert_fail(b"cursor\x00" as *const u8 as *const libc::c_char,
                      b"../examples/layer-shell.c\x00" as *const u8 as
                          *const libc::c_char, 607i32 as libc::c_uint,
                      (*::std::mem::transmute::<&[u8; 23],
                                                &[libc::c_char; 23]>(b"int main(int, char **)\x00")).as_ptr());
    };
    popup_cursor_image = *(*cursor).images.offset(0);
    cursor_surface = wl_compositor_create_surface(compositor);
    if !cursor_surface.is_null() {
    } else {
        __assert_fail(b"cursor_surface\x00" as *const u8 as
                          *const libc::c_char,
                      b"../examples/layer-shell.c\x00" as *const u8 as
                          *const libc::c_char, 611i32 as libc::c_uint,
                      (*::std::mem::transmute::<&[u8; 23],
                                                &[libc::c_char; 23]>(b"int main(int, char **)\x00")).as_ptr());
    };
    let mut attribs: [EGLint; 3] = [0x3021i32, 8i32, 0x3038i32];
    wlr_egl_init(&mut egl, 0x31d8i32 as EGLenum, display as *mut libc::c_void,
                 attribs.as_mut_ptr(), WL_SHM_FORMAT_ARGB8888 as libc::c_int);
    wl_surface = wl_compositor_create_surface(compositor);
    if !wl_surface.is_null() {
    } else {
        __assert_fail(b"wl_surface\x00" as *const u8 as *const libc::c_char,
                      b"../examples/layer-shell.c\x00" as *const u8 as
                          *const libc::c_char, 618i32 as libc::c_uint,
                      (*::std::mem::transmute::<&[u8; 23],
                                                &[libc::c_char; 23]>(b"int main(int, char **)\x00")).as_ptr());
    };
    layer_surface =
        zwlr_layer_shell_v1_get_layer_surface(layer_shell, wl_surface,
                                              wl_output, layer,
                                              namespace.as_mut_ptr());
    if !layer_surface.is_null() {
    } else {
        __assert_fail(b"layer_surface\x00" as *const u8 as
                          *const libc::c_char,
                      b"../examples/layer-shell.c\x00" as *const u8 as
                          *const libc::c_char, 622i32 as libc::c_uint,
                      (*::std::mem::transmute::<&[u8; 23],
                                                &[libc::c_char; 23]>(b"int main(int, char **)\x00")).as_ptr());
    };
    zwlr_layer_surface_v1_set_size(layer_surface, width, height);
    zwlr_layer_surface_v1_set_anchor(layer_surface, anchor);
    zwlr_layer_surface_v1_set_exclusive_zone(layer_surface, exclusive_zone);
    zwlr_layer_surface_v1_set_margin(layer_surface, margin_top, margin_right,
                                     margin_bottom, margin_left);
    zwlr_layer_surface_v1_set_keyboard_interactivity(layer_surface,
                                                     keyboard_interactive as
                                                         uint32_t);
    zwlr_layer_surface_v1_add_listener(layer_surface,
                                       &mut layer_surface_listener,
                                       layer_surface as *mut libc::c_void);
    wl_surface_commit(wl_surface);
    wl_display_roundtrip(display);
    egl_window =
        wl_egl_window_create(wl_surface, width as libc::c_int,
                             height as libc::c_int);
    if !egl_window.is_null() {
    } else {
        __assert_fail(b"egl_window\x00" as *const u8 as *const libc::c_char,
                      b"../examples/layer-shell.c\x00" as *const u8 as
                          *const libc::c_char, 636i32 as libc::c_uint,
                      (*::std::mem::transmute::<&[u8; 23],
                                                &[libc::c_char; 23]>(b"int main(int, char **)\x00")).as_ptr());
    };
    egl_surface =
        wlr_egl_create_surface(&mut egl, egl_window as *mut libc::c_void) as
            *mut wlr_egl_surface;
    if !egl_surface.is_null() {
    } else {
        __assert_fail(b"egl_surface\x00" as *const u8 as *const libc::c_char,
                      b"../examples/layer-shell.c\x00" as *const u8 as
                          *const libc::c_char, 638i32 as libc::c_uint,
                      (*::std::mem::transmute::<&[u8; 23],
                                                &[libc::c_char; 23]>(b"int main(int, char **)\x00")).as_ptr());
    };
    wl_display_roundtrip(display);
    draw();
    // This space intentionally left blank
    while wl_display_dispatch(display) != -1i32 &&
              run_display as libc::c_int != 0 {
    }
    wl_cursor_theme_destroy(cursor_theme);
    return 0i32;
}
#[main]
pub fn main() {
    let mut args: Vec<*mut libc::c_char> = Vec::new();
    for arg in ::std::env::args() {
        args.push(::std::ffi::CString::new(arg).expect("Failed to convert argument into CString.").into_raw());
    };
    args.push(::std::ptr::null_mut());
    unsafe {
        ::std::process::exit(main_0((args.len() - 1) as libc::c_int,
                                    args.as_mut_ptr() as
                                        *mut *mut libc::c_char) as i32)
    }
}
