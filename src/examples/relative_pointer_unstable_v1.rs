use libc;
extern "C" {
    pub type _IO_wide_data;
    pub type _IO_codecvt;
    pub type _IO_marker;
    pub type wl_proxy;
    pub type wl_display;
    pub type wl_callback;
    pub type wl_compositor;
    /* Generated by wayland-scanner 1.17.0 */
    /* *
 * @page page_pointer_constraints_unstable_v1 The pointer_constraints_unstable_v1 protocol
 * protocol for constraining pointer motions
 *
 * @section page_desc_pointer_constraints_unstable_v1 Description
 *
 * This protocol specifies a set of interfaces used for adding constraints to
 * the motion of a pointer. Possible constraints include confining pointer
 * motions to a given region, or locking it to its current position.
 *
 * In order to constrain the pointer, a client must first bind the global
 * interface "wp_pointer_constraints" which, if a compositor supports pointer
 * constraints, is exposed by the registry. Using the bound global object, the
 * client uses the request that corresponds to the type of constraint it wants
 * to make. See wp_pointer_constraints for more details.
 *
 * Warning! The protocol described in this file is experimental and backward
 * incompatible changes may be made. Backward compatible changes may be added
 * together with the corresponding interface version bump. Backward
 * incompatible changes are done by bumping the version number in the protocol
 * and interface names and resetting the interface version. Once the protocol
 * is to be declared stable, the 'z' prefix and the version number in the
 * protocol and interface names are removed and the interface version number is
 * reset.
 *
 * @section page_ifaces_pointer_constraints_unstable_v1 Interfaces
 * - @subpage page_iface_zwp_pointer_constraints_v1 - constrain the movement of a pointer
 * - @subpage page_iface_zwp_locked_pointer_v1 - receive relative pointer motion events
 * - @subpage page_iface_zwp_confined_pointer_v1 - confined pointer object
 * @section page_copyright_pointer_constraints_unstable_v1 Copyright
 * <pre>
 *
 * Copyright © 2014      Jonas Ådahl
 * Copyright © 2015      Red Hat Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 * </pre>
 */
    /* Generated by wayland-scanner 1.17.0 */
    /* *
 * @page page_relative_pointer_unstable_v1 The relative_pointer_unstable_v1 protocol
 * protocol for relative pointer motion events
 *
 * @section page_desc_relative_pointer_unstable_v1 Description
 *
 * This protocol specifies a set of interfaces used for making clients able to
 * receive relative pointer events not obstructed by barriers (such as the
 * monitor edge or other pointer barriers).
 *
 * To start receiving relative pointer events, a client must first bind the
 * global interface "wp_relative_pointer_manager" which, if a compositor
 * supports relative pointer motion events, is exposed by the registry. After
 * having created the relative pointer manager proxy object, the client uses
 * it to create the actual relative pointer object using the
 * "get_relative_pointer" request given a wl_pointer. The relative pointer
 * motion events will then, when applicable, be transmitted via the proxy of
 * the newly created relative pointer object. See the documentation of the
 * relative pointer interface for more details.
 *
 * Warning! The protocol described in this file is experimental and backward
 * incompatible changes may be made. Backward compatible changes may be added
 * together with the corresponding interface version bump. Backward
 * incompatible changes are done by bumping the version number in the protocol
 * and interface names and resetting the interface version. Once the protocol
 * is to be declared stable, the 'z' prefix and the version number in the
 * protocol and interface names are removed and the interface version number is
 * reset.
 *
 * @section page_ifaces_relative_pointer_unstable_v1 Interfaces
 * - @subpage page_iface_zwp_relative_pointer_manager_v1 - get relative pointer objects
 * - @subpage page_iface_zwp_relative_pointer_v1 - relative pointer object
 * @section page_copyright_relative_pointer_unstable_v1 Copyright
 * <pre>
 *
 * Copyright © 2014      Jonas Ådahl
 * Copyright © 2015      Red Hat Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 * </pre>
 */
    pub type wl_pointer;
    pub type wl_region;
    pub type wl_registry;
    pub type wl_seat;
    pub type wl_surface;
    pub type zwp_locked_pointer_v1;
    pub type zwp_relative_pointer_v1;
    pub type zwp_pointer_constraints_v1;
    pub type xdg_wm_base;
    pub type zwp_relative_pointer_manager_v1;
    pub type wl_egl_window;
    pub type xdg_surface;
    pub type xdg_toplevel;
    pub type wlr_egl_surface;
    #[no_mangle]
    static mut stderr: *mut FILE;
    #[no_mangle]
    fn fprintf(_: *mut FILE, _: *const libc::c_char, _: ...) -> libc::c_int;
    #[no_mangle]
    fn calloc(_: libc::c_ulong, _: libc::c_ulong) -> *mut libc::c_void;
    #[no_mangle]
    fn exit(_: libc::c_int) -> !;
    #[no_mangle]
    fn strcmp(_: *const libc::c_char, _: *const libc::c_char) -> libc::c_int;
    #[no_mangle]
    fn glClear(mask: GLbitfield);
    #[no_mangle]
    fn glClearColor(red: GLfloat, green: GLfloat, blue: GLfloat,
                    alpha: GLfloat);
    #[no_mangle]
    fn glDisable(cap: GLenum);
    #[no_mangle]
    fn glEnable(cap: GLenum);
    #[no_mangle]
    fn glScissor(x: GLint, y: GLint, width: GLsizei, height: GLsizei);
    #[no_mangle]
    fn glViewport(x: GLint, y: GLint, width: GLsizei, height: GLsizei);
    #[no_mangle]
    fn wl_proxy_marshal(p: *mut wl_proxy, opcode: uint32_t, _: ...);
    #[no_mangle]
    fn wl_proxy_marshal_constructor(proxy: *mut wl_proxy, opcode: uint32_t,
                                    interface: *const wl_interface, _: ...)
     -> *mut wl_proxy;
    #[no_mangle]
    fn wl_proxy_marshal_constructor_versioned(proxy: *mut wl_proxy,
                                              opcode: uint32_t,
                                              interface: *const wl_interface,
                                              version: uint32_t, _: ...)
     -> *mut wl_proxy;
    #[no_mangle]
    fn wl_proxy_destroy(proxy: *mut wl_proxy);
    #[no_mangle]
    fn wl_proxy_add_listener(proxy: *mut wl_proxy,
                             implementation:
                                 *mut Option<unsafe extern "C" fn() -> ()>,
                             data: *mut libc::c_void) -> libc::c_int;
    #[no_mangle]
    fn wl_display_connect(name: *const libc::c_char) -> *mut wl_display;
    #[no_mangle]
    fn wl_display_dispatch(display: *mut wl_display) -> libc::c_int;
    #[no_mangle]
    fn wl_display_roundtrip(display: *mut wl_display) -> libc::c_int;
    #[no_mangle]
    static wl_registry_interface: wl_interface;
    #[no_mangle]
    static wl_callback_interface: wl_interface;
    #[no_mangle]
    static wl_compositor_interface: wl_interface;
    #[no_mangle]
    static wl_surface_interface: wl_interface;
    #[no_mangle]
    static wl_seat_interface: wl_interface;
    #[no_mangle]
    static wl_pointer_interface: wl_interface;
    #[no_mangle]
    fn wl_egl_window_resize(egl_window: *mut wl_egl_window,
                            width: libc::c_int, height: libc::c_int,
                            dx: libc::c_int, dy: libc::c_int);
    #[no_mangle]
    fn wl_egl_window_create(surface: *mut wl_surface, width: libc::c_int,
                            height: libc::c_int) -> *mut wl_egl_window;
    #[no_mangle]
    fn eglSwapBuffers(dpy: EGLDisplay, surface: EGLSurface) -> EGLBoolean;
    #[no_mangle]
    fn eglMakeCurrent(dpy: EGLDisplay, draw: EGLSurface, read: EGLSurface,
                      ctx: EGLContext) -> EGLBoolean;
    #[no_mangle]
    fn wlr_egl_create_surface(egl: *mut wlr_egl, window: *mut libc::c_void)
     -> EGLSurface;
    #[no_mangle]
    fn wlr_egl_finish(egl: *mut wlr_egl);
    #[no_mangle]
    fn wlr_egl_init(egl: *mut wlr_egl, platform: EGLenum,
                    remote_display: *mut libc::c_void,
                    config_attribs: *mut EGLint, visual_id: EGLint) -> bool;
    /* *
 * @page page_iface_zwp_pointer_constraints_v1 zwp_pointer_constraints_v1
 * @section page_iface_zwp_pointer_constraints_v1_desc Description
 *
 * The global interface exposing pointer constraining functionality. It
 * exposes two requests: lock_pointer for locking the pointer to its
 * position, and confine_pointer for locking the pointer to a region.
 *
 * The lock_pointer and confine_pointer requests create the objects
 * wp_locked_pointer and wp_confined_pointer respectively, and the client can
 * use these objects to interact with the lock.
 *
 * For any surface, only one lock or confinement may be active across all
 * wl_pointer objects of the same seat. If a lock or confinement is requested
 * when another lock or confinement is active or requested on the same surface
 * and with any of the wl_pointer objects of the same seat, an
 * 'already_constrained' error will be raised.
 * @section page_iface_zwp_pointer_constraints_v1_api API
 * See @ref iface_zwp_pointer_constraints_v1.
 */
/* *
 * @defgroup iface_zwp_pointer_constraints_v1 The zwp_pointer_constraints_v1 interface
 *
 * The global interface exposing pointer constraining functionality. It
 * exposes two requests: lock_pointer for locking the pointer to its
 * position, and confine_pointer for locking the pointer to a region.
 *
 * The lock_pointer and confine_pointer requests create the objects
 * wp_locked_pointer and wp_confined_pointer respectively, and the client can
 * use these objects to interact with the lock.
 *
 * For any surface, only one lock or confinement may be active across all
 * wl_pointer objects of the same seat. If a lock or confinement is requested
 * when another lock or confinement is active or requested on the same surface
 * and with any of the wl_pointer objects of the same seat, an
 * 'already_constrained' error will be raised.
 */
    #[no_mangle]
    static zwp_pointer_constraints_v1_interface: wl_interface;
    /* *
 * @page page_iface_zwp_locked_pointer_v1 zwp_locked_pointer_v1
 * @section page_iface_zwp_locked_pointer_v1_desc Description
 *
 * The wp_locked_pointer interface represents a locked pointer state.
 *
 * While the lock of this object is active, the wl_pointer objects of the
 * associated seat will not emit any wl_pointer.motion events.
 *
 * This object will send the event 'locked' when the lock is activated.
 * Whenever the lock is activated, it is guaranteed that the locked surface
 * will already have received pointer focus and that the pointer will be
 * within the region passed to the request creating this object.
 *
 * To unlock the pointer, send the destroy request. This will also destroy
 * the wp_locked_pointer object.
 *
 * If the compositor decides to unlock the pointer the unlocked event is
 * sent. See wp_locked_pointer.unlock for details.
 *
 * When unlocking, the compositor may warp the cursor position to the set
 * cursor position hint. If it does, it will not result in any relative
 * motion events emitted via wp_relative_pointer.
 *
 * If the surface the lock was requested on is destroyed and the lock is not
 * yet activated, the wp_locked_pointer object is now defunct and must be
 * destroyed.
 * @section page_iface_zwp_locked_pointer_v1_api API
 * See @ref iface_zwp_locked_pointer_v1.
 */
/* *
 * @defgroup iface_zwp_locked_pointer_v1 The zwp_locked_pointer_v1 interface
 *
 * The wp_locked_pointer interface represents a locked pointer state.
 *
 * While the lock of this object is active, the wl_pointer objects of the
 * associated seat will not emit any wl_pointer.motion events.
 *
 * This object will send the event 'locked' when the lock is activated.
 * Whenever the lock is activated, it is guaranteed that the locked surface
 * will already have received pointer focus and that the pointer will be
 * within the region passed to the request creating this object.
 *
 * To unlock the pointer, send the destroy request. This will also destroy
 * the wp_locked_pointer object.
 *
 * If the compositor decides to unlock the pointer the unlocked event is
 * sent. See wp_locked_pointer.unlock for details.
 *
 * When unlocking, the compositor may warp the cursor position to the set
 * cursor position hint. If it does, it will not result in any relative
 * motion events emitted via wp_relative_pointer.
 *
 * If the surface the lock was requested on is destroyed and the lock is not
 * yet activated, the wp_locked_pointer object is now defunct and must be
 * destroyed.
 */
    #[no_mangle]
    static zwp_locked_pointer_v1_interface: wl_interface;
    /* *
 * @page page_iface_zwp_relative_pointer_manager_v1 zwp_relative_pointer_manager_v1
 * @section page_iface_zwp_relative_pointer_manager_v1_desc Description
 *
 * A global interface used for getting the relative pointer object for a
 * given pointer.
 * @section page_iface_zwp_relative_pointer_manager_v1_api API
 * See @ref iface_zwp_relative_pointer_manager_v1.
 */
/* *
 * @defgroup iface_zwp_relative_pointer_manager_v1 The zwp_relative_pointer_manager_v1 interface
 *
 * A global interface used for getting the relative pointer object for a
 * given pointer.
 */
    #[no_mangle]
    static zwp_relative_pointer_manager_v1_interface: wl_interface;
    /* *
 * @page page_iface_zwp_relative_pointer_v1 zwp_relative_pointer_v1
 * @section page_iface_zwp_relative_pointer_v1_desc Description
 *
 * A wp_relative_pointer object is an extension to the wl_pointer interface
 * used for emitting relative pointer events. It shares the same focus as
 * wl_pointer objects of the same seat and will only emit events when it has
 * focus.
 * @section page_iface_zwp_relative_pointer_v1_api API
 * See @ref iface_zwp_relative_pointer_v1.
 */
/* *
 * @defgroup iface_zwp_relative_pointer_v1 The zwp_relative_pointer_v1 interface
 *
 * A wp_relative_pointer object is an extension to the wl_pointer interface
 * used for emitting relative pointer events. It shares the same focus as
 * wl_pointer objects of the same seat and will only emit events when it has
 * focus.
 */
    #[no_mangle]
    static zwp_relative_pointer_v1_interface: wl_interface;
    /* *
 * @page page_iface_xdg_wm_base xdg_wm_base
 * @section page_iface_xdg_wm_base_desc Description
 *
 * The xdg_wm_base interface is exposed as a global object enabling clients
 * to turn their wl_surfaces into windows in a desktop environment. It
 * defines the basic functionality needed for clients and the compositor to
 * create windows that can be dragged, resized, maximized, etc, as well as
 * creating transient windows such as popup menus.
 * @section page_iface_xdg_wm_base_api API
 * See @ref iface_xdg_wm_base.
 */
/* *
 * @defgroup iface_xdg_wm_base The xdg_wm_base interface
 *
 * The xdg_wm_base interface is exposed as a global object enabling clients
 * to turn their wl_surfaces into windows in a desktop environment. It
 * defines the basic functionality needed for clients and the compositor to
 * create windows that can be dragged, resized, maximized, etc, as well as
 * creating transient windows such as popup menus.
 */
    #[no_mangle]
    static xdg_wm_base_interface: wl_interface;
    /* *
 * @page page_iface_xdg_surface xdg_surface
 * @section page_iface_xdg_surface_desc Description
 *
 * An interface that may be implemented by a wl_surface, for
 * implementations that provide a desktop-style user interface.
 *
 * It provides a base set of functionality required to construct user
 * interface elements requiring management by the compositor, such as
 * toplevel windows, menus, etc. The types of functionality are split into
 * xdg_surface roles.
 *
 * Creating an xdg_surface does not set the role for a wl_surface. In order
 * to map an xdg_surface, the client must create a role-specific object
 * using, e.g., get_toplevel, get_popup. The wl_surface for any given
 * xdg_surface can have at most one role, and may not be assigned any role
 * not based on xdg_surface.
 *
 * A role must be assigned before any other requests are made to the
 * xdg_surface object.
 *
 * The client must call wl_surface.commit on the corresponding wl_surface
 * for the xdg_surface state to take effect.
 *
 * Creating an xdg_surface from a wl_surface which has a buffer attached or
 * committed is a client error, and any attempts by a client to attach or
 * manipulate a buffer prior to the first xdg_surface.configure call must
 * also be treated as errors.
 *
 * Mapping an xdg_surface-based role surface is defined as making it
 * possible for the surface to be shown by the compositor. Note that
 * a mapped surface is not guaranteed to be visible once it is mapped.
 *
 * For an xdg_surface to be mapped by the compositor, the following
 * conditions must be met:
 * (1) the client has assigned an xdg_surface-based role to the surface
 * (2) the client has set and committed the xdg_surface state and the
 * role-dependent state to the surface
 * (3) the client has committed a buffer to the surface
 *
 * A newly-unmapped surface is considered to have met condition (1) out
 * of the 3 required conditions for mapping a surface if its role surface
 * has not been destroyed.
 * @section page_iface_xdg_surface_api API
 * See @ref iface_xdg_surface.
 */
/* *
 * @defgroup iface_xdg_surface The xdg_surface interface
 *
 * An interface that may be implemented by a wl_surface, for
 * implementations that provide a desktop-style user interface.
 *
 * It provides a base set of functionality required to construct user
 * interface elements requiring management by the compositor, such as
 * toplevel windows, menus, etc. The types of functionality are split into
 * xdg_surface roles.
 *
 * Creating an xdg_surface does not set the role for a wl_surface. In order
 * to map an xdg_surface, the client must create a role-specific object
 * using, e.g., get_toplevel, get_popup. The wl_surface for any given
 * xdg_surface can have at most one role, and may not be assigned any role
 * not based on xdg_surface.
 *
 * A role must be assigned before any other requests are made to the
 * xdg_surface object.
 *
 * The client must call wl_surface.commit on the corresponding wl_surface
 * for the xdg_surface state to take effect.
 *
 * Creating an xdg_surface from a wl_surface which has a buffer attached or
 * committed is a client error, and any attempts by a client to attach or
 * manipulate a buffer prior to the first xdg_surface.configure call must
 * also be treated as errors.
 *
 * Mapping an xdg_surface-based role surface is defined as making it
 * possible for the surface to be shown by the compositor. Note that
 * a mapped surface is not guaranteed to be visible once it is mapped.
 *
 * For an xdg_surface to be mapped by the compositor, the following
 * conditions must be met:
 * (1) the client has assigned an xdg_surface-based role to the surface
 * (2) the client has set and committed the xdg_surface state and the
 * role-dependent state to the surface
 * (3) the client has committed a buffer to the surface
 *
 * A newly-unmapped surface is considered to have met condition (1) out
 * of the 3 required conditions for mapping a surface if its role surface
 * has not been destroyed.
 */
    #[no_mangle]
    static xdg_surface_interface: wl_interface;
    /* *
 * @page page_iface_xdg_toplevel xdg_toplevel
 * @section page_iface_xdg_toplevel_desc Description
 *
 * This interface defines an xdg_surface role which allows a surface to,
 * among other things, set window-like properties such as maximize,
 * fullscreen, and minimize, set application-specific metadata like title and
 * id, and well as trigger user interactive operations such as interactive
 * resize and move.
 *
 * Unmapping an xdg_toplevel means that the surface cannot be shown
 * by the compositor until it is explicitly mapped again.
 * All active operations (e.g., move, resize) are canceled and all
 * attributes (e.g. title, state, stacking, ...) are discarded for
 * an xdg_toplevel surface when it is unmapped.
 *
 * Attaching a null buffer to a toplevel unmaps the surface.
 * @section page_iface_xdg_toplevel_api API
 * See @ref iface_xdg_toplevel.
 */
/* *
 * @defgroup iface_xdg_toplevel The xdg_toplevel interface
 *
 * This interface defines an xdg_surface role which allows a surface to,
 * among other things, set window-like properties such as maximize,
 * fullscreen, and minimize, set application-specific metadata like title and
 * id, and well as trigger user interactive operations such as interactive
 * resize and move.
 *
 * Unmapping an xdg_toplevel means that the surface cannot be shown
 * by the compositor until it is explicitly mapped again.
 * All active operations (e.g., move, resize) are canceled and all
 * attributes (e.g. title, state, stacking, ...) are discarded for
 * an xdg_toplevel surface when it is unmapped.
 *
 * Attaching a null buffer to a toplevel unmaps the surface.
 */
    #[no_mangle]
    static xdg_toplevel_interface: wl_interface;
}
pub type size_t = libc::c_ulong;
pub type __int32_t = libc::c_int;
pub type __uint32_t = libc::c_uint;
pub type __uint64_t = libc::c_ulong;
pub type __off_t = libc::c_long;
pub type __off64_t = libc::c_long;
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct _IO_FILE {
    pub _flags: libc::c_int,
    pub _IO_read_ptr: *mut libc::c_char,
    pub _IO_read_end: *mut libc::c_char,
    pub _IO_read_base: *mut libc::c_char,
    pub _IO_write_base: *mut libc::c_char,
    pub _IO_write_ptr: *mut libc::c_char,
    pub _IO_write_end: *mut libc::c_char,
    pub _IO_buf_base: *mut libc::c_char,
    pub _IO_buf_end: *mut libc::c_char,
    pub _IO_save_base: *mut libc::c_char,
    pub _IO_backup_base: *mut libc::c_char,
    pub _IO_save_end: *mut libc::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: libc::c_int,
    pub _flags2: libc::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: libc::c_ushort,
    pub _vtable_offset: libc::c_schar,
    pub _shortbuf: [libc::c_char; 1],
    pub _lock: *mut libc::c_void,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut libc::c_void,
    pub __pad5: size_t,
    pub _mode: libc::c_int,
    pub _unused2: [libc::c_char; 20],
}
pub type _IO_lock_t = ();
pub type FILE = _IO_FILE;
pub type int32_t = __int32_t;
pub type uint32_t = __uint32_t;
pub type uint64_t = __uint64_t;
pub type khronos_int32_t = int32_t;
pub type khronos_float_t = libc::c_float;
pub type GLenum = libc::c_uint;
pub type GLfloat = khronos_float_t;
pub type GLbitfield = libc::c_uint;
pub type GLint = libc::c_int;
pub type GLsizei = libc::c_int;
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wl_message {
    pub name: *const libc::c_char,
    pub signature: *const libc::c_char,
    pub types: *mut *const wl_interface,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wl_interface {
    pub name: *const libc::c_char,
    pub version: libc::c_int,
    pub method_count: libc::c_int,
    pub methods: *const wl_message,
    pub event_count: libc::c_int,
    pub events: *const wl_message,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wl_list {
    pub prev: *mut wl_list,
    pub next: *mut wl_list,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wl_array {
    pub size: size_t,
    pub alloc: size_t,
    pub data: *mut libc::c_void,
}
pub type wl_fixed_t = int32_t;
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wl_listener {
    pub link: wl_list,
    pub notify: wl_notify_func_t,
}
pub type wl_notify_func_t
    =
    Option<unsafe extern "C" fn(_: *mut wl_listener, _: *mut libc::c_void)
               -> ()>;
pub type EGLint = khronos_int32_t;
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wl_registry_listener {
    pub global: Option<unsafe extern "C" fn(_: *mut libc::c_void,
                                            _: *mut wl_registry, _: uint32_t,
                                            _: *const libc::c_char,
                                            _: uint32_t) -> ()>,
    pub global_remove: Option<unsafe extern "C" fn(_: *mut libc::c_void,
                                                   _: *mut wl_registry,
                                                   _: uint32_t) -> ()>,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wl_callback_listener {
    pub done: Option<unsafe extern "C" fn(_: *mut libc::c_void,
                                          _: *mut wl_callback, _: uint32_t)
                         -> ()>,
}
pub type wl_shm_format = libc::c_uint;
pub const WL_SHM_FORMAT_YVU444: wl_shm_format = 875714137;
pub const WL_SHM_FORMAT_YUV444: wl_shm_format = 875713881;
pub const WL_SHM_FORMAT_YVU422: wl_shm_format = 909203033;
pub const WL_SHM_FORMAT_YUV422: wl_shm_format = 909202777;
pub const WL_SHM_FORMAT_YVU420: wl_shm_format = 842094169;
pub const WL_SHM_FORMAT_YUV420: wl_shm_format = 842093913;
pub const WL_SHM_FORMAT_YVU411: wl_shm_format = 825316953;
pub const WL_SHM_FORMAT_YUV411: wl_shm_format = 825316697;
pub const WL_SHM_FORMAT_YVU410: wl_shm_format = 961893977;
pub const WL_SHM_FORMAT_YUV410: wl_shm_format = 961959257;
pub const WL_SHM_FORMAT_NV61: wl_shm_format = 825644622;
pub const WL_SHM_FORMAT_NV16: wl_shm_format = 909203022;
pub const WL_SHM_FORMAT_NV21: wl_shm_format = 825382478;
pub const WL_SHM_FORMAT_NV12: wl_shm_format = 842094158;
pub const WL_SHM_FORMAT_AYUV: wl_shm_format = 1448433985;
pub const WL_SHM_FORMAT_VYUY: wl_shm_format = 1498765654;
pub const WL_SHM_FORMAT_UYVY: wl_shm_format = 1498831189;
pub const WL_SHM_FORMAT_YVYU: wl_shm_format = 1431918169;
pub const WL_SHM_FORMAT_YUYV: wl_shm_format = 1448695129;
pub const WL_SHM_FORMAT_BGRA1010102: wl_shm_format = 808665410;
pub const WL_SHM_FORMAT_RGBA1010102: wl_shm_format = 808665426;
pub const WL_SHM_FORMAT_ABGR2101010: wl_shm_format = 808665665;
pub const WL_SHM_FORMAT_ARGB2101010: wl_shm_format = 808669761;
pub const WL_SHM_FORMAT_BGRX1010102: wl_shm_format = 808671298;
pub const WL_SHM_FORMAT_RGBX1010102: wl_shm_format = 808671314;
pub const WL_SHM_FORMAT_XBGR2101010: wl_shm_format = 808665688;
pub const WL_SHM_FORMAT_XRGB2101010: wl_shm_format = 808669784;
pub const WL_SHM_FORMAT_BGRA8888: wl_shm_format = 875708738;
pub const WL_SHM_FORMAT_RGBA8888: wl_shm_format = 875708754;
pub const WL_SHM_FORMAT_ABGR8888: wl_shm_format = 875708993;
pub const WL_SHM_FORMAT_BGRX8888: wl_shm_format = 875714626;
pub const WL_SHM_FORMAT_RGBX8888: wl_shm_format = 875714642;
pub const WL_SHM_FORMAT_XBGR8888: wl_shm_format = 875709016;
pub const WL_SHM_FORMAT_BGR888: wl_shm_format = 875710274;
pub const WL_SHM_FORMAT_RGB888: wl_shm_format = 875710290;
pub const WL_SHM_FORMAT_BGR565: wl_shm_format = 909199170;
pub const WL_SHM_FORMAT_RGB565: wl_shm_format = 909199186;
pub const WL_SHM_FORMAT_BGRA5551: wl_shm_format = 892420418;
pub const WL_SHM_FORMAT_RGBA5551: wl_shm_format = 892420434;
pub const WL_SHM_FORMAT_ABGR1555: wl_shm_format = 892420673;
pub const WL_SHM_FORMAT_ARGB1555: wl_shm_format = 892424769;
pub const WL_SHM_FORMAT_BGRX5551: wl_shm_format = 892426306;
pub const WL_SHM_FORMAT_RGBX5551: wl_shm_format = 892426322;
pub const WL_SHM_FORMAT_XBGR1555: wl_shm_format = 892420696;
pub const WL_SHM_FORMAT_XRGB1555: wl_shm_format = 892424792;
pub const WL_SHM_FORMAT_BGRA4444: wl_shm_format = 842088770;
pub const WL_SHM_FORMAT_RGBA4444: wl_shm_format = 842088786;
pub const WL_SHM_FORMAT_ABGR4444: wl_shm_format = 842089025;
pub const WL_SHM_FORMAT_ARGB4444: wl_shm_format = 842093121;
pub const WL_SHM_FORMAT_BGRX4444: wl_shm_format = 842094658;
pub const WL_SHM_FORMAT_RGBX4444: wl_shm_format = 842094674;
pub const WL_SHM_FORMAT_XBGR4444: wl_shm_format = 842089048;
pub const WL_SHM_FORMAT_XRGB4444: wl_shm_format = 842093144;
pub const WL_SHM_FORMAT_BGR233: wl_shm_format = 944916290;
pub const WL_SHM_FORMAT_RGB332: wl_shm_format = 943867730;
pub const WL_SHM_FORMAT_C8: wl_shm_format = 538982467;
pub const WL_SHM_FORMAT_XRGB8888: wl_shm_format = 1;
pub const WL_SHM_FORMAT_ARGB8888: wl_shm_format = 0;
pub type wl_pointer_button_state = libc::c_uint;
pub const WL_POINTER_BUTTON_STATE_PRESSED: wl_pointer_button_state = 1;
pub const WL_POINTER_BUTTON_STATE_RELEASED: wl_pointer_button_state = 0;
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wl_pointer_listener {
    pub enter: Option<unsafe extern "C" fn(_: *mut libc::c_void,
                                           _: *mut wl_pointer, _: uint32_t,
                                           _: *mut wl_surface, _: wl_fixed_t,
                                           _: wl_fixed_t) -> ()>,
    pub leave: Option<unsafe extern "C" fn(_: *mut libc::c_void,
                                           _: *mut wl_pointer, _: uint32_t,
                                           _: *mut wl_surface) -> ()>,
    pub motion: Option<unsafe extern "C" fn(_: *mut libc::c_void,
                                            _: *mut wl_pointer, _: uint32_t,
                                            _: wl_fixed_t, _: wl_fixed_t)
                           -> ()>,
    pub button: Option<unsafe extern "C" fn(_: *mut libc::c_void,
                                            _: *mut wl_pointer, _: uint32_t,
                                            _: uint32_t, _: uint32_t,
                                            _: uint32_t) -> ()>,
    pub axis: Option<unsafe extern "C" fn(_: *mut libc::c_void,
                                          _: *mut wl_pointer, _: uint32_t,
                                          _: uint32_t, _: wl_fixed_t) -> ()>,
    pub frame: Option<unsafe extern "C" fn(_: *mut libc::c_void,
                                           _: *mut wl_pointer) -> ()>,
    pub axis_source: Option<unsafe extern "C" fn(_: *mut libc::c_void,
                                                 _: *mut wl_pointer,
                                                 _: uint32_t) -> ()>,
    pub axis_stop: Option<unsafe extern "C" fn(_: *mut libc::c_void,
                                               _: *mut wl_pointer,
                                               _: uint32_t, _: uint32_t)
                              -> ()>,
    pub axis_discrete: Option<unsafe extern "C" fn(_: *mut libc::c_void,
                                                   _: *mut wl_pointer,
                                                   _: uint32_t, _: int32_t)
                                  -> ()>,
}
pub type EGLBoolean = libc::c_uint;
pub type EGLDisplay = *mut libc::c_void;
pub type EGLConfig = *mut libc::c_void;
pub type EGLSurface = *mut libc::c_void;
pub type EGLContext = *mut libc::c_void;
pub type EGLenum = libc::c_uint;
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wlr_drm_format {
    pub format: uint32_t,
    pub len: size_t,
    pub cap: size_t,
    pub modifiers: [uint64_t; 0],
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wlr_drm_format_set {
    pub len: size_t,
    pub cap: size_t,
    pub formats: *mut *mut wlr_drm_format,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wlr_egl {
    pub platform: EGLenum,
    pub display: EGLDisplay,
    pub config: EGLConfig,
    pub context: EGLContext,
    pub exts_str: *const libc::c_char,
    pub exts: C2RustUnnamed,
    pub wl_display: *mut wl_display,
    pub dmabuf_formats: wlr_drm_format_set,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct C2RustUnnamed {
    pub bind_wayland_display_wl: bool,
    pub buffer_age_ext: bool,
    pub image_base_khr: bool,
    pub image_dma_buf_export_mesa: bool,
    pub image_dmabuf_import_ext: bool,
    pub image_dmabuf_import_modifiers_ext: bool,
    pub swap_buffers_with_damage_ext: bool,
    pub swap_buffers_with_damage_khr: bool,
}
/* ZWP_POINTER_CONSTRAINTS_V1_ERROR_ENUM */
/* *
 * @ingroup iface_zwp_pointer_constraints_v1
 * the pointer constraint may reactivate
 *
 * A persistent pointer constraint may again reactivate once it has
 * been deactivated. See the corresponding deactivation event
 * (wp_locked_pointer.unlocked and wp_confined_pointer.unconfined) for
 * details.
 */
pub type zwp_pointer_constraints_v1_lifetime = libc::c_uint;
pub const ZWP_POINTER_CONSTRAINTS_V1_LIFETIME_PERSISTENT:
          zwp_pointer_constraints_v1_lifetime =
    2;
pub const ZWP_POINTER_CONSTRAINTS_V1_LIFETIME_ONESHOT:
          zwp_pointer_constraints_v1_lifetime =
    1;
/* *
 * @ingroup iface_zwp_locked_pointer_v1
 * @struct zwp_locked_pointer_v1_listener
 */
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct zwp_locked_pointer_v1_listener {
    pub locked: Option<unsafe extern "C" fn(_: *mut libc::c_void,
                                            _: *mut zwp_locked_pointer_v1)
                           -> ()>,
    pub unlocked: Option<unsafe extern "C" fn(_: *mut libc::c_void,
                                              _: *mut zwp_locked_pointer_v1)
                             -> ()>,
}
/* *
 * @ingroup iface_zwp_relative_pointer_v1
 * @struct zwp_relative_pointer_v1_listener
 */
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct zwp_relative_pointer_v1_listener {
    pub relative_motion: Option<unsafe extern "C" fn(_: *mut libc::c_void,
                                                     _:
                                                         *mut zwp_relative_pointer_v1,
                                                     _: uint32_t, _: uint32_t,
                                                     _: wl_fixed_t,
                                                     _: wl_fixed_t,
                                                     _: wl_fixed_t,
                                                     _: wl_fixed_t) -> ()>,
}
/* XDG_SURFACE_ERROR_ENUM */
/* *
 * @ingroup iface_xdg_surface
 * @struct xdg_surface_listener
 */
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct xdg_surface_listener {
    pub configure: Option<unsafe extern "C" fn(_: *mut libc::c_void,
                                               _: *mut xdg_surface,
                                               _: uint32_t) -> ()>,
}
/* *
 * @ingroup iface_xdg_toplevel
 */
/* *
 * @ingroup iface_xdg_toplevel
 */
/* *
 * @ingroup iface_xdg_toplevel
 */
/* *
 * @ingroup iface_xdg_toplevel
 */
/* XDG_TOPLEVEL_STATE_ENUM */
/* *
 * @ingroup iface_xdg_toplevel
 * @struct xdg_toplevel_listener
 */
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct xdg_toplevel_listener {
    pub configure: Option<unsafe extern "C" fn(_: *mut libc::c_void,
                                               _: *mut xdg_toplevel,
                                               _: int32_t, _: int32_t,
                                               _: *mut wl_array) -> ()>,
    pub close: Option<unsafe extern "C" fn(_: *mut libc::c_void,
                                           _: *mut xdg_toplevel) -> ()>,
}
/* *
 * structs storing global state
 *
 * These are passed around as user data in the wayland globals.
 */
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct egl_info {
    pub egl: *mut wlr_egl,
    pub egl_window: *mut wl_egl_window,
    pub egl_surface: *mut wlr_egl_surface,
    pub width: uint32_t,
    pub height: uint32_t,
    pub surface: *mut wl_surface,
    pub frame_callback: *mut wl_callback,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct window {
    pub egl_info: *mut egl_info,
    pub pointer: *mut wl_pointer,
    pub locked_pointer: *mut zwp_locked_pointer_v1,
    pub relative_pointer: *mut zwp_relative_pointer_v1,
    pub pointer_x: int32_t,
    pub pointer_y: int32_t,
    pub last_draw: uint32_t,
}
#[inline]
unsafe extern "C" fn wl_fixed_to_int(mut f: wl_fixed_t) -> libc::c_int {
    return f / 256i32;
}
#[inline]
unsafe extern "C" fn wl_display_get_registry(mut wl_display: *mut wl_display)
 -> *mut wl_registry {
    let mut registry: *mut wl_proxy = 0 as *mut wl_proxy;
    registry =
        wl_proxy_marshal_constructor(wl_display as *mut wl_proxy,
                                     1i32 as uint32_t,
                                     &wl_registry_interface as
                                         *const wl_interface,
                                     0 as *mut libc::c_void);
    return registry as *mut wl_registry;
}
#[inline]
unsafe extern "C" fn wl_registry_add_listener(mut wl_registry:
                                                  *mut wl_registry,
                                              mut listener:
                                                  *const wl_registry_listener,
                                              mut data: *mut libc::c_void)
 -> libc::c_int {
    return wl_proxy_add_listener(wl_registry as *mut wl_proxy,
                                 listener as
                                     *mut Option<unsafe extern "C" fn()
                                                     -> ()>, data);
}
#[inline]
unsafe extern "C" fn wl_registry_bind(mut wl_registry: *mut wl_registry,
                                      mut name: uint32_t,
                                      mut interface: *const wl_interface,
                                      mut version: uint32_t)
 -> *mut libc::c_void {
    let mut id: *mut wl_proxy = 0 as *mut wl_proxy;
    id =
        wl_proxy_marshal_constructor_versioned(wl_registry as *mut wl_proxy,
                                               0i32 as uint32_t, interface,
                                               version, name,
                                               (*interface).name, version,
                                               0 as *mut libc::c_void);
    return id as *mut libc::c_void;
}
#[inline]
unsafe extern "C" fn wl_callback_add_listener(mut wl_callback:
                                                  *mut wl_callback,
                                              mut listener:
                                                  *const wl_callback_listener,
                                              mut data: *mut libc::c_void)
 -> libc::c_int {
    return wl_proxy_add_listener(wl_callback as *mut wl_proxy,
                                 listener as
                                     *mut Option<unsafe extern "C" fn()
                                                     -> ()>, data);
}
#[inline]
unsafe extern "C" fn wl_callback_destroy(mut wl_callback: *mut wl_callback) {
    wl_proxy_destroy(wl_callback as *mut wl_proxy);
}
#[inline]
unsafe extern "C" fn wl_compositor_create_surface(mut wl_compositor:
                                                      *mut wl_compositor)
 -> *mut wl_surface {
    let mut id: *mut wl_proxy = 0 as *mut wl_proxy;
    id =
        wl_proxy_marshal_constructor(wl_compositor as *mut wl_proxy,
                                     0i32 as uint32_t,
                                     &wl_surface_interface as
                                         *const wl_interface,
                                     0 as *mut libc::c_void);
    return id as *mut wl_surface;
}
#[inline]
unsafe extern "C" fn wl_surface_frame(mut wl_surface: *mut wl_surface)
 -> *mut wl_callback {
    let mut callback: *mut wl_proxy = 0 as *mut wl_proxy;
    callback =
        wl_proxy_marshal_constructor(wl_surface as *mut wl_proxy,
                                     3i32 as uint32_t,
                                     &wl_callback_interface as
                                         *const wl_interface,
                                     0 as *mut libc::c_void);
    return callback as *mut wl_callback;
}
#[inline]
unsafe extern "C" fn wl_surface_commit(mut wl_surface: *mut wl_surface) {
    wl_proxy_marshal(wl_surface as *mut wl_proxy, 6i32 as uint32_t);
}
#[inline]
unsafe extern "C" fn wl_seat_get_pointer(mut wl_seat: *mut wl_seat)
 -> *mut wl_pointer {
    let mut id: *mut wl_proxy = 0 as *mut wl_proxy;
    id =
        wl_proxy_marshal_constructor(wl_seat as *mut wl_proxy,
                                     0i32 as uint32_t,
                                     &wl_pointer_interface as
                                         *const wl_interface,
                                     0 as *mut libc::c_void);
    return id as *mut wl_pointer;
}
#[inline]
unsafe extern "C" fn wl_pointer_add_listener(mut wl_pointer: *mut wl_pointer,
                                             mut listener:
                                                 *const wl_pointer_listener,
                                             mut data: *mut libc::c_void)
 -> libc::c_int {
    return wl_proxy_add_listener(wl_pointer as *mut wl_proxy,
                                 listener as
                                     *mut Option<unsafe extern "C" fn()
                                                     -> ()>, data);
}
#[inline]
unsafe extern "C" fn wl_pointer_set_cursor(mut wl_pointer: *mut wl_pointer,
                                           mut serial: uint32_t,
                                           mut surface: *mut wl_surface,
                                           mut hotspot_x: int32_t,
                                           mut hotspot_y: int32_t) {
    wl_proxy_marshal(wl_pointer as *mut wl_proxy, 0i32 as uint32_t, serial,
                     surface, hotspot_x, hotspot_y);
}
/* *
 * @ingroup iface_zwp_pointer_constraints_v1
 *
 * The lock_pointer request lets the client request to disable movements of
 * the virtual pointer (i.e. the cursor), effectively locking the pointer
 * to a position. This request may not take effect immediately; in the
 * future, when the compositor deems implementation-specific constraints
 * are satisfied, the pointer lock will be activated and the compositor
 * sends a locked event.
 *
 * The protocol provides no guarantee that the constraints are ever
 * satisfied, and does not require the compositor to send an error if the
 * constraints cannot ever be satisfied. It is thus possible to request a
 * lock that will never activate.
 *
 * There may not be another pointer constraint of any kind requested or
 * active on the surface for any of the wl_pointer objects of the seat of
 * the passed pointer when requesting a lock. If there is, an error will be
 * raised. See general pointer lock documentation for more details.
 *
 * The intersection of the region passed with this request and the input
 * region of the surface is used to determine where the pointer must be
 * in order for the lock to activate. It is up to the compositor whether to
 * warp the pointer or require some kind of user interaction for the lock
 * to activate. If the region is null the surface input region is used.
 *
 * A surface may receive pointer focus without the lock being activated.
 *
 * The request creates a new object wp_locked_pointer which is used to
 * interact with the lock as well as receive updates about its state. See
 * the the description of wp_locked_pointer for further information.
 *
 * Note that while a pointer is locked, the wl_pointer objects of the
 * corresponding seat will not emit any wl_pointer.motion events, but
 * relative motion events will still be emitted via wp_relative_pointer
 * objects of the same seat. wl_pointer.axis and wl_pointer.button events
 * are unaffected.
 */
#[inline]
unsafe extern "C" fn zwp_pointer_constraints_v1_lock_pointer(mut zwp_pointer_constraints_v1:
                                                                 *mut zwp_pointer_constraints_v1,
                                                             mut surface:
                                                                 *mut wl_surface,
                                                             mut pointer:
                                                                 *mut wl_pointer,
                                                             mut region:
                                                                 *mut wl_region,
                                                             mut lifetime:
                                                                 uint32_t)
 -> *mut zwp_locked_pointer_v1 {
    let mut id: *mut wl_proxy = 0 as *mut wl_proxy;
    id =
        wl_proxy_marshal_constructor(zwp_pointer_constraints_v1 as
                                         *mut wl_proxy, 1i32 as uint32_t,
                                     &zwp_locked_pointer_v1_interface as
                                         *const wl_interface,
                                     0 as *mut libc::c_void, surface, pointer,
                                     region, lifetime);
    return id as *mut zwp_locked_pointer_v1;
}
/* *
 * @ingroup iface_zwp_locked_pointer_v1
 */
#[inline]
unsafe extern "C" fn zwp_locked_pointer_v1_add_listener(mut zwp_locked_pointer_v1:
                                                            *mut zwp_locked_pointer_v1,
                                                        mut listener:
                                                            *const zwp_locked_pointer_v1_listener,
                                                        mut data:
                                                            *mut libc::c_void)
 -> libc::c_int {
    return wl_proxy_add_listener(zwp_locked_pointer_v1 as *mut wl_proxy,
                                 listener as
                                     *mut Option<unsafe extern "C" fn()
                                                     -> ()>, data);
}
/* *
 * @ingroup iface_zwp_locked_pointer_v1
 *
 * Destroy the locked pointer object. If applicable, the compositor will
 * unlock the pointer.
 */
#[inline]
unsafe extern "C" fn zwp_locked_pointer_v1_destroy(mut zwp_locked_pointer_v1:
                                                       *mut zwp_locked_pointer_v1) {
    wl_proxy_marshal(zwp_locked_pointer_v1 as *mut wl_proxy,
                     0i32 as uint32_t);
    wl_proxy_destroy(zwp_locked_pointer_v1 as *mut wl_proxy);
}
/* *
 * @ingroup iface_zwp_relative_pointer_manager_v1
 *
 * Create a relative pointer interface given a wl_pointer object. See the
 * wp_relative_pointer interface for more details.
 */
#[inline]
unsafe extern "C" fn zwp_relative_pointer_manager_v1_get_relative_pointer(mut zwp_relative_pointer_manager_v1:
                                                                              *mut zwp_relative_pointer_manager_v1,
                                                                          mut pointer:
                                                                              *mut wl_pointer)
 -> *mut zwp_relative_pointer_v1 {
    let mut id: *mut wl_proxy = 0 as *mut wl_proxy;
    id =
        wl_proxy_marshal_constructor(zwp_relative_pointer_manager_v1 as
                                         *mut wl_proxy, 1i32 as uint32_t,
                                     &zwp_relative_pointer_v1_interface as
                                         *const wl_interface,
                                     0 as *mut libc::c_void, pointer);
    return id as *mut zwp_relative_pointer_v1;
}
/* *
 * @ingroup iface_zwp_relative_pointer_v1
 */
#[inline]
unsafe extern "C" fn zwp_relative_pointer_v1_add_listener(mut zwp_relative_pointer_v1:
                                                              *mut zwp_relative_pointer_v1,
                                                          mut listener:
                                                              *const zwp_relative_pointer_v1_listener,
                                                          mut data:
                                                              *mut libc::c_void)
 -> libc::c_int {
    return wl_proxy_add_listener(zwp_relative_pointer_v1 as *mut wl_proxy,
                                 listener as
                                     *mut Option<unsafe extern "C" fn()
                                                     -> ()>, data);
}
/* *
 * @ingroup iface_zwp_relative_pointer_v1
 */
#[inline]
unsafe extern "C" fn zwp_relative_pointer_v1_destroy(mut zwp_relative_pointer_v1:
                                                         *mut zwp_relative_pointer_v1) {
    wl_proxy_marshal(zwp_relative_pointer_v1 as *mut wl_proxy,
                     0i32 as uint32_t);
    wl_proxy_destroy(zwp_relative_pointer_v1 as *mut wl_proxy);
}
/* *
 * @ingroup iface_xdg_wm_base
 *
 * This creates an xdg_surface for the given surface. While xdg_surface
 * itself is not a role, the corresponding surface may only be assigned
 * a role extending xdg_surface, such as xdg_toplevel or xdg_popup.
 *
 * This creates an xdg_surface for the given surface. An xdg_surface is
 * used as basis to define a role to a given surface, such as xdg_toplevel
 * or xdg_popup. It also manages functionality shared between xdg_surface
 * based surface roles.
 *
 * See the documentation of xdg_surface for more details about what an
 * xdg_surface is and how it is used.
 */
#[inline]
unsafe extern "C" fn xdg_wm_base_get_xdg_surface(mut xdg_wm_base:
                                                     *mut xdg_wm_base,
                                                 mut surface: *mut wl_surface)
 -> *mut xdg_surface {
    let mut id: *mut wl_proxy = 0 as *mut wl_proxy;
    id =
        wl_proxy_marshal_constructor(xdg_wm_base as *mut wl_proxy,
                                     2i32 as uint32_t,
                                     &xdg_surface_interface as
                                         *const wl_interface,
                                     0 as *mut libc::c_void, surface);
    return id as *mut xdg_surface;
}
/* *
 * @ingroup iface_xdg_surface
 */
#[inline]
unsafe extern "C" fn xdg_surface_add_listener(mut xdg_surface:
                                                  *mut xdg_surface,
                                              mut listener:
                                                  *const xdg_surface_listener,
                                              mut data: *mut libc::c_void)
 -> libc::c_int {
    return wl_proxy_add_listener(xdg_surface as *mut wl_proxy,
                                 listener as
                                     *mut Option<unsafe extern "C" fn()
                                                     -> ()>, data);
}
/* *
 * @ingroup iface_xdg_surface
 *
 * This creates an xdg_toplevel object for the given xdg_surface and gives
 * the associated wl_surface the xdg_toplevel role.
 *
 * See the documentation of xdg_toplevel for more details about what an
 * xdg_toplevel is and how it is used.
 */
#[inline]
unsafe extern "C" fn xdg_surface_get_toplevel(mut xdg_surface:
                                                  *mut xdg_surface)
 -> *mut xdg_toplevel {
    let mut id: *mut wl_proxy = 0 as *mut wl_proxy;
    id =
        wl_proxy_marshal_constructor(xdg_surface as *mut wl_proxy,
                                     1i32 as uint32_t,
                                     &xdg_toplevel_interface as
                                         *const wl_interface,
                                     0 as *mut libc::c_void);
    return id as *mut xdg_toplevel;
}
/* *
 * @ingroup iface_xdg_surface
 *
 * When a configure event is received, if a client commits the
 * surface in response to the configure event, then the client
 * must make an ack_configure request sometime before the commit
 * request, passing along the serial of the configure event.
 *
 * For instance, for toplevel surfaces the compositor might use this
 * information to move a surface to the top left only when the client has
 * drawn itself for the maximized or fullscreen state.
 *
 * If the client receives multiple configure events before it
 * can respond to one, it only has to ack the last configure event.
 *
 * A client is not required to commit immediately after sending
 * an ack_configure request - it may even ack_configure several times
 * before its next surface commit.
 *
 * A client may send multiple ack_configure requests before committing, but
 * only the last request sent before a commit indicates which configure
 * event the client really is responding to.
 */
#[inline]
unsafe extern "C" fn xdg_surface_ack_configure(mut xdg_surface:
                                                   *mut xdg_surface,
                                               mut serial: uint32_t) {
    wl_proxy_marshal(xdg_surface as *mut wl_proxy, 4i32 as uint32_t, serial);
}
/* *
 * @ingroup iface_xdg_toplevel
 */
#[inline]
unsafe extern "C" fn xdg_toplevel_add_listener(mut xdg_toplevel:
                                                   *mut xdg_toplevel,
                                               mut listener:
                                                   *const xdg_toplevel_listener,
                                               mut data: *mut libc::c_void)
 -> libc::c_int {
    return wl_proxy_add_listener(xdg_toplevel as *mut wl_proxy,
                                 listener as
                                     *mut Option<unsafe extern "C" fn()
                                                     -> ()>, data);
}
/* *
 * surface handling and helpers
 *
 * draw_cursor and draw_relative_cursor draw a small 5px by 5px box around the
 * cursor and relative motion coordinates respectively. draw_background colors
 * the background black.
 *
 * The functions are somewhat duplicated, but it doesn't really matter.
 */
unsafe extern "C" fn surface_callback_handle_done(mut data: *mut libc::c_void,
                                                  mut callback:
                                                      *mut wl_callback,
                                                  mut time: uint32_t) {
    wl_callback_destroy(callback); /* white */
    let mut e: *mut egl_info = data as *mut egl_info; /* red */
    (*e).frame_callback = 0 as *mut wl_callback; /* black */
}
static mut surface_callback_listener: wl_callback_listener =
    unsafe {
        {
            let mut init =
                wl_callback_listener{done:
                                         Some(surface_callback_handle_done as
                                                  unsafe extern "C" fn(_:
                                                                           *mut libc::c_void,
                                                                       _:
                                                                           *mut wl_callback,
                                                                       _:
                                                                           uint32_t)
                                                      -> ()),};
            init
        }
    };
unsafe extern "C" fn draw_init(mut e: *mut egl_info) {
    eglMakeCurrent((*(*e).egl).display, (*e).egl_surface as EGLSurface,
                   (*e).egl_surface as EGLSurface, (*(*e).egl).context);
    glViewport(0i32, 0i32, (*e).width as GLsizei, (*e).height as GLsizei);
}
unsafe extern "C" fn draw_cursor(mut e: *mut egl_info, mut x: int32_t,
                                 mut y: int32_t) {
    glEnable(0xc11i32 as GLenum);
    glScissor(x, (*e).height.wrapping_sub(y as libc::c_uint) as GLint, 5i32,
              5i32);
    glClearColor(1.0f32, 1.0f32, 1.0f32, 1.0f32);
    glClear(0x4000i32 as GLbitfield);
    glDisable(0xc11i32 as GLenum);
}
unsafe extern "C" fn draw_relative_cursor(mut e: *mut egl_info,
                                          mut x: int32_t, mut y: int32_t) {
    glEnable(0xc11i32 as GLenum);
    glScissor(x, (*e).height.wrapping_sub(y as libc::c_uint) as GLint, 5i32,
              5i32);
    glClearColor(1.0f32, 0.0f32, 0.0f32, 1.0f32);
    glClear(0x4000i32 as GLbitfield);
    glDisable(0xc11i32 as GLenum);
}
unsafe extern "C" fn draw_background(mut e: *mut egl_info) {
    glClearColor(0.0f32, 0.0f32, 0.0f32, 1.0f32);
    glClear(0x4000i32 as GLbitfield);
}
unsafe extern "C" fn draw_end(mut e: *mut egl_info) {
    (*e).frame_callback = wl_surface_frame((*e).surface);
    wl_callback_add_listener((*e).frame_callback,
                             &mut surface_callback_listener,
                             e as *mut libc::c_void);
    eglSwapBuffers((*(*e).egl).display, (*e).egl_surface as EGLSurface);
}
/* *
 * registry and globals handling
 */
static mut compositor: *mut wl_compositor =
    0 as *const wl_compositor as *mut wl_compositor;
static mut seat: *mut wl_seat = 0 as *const wl_seat as *mut wl_seat;
static mut wm_base: *mut xdg_wm_base =
    0 as *const xdg_wm_base as *mut xdg_wm_base;
static mut pointer_constraints: *mut zwp_pointer_constraints_v1 =
    0 as *const zwp_pointer_constraints_v1 as *mut zwp_pointer_constraints_v1;
static mut relative_pointer_manager: *mut zwp_relative_pointer_manager_v1 =
    0 as *const zwp_relative_pointer_manager_v1 as
        *mut zwp_relative_pointer_manager_v1;
unsafe extern "C" fn registry_handle_global(mut data: *mut libc::c_void,
                                            mut registry: *mut wl_registry,
                                            mut name: uint32_t,
                                            mut interface:
                                                *const libc::c_char,
                                            mut version: uint32_t) {
    if strcmp(interface, wl_compositor_interface.name) == 0i32 {
        compositor =
            wl_registry_bind(registry, name, &wl_compositor_interface,
                             version) as *mut wl_compositor
    } else if strcmp(interface, xdg_wm_base_interface.name) == 0i32 {
        wm_base =
            wl_registry_bind(registry, name, &xdg_wm_base_interface, version)
                as *mut xdg_wm_base
    } else if strcmp(interface, wl_seat_interface.name) == 0i32 {
        seat =
            wl_registry_bind(registry, name, &wl_seat_interface, version) as
                *mut wl_seat
    } else if strcmp(interface, zwp_pointer_constraints_v1_interface.name) ==
                  0i32 {
        pointer_constraints =
            wl_registry_bind(registry, name,
                             &zwp_pointer_constraints_v1_interface, version)
                as *mut zwp_pointer_constraints_v1
    } else if strcmp(interface,
                     zwp_relative_pointer_manager_v1_interface.name) == 0i32 {
        relative_pointer_manager =
            wl_registry_bind(registry, name,
                             &zwp_relative_pointer_manager_v1_interface,
                             version) as *mut zwp_relative_pointer_manager_v1
    };
}
unsafe extern "C" fn registry_handle_global_remove(mut data:
                                                       *mut libc::c_void,
                                                   mut registry:
                                                       *mut wl_registry,
                                                   mut time: uint32_t) {
    /* This space intentionally left blank */
}
static mut registry_listener: wl_registry_listener =
    unsafe {
        {
            let mut init =
                wl_registry_listener{global:
                                         Some(registry_handle_global as
                                                  unsafe extern "C" fn(_:
                                                                           *mut libc::c_void,
                                                                       _:
                                                                           *mut wl_registry,
                                                                       _:
                                                                           uint32_t,
                                                                       _:
                                                                           *const libc::c_char,
                                                                       _:
                                                                           uint32_t)
                                                      -> ()),
                                     global_remove:
                                         Some(registry_handle_global_remove as
                                                  unsafe extern "C" fn(_:
                                                                           *mut libc::c_void,
                                                                       _:
                                                                           *mut wl_registry,
                                                                       _:
                                                                           uint32_t)
                                                      -> ()),};
            init
        }
    };
/* *
 * xdg_surface handling
 */
unsafe extern "C" fn xdg_surface_handle_configure(mut data: *mut libc::c_void,
                                                  mut xdg_surface:
                                                      *mut xdg_surface,
                                                  mut serial: uint32_t) {
    let mut e: *mut egl_info = data as *mut egl_info;
    xdg_surface_ack_configure(xdg_surface, serial);
    wl_egl_window_resize((*e).egl_window, (*e).width as libc::c_int,
                         (*e).height as libc::c_int, 0i32, 0i32);
    draw_init(e);
    draw_background(e);
    draw_end(e);
}
static mut xdg_surface_listener: xdg_surface_listener =
    unsafe {
        {
            let mut init =
                xdg_surface_listener{configure:
                                         Some(xdg_surface_handle_configure as
                                                  unsafe extern "C" fn(_:
                                                                           *mut libc::c_void,
                                                                       _:
                                                                           *mut xdg_surface,
                                                                       _:
                                                                           uint32_t)
                                                      -> ()),};
            init
        }
    };
/* *
 * xdg_toplevel handling
 */
unsafe extern "C" fn xdg_toplevel_handle_configure(mut data:
                                                       *mut libc::c_void,
                                                   mut xdg_toplevel:
                                                       *mut xdg_toplevel,
                                                   mut width: int32_t,
                                                   mut height: int32_t,
                                                   mut states:
                                                       *mut wl_array) {
    let mut e: *mut egl_info = data as *mut egl_info;
    // TODO: Why do we get 0,0 on initialization here? (in rootston)
    if width == 0i32 && height == 0i32 { return }
    (*e).width = width as uint32_t;
    (*e).height = height as uint32_t;
}
unsafe extern "C" fn xdg_toplevel_handle_close(mut data: *mut libc::c_void,
                                               mut xdg_toplevel:
                                                   *mut xdg_toplevel) {
    let mut e: *mut egl_info = data as *mut egl_info;
    wlr_egl_finish((*e).egl);
    exit(0i32);
}
static mut xdg_toplevel_listener: xdg_toplevel_listener =
    unsafe {
        {
            let mut init =
                xdg_toplevel_listener{configure:
                                          Some(xdg_toplevel_handle_configure
                                                   as
                                                   unsafe extern "C" fn(_:
                                                                            *mut libc::c_void,
                                                                        _:
                                                                            *mut xdg_toplevel,
                                                                        _:
                                                                            int32_t,
                                                                        _:
                                                                            int32_t,
                                                                        _:
                                                                            *mut wl_array)
                                                       -> ()),
                                      close:
                                          Some(xdg_toplevel_handle_close as
                                                   unsafe extern "C" fn(_:
                                                                            *mut libc::c_void,
                                                                        _:
                                                                            *mut xdg_toplevel)
                                                       -> ()),};
            init
        }
    };
/* *
 * zwp_locked_pointer handling
 *
 * Pointer unlocks need to be handled properly since the relative pointer needs
 * to be released as well. Unlocks happen when the focus is changed, for
 * example.
 */
unsafe extern "C" fn locked_pointer_handle_locked(mut data: *mut libc::c_void,
                                                  mut zwp_locked_pointer_v1:
                                                      *mut zwp_locked_pointer_v1) {
    /* This space intentionally left blank */
}
unsafe extern "C" fn locked_pointer_handle_unlocked(mut data:
                                                        *mut libc::c_void,
                                                    mut zwp_locked_pointer_v1:
                                                        *mut zwp_locked_pointer_v1) {
    let mut w: *mut window = data as *mut window;
    /* The locked pointer doesn't need to be destroyed since it was oneshot */
    (*w).locked_pointer = 0 as *mut zwp_locked_pointer_v1;
    if !(*w).relative_pointer.is_null() {
        /* Destroy the relative pointer */
        zwp_relative_pointer_v1_destroy((*w).relative_pointer);
        (*w).relative_pointer = 0 as *mut zwp_relative_pointer_v1
    }
    draw_init((*w).egl_info);
    draw_background((*w).egl_info);
    draw_end((*w).egl_info);
}
static mut locked_pointer_listener: zwp_locked_pointer_v1_listener =
    unsafe {
        {
            let mut init =
                zwp_locked_pointer_v1_listener{locked:
                                                   Some(locked_pointer_handle_locked
                                                            as
                                                            unsafe extern "C" fn(_:
                                                                                     *mut libc::c_void,
                                                                                 _:
                                                                                     *mut zwp_locked_pointer_v1)
                                                                -> ()),
                                               unlocked:
                                                   Some(locked_pointer_handle_unlocked
                                                            as
                                                            unsafe extern "C" fn(_:
                                                                                     *mut libc::c_void,
                                                                                 _:
                                                                                     *mut zwp_locked_pointer_v1)
                                                                -> ()),};
            init
        }
    };
/* *
 * zwp_relative_pointer handling
 *
 * Handling relative_motion events is the meat of the code. The handler simply
 * tries to indicate what the deltas look like.
 */
unsafe extern "C" fn relative_pointer_handle_relative_motion(mut data:
                                                                 *mut libc::c_void,
                                                             mut zwp_relative_pointer_v1:
                                                                 *mut zwp_relative_pointer_v1,
                                                             mut utime_hi:
                                                                 uint32_t,
                                                             mut utime_lo:
                                                                 uint32_t,
                                                             mut dx:
                                                                 wl_fixed_t,
                                                             mut dy:
                                                                 wl_fixed_t,
                                                             mut dx_unaccel:
                                                                 wl_fixed_t,
                                                             mut dy_unaccel:
                                                                 wl_fixed_t) {
    let mut w: *mut window = data as *mut window;
    /* *
	 * This renders the last location of the pointer (before it as locked), as
	 * well as what the position would have been after the given relative
	 * motion. Note that, if the device sends absolute motion events, the
	 * cursor location after relative motion is always identical to the actual
	 * cursor position.
	 */
    let mut utime: uint64_t =
        ((utime_hi as uint64_t) <<
             32i32).wrapping_add(utime_lo as
                                     libc::c_ulong).wrapping_div(1000i32 as
                                                                     libc::c_ulong);
    if utime.wrapping_sub((*w).last_draw as libc::c_ulong) >
           30i32 as libc::c_ulong && (*(*w).egl_info).frame_callback.is_null()
       {
        (*w).last_draw = utime as uint32_t;
        let mut e: *mut egl_info = (*w).egl_info;
        draw_init(e);
        draw_background(e);
        draw_cursor(e, (*w).pointer_x, (*w).pointer_y);
        draw_relative_cursor(e, (*w).pointer_x + wl_fixed_to_int(dx),
                             (*w).pointer_y + wl_fixed_to_int(dy));
        draw_end(e);
    };
}
static mut relative_pointer_listener: zwp_relative_pointer_v1_listener =
    unsafe {
        {
            let mut init =
                zwp_relative_pointer_v1_listener{relative_motion:
                                                     Some(relative_pointer_handle_relative_motion
                                                              as
                                                              unsafe extern "C" fn(_:
                                                                                       *mut libc::c_void,
                                                                                   _:
                                                                                       *mut zwp_relative_pointer_v1,
                                                                                   _:
                                                                                       uint32_t,
                                                                                   _:
                                                                                       uint32_t,
                                                                                   _:
                                                                                       wl_fixed_t,
                                                                                   _:
                                                                                       wl_fixed_t,
                                                                                   _:
                                                                                       wl_fixed_t,
                                                                                   _:
                                                                                       wl_fixed_t)
                                                                  -> ()),};
            init
        }
    };
/* *
 * wl_pointer handling
 *
 * The client toggles between locking the pointer and receiving relative motion
 * events, and releasing the locked pointer and falling back to normal motion
 * events, on a mouse button one (left mouse button) click.
 *
 * It additionally removes the cursor image, and indicates the pointer location
 * via a small white box.
 */
unsafe extern "C" fn pointer_handle_button(mut data: *mut libc::c_void,
                                           mut pointer: *mut wl_pointer,
                                           mut serial: uint32_t,
                                           mut time: uint32_t,
                                           mut button: uint32_t,
                                           mut state_w: uint32_t) {
    let mut w: *mut window = data as *mut window;
    let mut e: *mut egl_info = (*w).egl_info;
    if button == 0x110i32 as libc::c_uint &&
           state_w ==
               WL_POINTER_BUTTON_STATE_PRESSED as libc::c_int as libc::c_uint
       {
        if (*w).locked_pointer.is_null() && (*w).relative_pointer.is_null() {
            /* Get a locked pointer and add listener */
            (*w).locked_pointer =
                zwp_pointer_constraints_v1_lock_pointer(pointer_constraints,
                                                        (*(*w).egl_info).surface,
                                                        (*w).pointer,
                                                        0 as *mut wl_region,
                                                        ZWP_POINTER_CONSTRAINTS_V1_LIFETIME_ONESHOT
                                                            as libc::c_int as
                                                            uint32_t);
            zwp_locked_pointer_v1_add_listener((*w).locked_pointer,
                                               &locked_pointer_listener,
                                               w as *mut libc::c_void);
            /* Get relative pointer and add listener */
            (*w).relative_pointer =
                zwp_relative_pointer_manager_v1_get_relative_pointer(relative_pointer_manager,
                                                                     (*w).pointer);
            zwp_relative_pointer_v1_add_listener((*w).relative_pointer,
                                                 &relative_pointer_listener,
                                                 w as *mut libc::c_void);
            /* Commit the surface and render */
            wl_surface_commit((*e).surface);
            draw_init(e);
            draw_background(e);
            draw_cursor(e, (*w).pointer_x, (*w).pointer_y);
            draw_end(e);
        } else if !(*w).locked_pointer.is_null() &&
                      !(*w).relative_pointer.is_null() {
            /* Destroy the locked pointer */
            zwp_locked_pointer_v1_destroy((*w).locked_pointer);
            (*w).locked_pointer = 0 as *mut zwp_locked_pointer_v1;
            /* Destroy the relative pointer */
            zwp_relative_pointer_v1_destroy((*w).relative_pointer);
            (*w).relative_pointer = 0 as *mut zwp_relative_pointer_v1;
            /* Render */
            draw_init(e);
            draw_background(e);
            draw_cursor(e, (*w).pointer_x, (*w).pointer_y);
            draw_end(e);
        } else {
            fprintf(stderr,
                    b"Unknown state!\n\x00" as *const u8 as
                        *const libc::c_char);
            exit(1i32);
        }
    };
}
unsafe extern "C" fn pointer_handle_enter(mut data: *mut libc::c_void,
                                          mut wl_pointer: *mut wl_pointer,
                                          mut serial: uint32_t,
                                          mut surface: *mut wl_surface,
                                          mut surface_x: wl_fixed_t,
                                          mut surface_y: wl_fixed_t) {
    let mut w: *mut window = data as *mut window;
    wl_pointer_set_cursor((*w).pointer, serial, 0 as *mut wl_surface, 0i32,
                          0i32);
}
unsafe extern "C" fn pointer_handle_leave(mut data: *mut libc::c_void,
                                          mut wl_pointer: *mut wl_pointer,
                                          mut serial: uint32_t,
                                          mut surface: *mut wl_surface) {
    /* This space intentionally left blank */
}
unsafe extern "C" fn pointer_handle_motion(mut data: *mut libc::c_void,
                                           mut wl_pointer: *mut wl_pointer,
                                           mut time: uint32_t,
                                           mut surface_x: wl_fixed_t,
                                           mut surface_y: wl_fixed_t) {
    let mut w: *mut window = data as *mut window;
    let mut e: *mut egl_info = (*w).egl_info;
    (*w).pointer_x = wl_fixed_to_int(surface_x);
    (*w).pointer_y = wl_fixed_to_int(surface_y);
    if time.wrapping_sub((*w).last_draw) > 30i32 as libc::c_uint &&
           (*e).frame_callback.is_null() {
        (*w).last_draw = time;
        draw_init(e);
        draw_background(e);
        draw_cursor(e, (*w).pointer_x, (*w).pointer_y);
        draw_end(e);
    };
}
unsafe extern "C" fn pointer_handle_axis(mut data: *mut libc::c_void,
                                         mut wl_pointer: *mut wl_pointer,
                                         mut time: uint32_t,
                                         mut axis: uint32_t,
                                         mut value: wl_fixed_t) {
    /* This space intentionally left blank */
}
unsafe extern "C" fn pointer_handle_frame(mut data: *mut libc::c_void,
                                          mut wl_pointer: *mut wl_pointer) {
    /* This space intentionally left blank */
}
unsafe extern "C" fn pointer_handle_axis_source(mut data: *mut libc::c_void,
                                                mut wl_pointer:
                                                    *mut wl_pointer,
                                                mut axis_source: uint32_t) {
    /* This space intentionally left blank */
}
unsafe extern "C" fn pointer_handle_axis_stop(mut data: *mut libc::c_void,
                                              mut wl_pointer: *mut wl_pointer,
                                              mut time: uint32_t,
                                              mut axis: uint32_t) {
    /* This space intentionally left blank */
}
unsafe extern "C" fn pointer_handle_axis_discrete(mut data: *mut libc::c_void,
                                                  mut wl_pointer:
                                                      *mut wl_pointer,
                                                  mut axis: uint32_t,
                                                  mut discrete: int32_t) {
    /* This space intentionally left blank */
}
static mut pointer_listener: wl_pointer_listener =
    unsafe {
        {
            let mut init =
                wl_pointer_listener{enter:
                                        Some(pointer_handle_enter as
                                                 unsafe extern "C" fn(_:
                                                                          *mut libc::c_void,
                                                                      _:
                                                                          *mut wl_pointer,
                                                                      _:
                                                                          uint32_t,
                                                                      _:
                                                                          *mut wl_surface,
                                                                      _:
                                                                          wl_fixed_t,
                                                                      _:
                                                                          wl_fixed_t)
                                                     -> ()),
                                    leave:
                                        Some(pointer_handle_leave as
                                                 unsafe extern "C" fn(_:
                                                                          *mut libc::c_void,
                                                                      _:
                                                                          *mut wl_pointer,
                                                                      _:
                                                                          uint32_t,
                                                                      _:
                                                                          *mut wl_surface)
                                                     -> ()),
                                    motion:
                                        Some(pointer_handle_motion as
                                                 unsafe extern "C" fn(_:
                                                                          *mut libc::c_void,
                                                                      _:
                                                                          *mut wl_pointer,
                                                                      _:
                                                                          uint32_t,
                                                                      _:
                                                                          wl_fixed_t,
                                                                      _:
                                                                          wl_fixed_t)
                                                     -> ()),
                                    button:
                                        Some(pointer_handle_button as
                                                 unsafe extern "C" fn(_:
                                                                          *mut libc::c_void,
                                                                      _:
                                                                          *mut wl_pointer,
                                                                      _:
                                                                          uint32_t,
                                                                      _:
                                                                          uint32_t,
                                                                      _:
                                                                          uint32_t,
                                                                      _:
                                                                          uint32_t)
                                                     -> ()),
                                    axis:
                                        Some(pointer_handle_axis as
                                                 unsafe extern "C" fn(_:
                                                                          *mut libc::c_void,
                                                                      _:
                                                                          *mut wl_pointer,
                                                                      _:
                                                                          uint32_t,
                                                                      _:
                                                                          uint32_t,
                                                                      _:
                                                                          wl_fixed_t)
                                                     -> ()),
                                    frame:
                                        Some(pointer_handle_frame as
                                                 unsafe extern "C" fn(_:
                                                                          *mut libc::c_void,
                                                                      _:
                                                                          *mut wl_pointer)
                                                     -> ()),
                                    axis_source:
                                        Some(pointer_handle_axis_source as
                                                 unsafe extern "C" fn(_:
                                                                          *mut libc::c_void,
                                                                      _:
                                                                          *mut wl_pointer,
                                                                      _:
                                                                          uint32_t)
                                                     -> ()),
                                    axis_stop:
                                        Some(pointer_handle_axis_stop as
                                                 unsafe extern "C" fn(_:
                                                                          *mut libc::c_void,
                                                                      _:
                                                                          *mut wl_pointer,
                                                                      _:
                                                                          uint32_t,
                                                                      _:
                                                                          uint32_t)
                                                     -> ()),
                                    axis_discrete:
                                        Some(pointer_handle_axis_discrete as
                                                 unsafe extern "C" fn(_:
                                                                          *mut libc::c_void,
                                                                      _:
                                                                          *mut wl_pointer,
                                                                      _:
                                                                          uint32_t,
                                                                      _:
                                                                          int32_t)
                                                     -> ()),};
            init
        }
    };
/* *
 * relative-pointer:
 *
 * This client servers as an example for the relative-pointer-v1 protocol, and
 * to some extent the pointer-constraints protocol as well (the locked_pointer
 * interface).
 *
 * The intended behavior is the following. In the default state, the client
 * shows a black background, and renders the pointer location as a small white
 * box. No cursor is shown. In the locked state, the pointer is locked and the
 * client only listens for relative motion events, which are rendered relative
 * to the last unlocked pointer location by a small red box. Clicking with the
 * left mouse button toggles the state.
 *
 * Most of the code is standard. The interesting stuff happens in "wl_pointer
 * handling" (toggling states), and "zwp_relative_pointer handling" (rendering
 * relative motion events).
 */
unsafe fn main_0(mut argc: libc::c_int, mut argv: *mut *mut libc::c_char)
 -> libc::c_int {
    /* Connect to the display */
    let mut display: *mut wl_display =
        wl_display_connect(0 as *const libc::c_char);
    if display.is_null() {
        fprintf(stderr,
                b"Could not connect to a Wayland display\n\x00" as *const u8
                    as *const libc::c_char);
        return 1i32
    }
    /* Get the registry and set listeners */
    let mut registry: *mut wl_registry = wl_display_get_registry(display);
    wl_registry_add_listener(registry, &registry_listener,
                             0 as *mut libc::c_void);
    wl_display_dispatch(display);
    wl_display_roundtrip(display);
    /* Check that all the global interfaces were captured */
    if compositor.is_null() {
        fprintf(stderr,
                b"wl_compositor not available\n\x00" as *const u8 as
                    *const libc::c_char);
        return 1i32
    }
    if seat.is_null() {
        fprintf(stderr,
                b"wl_seat not available\n\x00" as *const u8 as
                    *const libc::c_char);
        return 1i32
    }
    if wm_base.is_null() {
        fprintf(stderr,
                b"xdg_wm_base not available\n\x00" as *const u8 as
                    *const libc::c_char);
        return 1i32
    }
    if pointer_constraints.is_null() {
        fprintf(stderr,
                b"zwp_pointer_constraints_v1 not available\n\x00" as *const u8
                    as *const libc::c_char);
        return 1i32
    }
    if relative_pointer_manager.is_null() {
        fprintf(stderr,
                b"zwp_relative_pointer_manager_v1 not available\n\x00" as
                    *const u8 as *const libc::c_char);
        return 1i32
    }
    /* Initialize EGL context */
    let mut e: *mut egl_info =
        calloc(1i32 as libc::c_ulong,
               ::std::mem::size_of::<egl_info>() as libc::c_ulong) as
            *mut egl_info;
    (*e).egl =
        calloc(1i32 as libc::c_ulong,
               ::std::mem::size_of::<wlr_egl>() as libc::c_ulong) as
            *mut wlr_egl;
    (*e).height = 512i32 as uint32_t;
    (*e).width = (*e).height;
    wlr_egl_init((*e).egl, 0x31d8i32 as EGLenum, display as *mut libc::c_void,
                 0 as *mut EGLint, WL_SHM_FORMAT_ARGB8888 as libc::c_int);
    /* Create the surface and xdg_toplevels, and set listeners */
    let mut surface: *mut wl_surface =
        wl_compositor_create_surface(compositor);
    let mut xdg_surface: *mut xdg_surface =
        xdg_wm_base_get_xdg_surface(wm_base, surface);
    let mut xdg_toplevel: *mut xdg_toplevel =
        xdg_surface_get_toplevel(xdg_surface);
    xdg_surface_add_listener(xdg_surface, &xdg_surface_listener,
                             e as *mut libc::c_void);
    xdg_toplevel_add_listener(xdg_toplevel, &xdg_toplevel_listener,
                              e as *mut libc::c_void);
    /* Create the egl window and surface */
    wl_surface_commit(surface);
    (*e).egl_window =
        wl_egl_window_create(surface, (*e).width as libc::c_int,
                             (*e).height as libc::c_int);
    (*e).egl_surface =
        wlr_egl_create_surface((*e).egl, (*e).egl_window as *mut libc::c_void)
            as *mut wlr_egl_surface;
    (*e).surface = surface;
    wl_display_roundtrip(display);
    /* Setup global state and render */
    let mut w: *mut window =
        calloc(1i32 as libc::c_ulong,
               ::std::mem::size_of::<window>() as libc::c_ulong) as
            *mut window;
    (*w).egl_info = e;
    draw_init(e);
    draw_background(e);
    draw_end(e);
    /* Setup the pointer */
    let mut pointer: *mut wl_pointer = wl_seat_get_pointer(seat);
    wl_pointer_add_listener(pointer, &pointer_listener,
                            w as *mut libc::c_void);
    (*w).pointer = pointer;
    /* Run display */
    while wl_display_dispatch(display) != -1i32 { }
    return 0i32;
}
#[main]
pub fn main() {
    let mut args: Vec<*mut libc::c_char> = Vec::new();
    for arg in ::std::env::args() {
        args.push(::std::ffi::CString::new(arg).expect("Failed to convert argument into CString.").into_raw());
    };
    args.push(::std::ptr::null_mut());
    unsafe {
        ::std::process::exit(main_0((args.len() - 1) as libc::c_int,
                                    args.as_mut_ptr() as
                                        *mut *mut libc::c_char) as i32)
    }
}
