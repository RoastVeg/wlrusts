use libc;
extern "C" {
    pub type wl_event_source;
    pub type wl_display;
    /* Generated by wayland-scanner 1.17.0 */
    pub type wl_client;
    pub type wl_global;
    pub type wlr_texture;
    pub type wlr_renderer;
    pub type wlr_backend_impl;
    pub type wlr_output_impl;
    #[no_mangle]
    fn __assert_fail(__assertion: *const libc::c_char,
                     __file: *const libc::c_char, __line: libc::c_uint,
                     __function: *const libc::c_char) -> !;
    #[no_mangle]
    fn calloc(_: libc::c_ulong, _: libc::c_ulong) -> *mut libc::c_void;
    #[no_mangle]
    fn free(__ptr: *mut libc::c_void);
    #[no_mangle]
    fn memset(_: *mut libc::c_void, _: libc::c_int, _: libc::c_ulong)
     -> *mut libc::c_void;
    #[no_mangle]
    fn wl_resource_instance_of(resource: *mut wl_resource,
                               interface: *const wl_interface,
                               implementation: *const libc::c_void)
     -> libc::c_int;
    #[no_mangle]
    fn wl_resource_get_version(resource: *mut wl_resource) -> libc::c_int;
    #[no_mangle]
    fn wl_resource_get_user_data(resource: *mut wl_resource)
     -> *mut libc::c_void;
    #[no_mangle]
    fn wl_resource_get_client(resource: *mut wl_resource) -> *mut wl_client;
    #[no_mangle]
    fn wl_resource_from_link(resource: *mut wl_list) -> *mut wl_resource;
    #[no_mangle]
    fn wl_resource_get_link(resource: *mut wl_resource) -> *mut wl_list;
    #[no_mangle]
    fn wl_list_init(list: *mut wl_list);
    #[no_mangle]
    fn wl_list_insert(list: *mut wl_list, elm: *mut wl_list);
    #[no_mangle]
    fn wl_list_remove(elm: *mut wl_list);
    #[no_mangle]
    fn wl_list_empty(list: *const wl_list) -> libc::c_int;
    #[no_mangle]
    fn wl_display_add_destroy_listener(display: *mut wl_display,
                                       listener: *mut wl_listener);
    #[no_mangle]
    fn wl_global_create(display: *mut wl_display,
                        interface: *const wl_interface, version: libc::c_int,
                        data: *mut libc::c_void, bind: wl_global_bind_func_t)
     -> *mut wl_global;
    #[no_mangle]
    fn wl_global_destroy(global: *mut wl_global);
    #[no_mangle]
    fn wl_client_post_no_memory(client: *mut wl_client);
    #[no_mangle]
    fn wl_resource_destroy(resource: *mut wl_resource);
    #[no_mangle]
    fn wl_resource_set_implementation(resource: *mut wl_resource,
                                      implementation: *const libc::c_void,
                                      data: *mut libc::c_void,
                                      destroy: wl_resource_destroy_func_t);
    #[no_mangle]
    fn wl_resource_create(client: *mut wl_client,
                          interface: *const wl_interface,
                          version: libc::c_int, id: uint32_t)
     -> *mut wl_resource;
    #[no_mangle]
    fn wl_resource_post_event(resource: *mut wl_resource, opcode: uint32_t,
                              _: ...);
    #[no_mangle]
    fn wlr_surface_from_resource(resource: *mut wl_resource)
     -> *mut wlr_surface;
    /* *
 * Returns the clock used by the backend for presentation feedback.
 */
    #[no_mangle]
    fn wlr_backend_get_presentation_clock(backend: *mut wlr_backend)
     -> clockid_t;
    /* *
 * @page page_iface_wp_presentation wp_presentation
 * @section page_iface_wp_presentation_desc Description
 *
 *
 *
 *
 * The main feature of this interface is accurate presentation
 * timing feedback to ensure smooth video playback while maintaining
 * audio/video synchronization. Some features use the concept of a
 * presentation clock, which is defined in the
 * presentation.clock_id event.
 *
 * A content update for a wl_surface is submitted by a
 * wl_surface.commit request. Request 'feedback' associates with
 * the wl_surface.commit and provides feedback on the content
 * update, particularly the final realized presentation time.
 *
 *
 *
 * When the final realized presentation time is available, e.g.
 * after a framebuffer flip completes, the requested
 * presentation_feedback.presented events are sent. The final
 * presentation time can differ from the compositor's predicted
 * display update time and the update's target time, especially
 * when the compositor misses its target vertical blanking period.
 * @section page_iface_wp_presentation_api API
 * See @ref iface_wp_presentation.
 */
/* *
 * @defgroup iface_wp_presentation The wp_presentation interface
 *
 *
 *
 *
 * The main feature of this interface is accurate presentation
 * timing feedback to ensure smooth video playback while maintaining
 * audio/video synchronization. Some features use the concept of a
 * presentation clock, which is defined in the
 * presentation.clock_id event.
 *
 * A content update for a wl_surface is submitted by a
 * wl_surface.commit request. Request 'feedback' associates with
 * the wl_surface.commit and provides feedback on the content
 * update, particularly the final realized presentation time.
 *
 *
 *
 * When the final realized presentation time is available, e.g.
 * after a framebuffer flip completes, the requested
 * presentation_feedback.presented events are sent. The final
 * presentation time can differ from the compositor's predicted
 * display update time and the update's target time, especially
 * when the compositor misses its target vertical blanking period.
 */
    #[no_mangle]
    static wp_presentation_interface: wl_interface;
    /* *
 * @page page_iface_wp_presentation_feedback wp_presentation_feedback
 * @section page_iface_wp_presentation_feedback_desc Description
 *
 * A presentation_feedback object returns an indication that a
 * wl_surface content update has become visible to the user.
 * One object corresponds to one content update submission
 * (wl_surface.commit). There are two possible outcomes: the
 * content update is presented to the user, and a presentation
 * timestamp delivered; or, the user did not see the content
 * update because it was superseded or its surface destroyed,
 * and the content update is discarded.
 *
 * Once a presentation_feedback object has delivered a 'presented'
 * or 'discarded' event it is automatically destroyed.
 * @section page_iface_wp_presentation_feedback_api API
 * See @ref iface_wp_presentation_feedback.
 */
/* *
 * @defgroup iface_wp_presentation_feedback The wp_presentation_feedback interface
 *
 * A presentation_feedback object returns an indication that a
 * wl_surface content update has become visible to the user.
 * One object corresponds to one content update submission
 * (wl_surface.commit). There are two possible outcomes: the
 * content update is presented to the user, and a presentation
 * timestamp delivered; or, the user did not see the content
 * update because it was superseded or its surface destroyed,
 * and the content update is discarded.
 *
 * Once a presentation_feedback object has delivered a 'presented'
 * or 'discarded' event it is automatically destroyed.
 */
    #[no_mangle]
    static wp_presentation_feedback_interface: wl_interface;
    #[no_mangle]
    fn wlr_signal_emit_safe(signal: *mut wl_signal, data: *mut libc::c_void);
}
pub type size_t = libc::c_ulong;
pub type __int32_t = libc::c_int;
pub type __uint32_t = libc::c_uint;
pub type __uint64_t = libc::c_ulong;
pub type __time_t = libc::c_long;
pub type __clockid_t = libc::c_int;
pub type __syscall_slong_t = libc::c_long;

#[repr(C)]#[derive(Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
pub type clockid_t = __clockid_t;
pub type int32_t = __int32_t;
pub type uint32_t = __uint32_t;
pub type uint64_t = __uint64_t;

#[repr(C)]#[derive(Copy, Clone)]
pub struct wl_object {
    pub interface: *const wl_interface,
    pub implementation: *const libc::c_void,
    pub id: uint32_t,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct wl_interface {
    pub name: *const libc::c_char,
    pub version: libc::c_int,
    pub method_count: libc::c_int,
    pub methods: *const wl_message,
    pub event_count: libc::c_int,
    pub events: *const wl_message,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct wl_message {
    pub name: *const libc::c_char,
    pub signature: *const libc::c_char,
    pub types: *mut *const wl_interface,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct wl_list {
    pub prev: *mut wl_list,
    pub next: *mut wl_list,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct wl_listener {
    pub link: wl_list,
    pub notify: wl_notify_func_t,
}
pub type wl_notify_func_t
    =
    Option<unsafe extern "C" fn(_: *mut wl_listener, _: *mut libc::c_void)
               -> ()>;
pub type wl_global_bind_func_t
    =
    Option<unsafe extern "C" fn(_: *mut wl_client, _: *mut libc::c_void,
                                _: uint32_t, _: uint32_t) -> ()>;

#[repr(C)]#[derive(Copy, Clone)]
pub struct wl_resource {
    pub object: wl_object,
    pub destroy: wl_resource_destroy_func_t,
    pub link: wl_list,
    pub destroy_signal: wl_signal,
    pub client: *mut wl_client,
    pub data: *mut libc::c_void,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct wl_signal {
    pub listener_list: wl_list,
}
pub type wl_resource_destroy_func_t
    =
    Option<unsafe extern "C" fn(_: *mut wl_resource) -> ()>;

#[repr(C)]#[derive(Copy, Clone)]
pub struct wlr_surface {
    pub resource: *mut wl_resource,
    pub renderer: *mut crate::src::backend::drm::atomic::wlr_renderer,
    pub buffer: *mut wlr_buffer,
    pub sx: libc::c_int,
    pub sy: libc::c_int,
    pub buffer_damage: pixman_region32_t,
    pub opaque_region: pixman_region32_t,
    pub input_region: pixman_region32_t,
    pub current: wlr_surface_state,
    pub pending: wlr_surface_state,
    pub previous: wlr_surface_state,
    pub role: *const wlr_surface_role,
    pub role_data: *mut libc::c_void,
    pub events: C2RustUnnamed,
    pub subsurfaces: wl_list,
    pub subsurface_pending_list: wl_list,
    pub renderer_destroy: wl_listener,
    pub data: *mut libc::c_void,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct C2RustUnnamed {
    pub commit: wl_signal,
    pub new_subsurface: wl_signal,
    pub destroy: wl_signal,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct wlr_surface_role {
    pub name: *const libc::c_char,
    pub commit: Option<unsafe extern "C" fn(_: *mut wlr_surface) -> ()>,
    pub precommit: Option<unsafe extern "C" fn(_: *mut wlr_surface) -> ()>,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct wlr_surface_state {
    pub committed: uint32_t,
    pub buffer_resource: *mut wl_resource,
    pub dx: int32_t,
    pub dy: int32_t,
    pub surface_damage: pixman_region32_t,
    pub buffer_damage: pixman_region32_t,
    pub opaque: pixman_region32_t,
    pub input: pixman_region32_t,
    pub transform: wl_output_transform,
    pub scale: int32_t,
    pub frame_callback_list: wl_list,
    pub width: libc::c_int,
    pub height: libc::c_int,
    pub buffer_width: libc::c_int,
    pub buffer_height: libc::c_int,
    pub buffer_destroy: wl_listener,
}
pub type wl_output_transform = libc::c_uint;
pub const WL_OUTPUT_TRANSFORM_FLIPPED_270: wl_output_transform = 7;
pub const WL_OUTPUT_TRANSFORM_FLIPPED_180: wl_output_transform = 6;
pub const WL_OUTPUT_TRANSFORM_FLIPPED_90: wl_output_transform = 5;
pub const WL_OUTPUT_TRANSFORM_FLIPPED: wl_output_transform = 4;
pub const WL_OUTPUT_TRANSFORM_270: wl_output_transform = 3;
pub const WL_OUTPUT_TRANSFORM_180: wl_output_transform = 2;
pub const WL_OUTPUT_TRANSFORM_90: wl_output_transform = 1;
pub const WL_OUTPUT_TRANSFORM_NORMAL: wl_output_transform = 0;
pub type pixman_region32_t = pixman_region32;

#[repr(C)]#[derive(Copy, Clone)]
pub struct pixman_region32 {
    pub extents: pixman_box32_t,
    pub data: *mut pixman_region32_data_t,
}
pub type pixman_region32_data_t = pixman_region32_data;

#[repr(C)]#[derive(Copy, Clone)]
pub struct pixman_region32_data {
    pub size: libc::c_long,
    pub numRects: libc::c_long,
}
pub type pixman_box32_t = pixman_box32;

#[repr(C)]#[derive(Copy, Clone)]
pub struct pixman_box32 {
    pub x1: int32_t,
    pub y1: int32_t,
    pub x2: int32_t,
    pub y2: int32_t,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct wlr_buffer {
    pub resource: *mut wl_resource,
    pub texture: *mut crate::src::backend::drm::atomic::wlr_texture,
    pub released: bool,
    pub n_refs: size_t,
    pub resource_destroy: wl_listener,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct wlr_presentation_feedback {
    pub presentation: *mut wlr_presentation,
    pub surface: *mut wlr_surface,
    pub link: wl_list,
    pub resources: wl_list,
    pub committed: bool,
    pub sampled: bool,
    pub presented: bool,
    pub output: *mut wlr_output,
    pub output_committed: bool,
    pub output_commit_seq: uint32_t,
    pub surface_commit: wl_listener,
    pub surface_destroy: wl_listener,
    pub output_commit: wl_listener,
    pub output_present: wl_listener,
    pub output_destroy: wl_listener,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct wlr_output {
    pub impl_0: *const crate::src::backend::drm::backend::wlr_output_impl,
    pub backend: *mut wlr_backend,
    pub display: *mut wl_display,
    pub global: *mut wl_global,
    pub resources: wl_list,
    pub name: [libc::c_char; 24],
    pub make: [libc::c_char; 56],
    pub model: [libc::c_char; 16],
    pub serial: [libc::c_char; 16],
    pub phys_width: int32_t,
    pub phys_height: int32_t,
    pub modes: wl_list,
    pub current_mode: *mut wlr_output_mode,
    pub width: int32_t,
    pub height: int32_t,
    pub refresh: int32_t,
    pub enabled: bool,
    pub scale: libc::c_float,
    pub subpixel: wl_output_subpixel,
    pub transform: wl_output_transform,
    pub needs_frame: bool,
    pub damage: pixman_region32_t,
    pub frame_pending: bool,
    pub transform_matrix: [libc::c_float; 9],
    pub pending: wlr_output_state,
    pub commit_seq: uint32_t,
    pub events: C2RustUnnamed_1,
    pub idle_frame: *mut wl_event_source,
    pub idle_done: *mut wl_event_source,
    pub attach_render_locks: libc::c_int,
    pub cursors: wl_list,
    pub hardware_cursor: *mut wlr_output_cursor,
    pub software_cursor_locks: libc::c_int,
    pub display_destroy: wl_listener,
    pub data: *mut libc::c_void,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct wlr_output_cursor {
    pub output: *mut wlr_output,
    pub x: libc::c_double,
    pub y: libc::c_double,
    pub enabled: bool,
    pub visible: bool,
    pub width: uint32_t,
    pub height: uint32_t,
    pub hotspot_x: int32_t,
    pub hotspot_y: int32_t,
    pub link: wl_list,
    pub texture: *mut crate::src::backend::drm::atomic::wlr_texture,
    pub surface: *mut wlr_surface,
    pub surface_commit: wl_listener,
    pub surface_destroy: wl_listener,
    pub events: C2RustUnnamed_0,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct C2RustUnnamed_0 {
    pub destroy: wl_signal,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct C2RustUnnamed_1 {
    pub frame: wl_signal,
    pub needs_frame: wl_signal,
    pub precommit: wl_signal,
    pub commit: wl_signal,
    pub present: wl_signal,
    pub enable: wl_signal,
    pub mode: wl_signal,
    pub scale: wl_signal,
    pub transform: wl_signal,
    pub destroy: wl_signal,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct wlr_output_state {
    pub committed: uint32_t,
    pub damage: pixman_region32_t,
    pub buffer_type: wlr_output_state_buffer_type,
    pub buffer: *mut wlr_buffer,
}
pub type wlr_output_state_buffer_type = libc::c_uint;
pub const WLR_OUTPUT_STATE_BUFFER_SCANOUT: wlr_output_state_buffer_type = 1;
pub const WLR_OUTPUT_STATE_BUFFER_RENDER: wlr_output_state_buffer_type = 0;
pub type wl_output_subpixel = libc::c_uint;
pub const WL_OUTPUT_SUBPIXEL_VERTICAL_BGR: wl_output_subpixel = 5;
pub const WL_OUTPUT_SUBPIXEL_VERTICAL_RGB: wl_output_subpixel = 4;
pub const WL_OUTPUT_SUBPIXEL_HORIZONTAL_BGR: wl_output_subpixel = 3;
pub const WL_OUTPUT_SUBPIXEL_HORIZONTAL_RGB: wl_output_subpixel = 2;
pub const WL_OUTPUT_SUBPIXEL_NONE: wl_output_subpixel = 1;
pub const WL_OUTPUT_SUBPIXEL_UNKNOWN: wl_output_subpixel = 0;

#[repr(C)]#[derive(Copy, Clone)]
pub struct wlr_output_mode {
    pub width: int32_t,
    pub height: int32_t,
    pub refresh: int32_t,
    pub preferred: bool,
    pub link: wl_list,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct wlr_backend {
    pub impl_0: *const crate::src::backend::backend::wlr_backend_impl,
    pub events: C2RustUnnamed_2,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct C2RustUnnamed_2 {
    pub destroy: wl_signal,
    pub new_input: wl_signal,
    pub new_output: wl_signal,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct wlr_presentation {
    pub global: *mut wl_global,
    pub feedbacks: wl_list,
    pub clock: clockid_t,
    pub events: C2RustUnnamed_3,
    pub display_destroy: wl_listener,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct C2RustUnnamed_3 {
    pub destroy: wl_signal,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct wlr_output_event_present {
    pub output: *mut wlr_output,
    pub commit_seq: uint32_t,
    pub when: *mut timespec,
    pub seq: libc::c_uint,
    pub refresh: libc::c_int,
    pub flags: uint32_t,
    /* *
 * Mark the current surface's buffer as sampled.
 *
 * The compositor must call this function when it uses the surface's current
 * contents (e.g. when rendering the surface's current texture, when
 * referencing its current buffer, or when directly scanning out its current
 * buffer). A wlr_presentation_feedback is returned. The compositor should call
 * wlr_presentation_feedback_send_presented if this content has been displayed,
 * then wlr_presentation_feedback_destroy.
 *
 * NULL is returned if the client hasn't requested presentation feedback for
 * this surface.
 */
    /* *
 * Fill a wlr_presentation_event from a wlr_output_event_present.
 */
    /* *
 * Mark the current surface's buffer as sampled on the given output.
 *
 * Instead of calling wlr_presentation_surface_sampled and managing the
 * wlr_presentation_feedback itself, the compositor can call this function
 * before a wlr_output_commit call to indicate that the surface's current
 * contents will be displayed on the output.
 */
}
/*
 * This an unstable interface of wlroots. No guarantees are made regarding the
 * future consistency of this API.
 */
// wlr_presentation_feedback::link
// NULL if the surface has been destroyed
// wlr_presentation::feedbacks
// wl_resource_get_link
// The surface contents were committed.
// The surface contents were sampled by the compositor and are to be
	// presented on the next flip. Can become true only after committed becomes
	// true.
// Only when the wlr_presentation_surface_sampled_on_output helper has been
	// called

#[repr(C)]#[derive(Copy, Clone)]
pub struct wlr_presentation_event {
    pub output: *mut wlr_output,
    pub tv_sec: uint64_t,
    pub tv_nsec: uint32_t,
    pub refresh: uint32_t,
    pub seq: uint64_t,
    pub flags: uint32_t,
    // wp_presentation_feedback_kind
}
/* WP_PRESENTATION_ERROR_ENUM */
/* *
 * @ingroup iface_wp_presentation
 * @struct wp_presentation_interface
 */

#[repr(C)]#[derive(Copy, Clone)]
pub struct wp_presentation_interface {
    pub destroy: Option<unsafe extern "C" fn(_: *mut wl_client,
                                             _: *mut wl_resource) -> ()>,
    pub feedback: Option<unsafe extern "C" fn(_: *mut wl_client,
                                              _: *mut wl_resource,
                                              _: *mut wl_resource,
                                              _: uint32_t) -> ()>,
}
#[inline]
unsafe extern "C" fn wl_signal_init(mut signal: *mut wl_signal) {
    wl_list_init(&mut (*signal).listener_list);
}
#[inline]
unsafe extern "C" fn wl_signal_add(mut signal: *mut wl_signal,
                                   mut listener: *mut wl_listener) {
    wl_list_insert((*signal).listener_list.prev, &mut (*listener).link);
}
/* *
 * @ingroup iface_wp_presentation
 */
/* *
 * @ingroup iface_wp_presentation
 */
/* *
 * @ingroup iface_wp_presentation
 */
/* *
 * @ingroup iface_wp_presentation
 * Sends an clock_id event to the client owning the resource.
 * @param resource_ The client's resource
 * @param clk_id platform clock identifier
 */
#[inline]
unsafe extern "C" fn wp_presentation_send_clock_id(mut resource_:
                                                       *mut wl_resource,
                                                   mut clk_id: uint32_t) {
    wl_resource_post_event(resource_, 0i32 as uint32_t, clk_id);
}
/* *
 * @ingroup iface_wp_presentation_feedback
 */
/* *
 * @ingroup iface_wp_presentation_feedback
 */
/* *
 * @ingroup iface_wp_presentation_feedback
 */
/* *
 * @ingroup iface_wp_presentation_feedback
 * Sends an sync_output event to the client owning the resource.
 * @param resource_ The client's resource
 * @param output presentation output
 */
#[inline]
unsafe extern "C" fn wp_presentation_feedback_send_sync_output(mut resource_:
                                                                   *mut wl_resource,
                                                               mut output:
                                                                   *mut wl_resource) {
    wl_resource_post_event(resource_, 0i32 as uint32_t, output);
}
/* *
 * @ingroup iface_wp_presentation_feedback
 * Sends an presented event to the client owning the resource.
 * @param resource_ The client's resource
 * @param tv_sec_hi high 32 bits of the seconds part of the presentation timestamp
 * @param tv_sec_lo low 32 bits of the seconds part of the presentation timestamp
 * @param tv_nsec nanoseconds part of the presentation timestamp
 * @param refresh nanoseconds till next refresh
 * @param seq_hi high 32 bits of refresh counter
 * @param seq_lo low 32 bits of refresh counter
 * @param flags combination of 'kind' values
 */
#[inline]
unsafe extern "C" fn wp_presentation_feedback_send_presented(mut resource_:
                                                                 *mut wl_resource,
                                                             mut tv_sec_hi:
                                                                 uint32_t,
                                                             mut tv_sec_lo:
                                                                 uint32_t,
                                                             mut tv_nsec:
                                                                 uint32_t,
                                                             mut refresh:
                                                                 uint32_t,
                                                             mut seq_hi:
                                                                 uint32_t,
                                                             mut seq_lo:
                                                                 uint32_t,
                                                             mut flags:
                                                                 uint32_t) {
    wl_resource_post_event(resource_, 1i32 as uint32_t, tv_sec_hi, tv_sec_lo,
                           tv_nsec, refresh, seq_hi, seq_lo, flags);
}
/* *
 * @ingroup iface_wp_presentation_feedback
 * Sends an discarded event to the client owning the resource.
 * @param resource_ The client's resource
 */
#[inline]
unsafe extern "C" fn wp_presentation_feedback_send_discarded(mut resource_:
                                                                 *mut wl_resource) {
    wl_resource_post_event(resource_, 2i32 as uint32_t);
}
unsafe extern "C" fn feedback_handle_resource_destroy(mut resource:
                                                          *mut wl_resource) {
    wl_list_remove(wl_resource_get_link(resource));
}
unsafe extern "C" fn feedback_resource_send_presented(mut feedback_resource:
                                                          *mut wl_resource,
                                                      mut event:
                                                          *mut wlr_presentation_event) {
    let mut client: *mut wl_client =
        wl_resource_get_client(feedback_resource);
    let mut output_resource: *mut wl_resource = 0 as *mut wl_resource;
    output_resource = 0 as *mut wl_resource;
    output_resource =
        wl_resource_from_link((*(*event).output).resources.next);
    while wl_resource_get_link(output_resource) !=
              &mut (*(*event).output).resources as *mut wl_list {
        if wl_resource_get_client(output_resource) == client {
            wp_presentation_feedback_send_sync_output(feedback_resource,
                                                      output_resource);
        }
        output_resource =
            wl_resource_from_link((*wl_resource_get_link(output_resource)).next)
    }
    let mut tv_sec_hi: uint32_t = ((*event).tv_sec >> 32i32) as uint32_t;
    let mut tv_sec_lo: uint32_t =
        ((*event).tv_sec & 0xffffffffu32 as libc::c_ulong) as uint32_t;
    let mut seq_hi: uint32_t = ((*event).seq >> 32i32) as uint32_t;
    let mut seq_lo: uint32_t =
        ((*event).seq & 0xffffffffu32 as libc::c_ulong) as uint32_t;
    wp_presentation_feedback_send_presented(feedback_resource, tv_sec_hi,
                                            tv_sec_lo, (*event).tv_nsec,
                                            (*event).refresh, seq_hi, seq_lo,
                                            (*event).flags);
    wl_resource_destroy(feedback_resource);
}
unsafe extern "C" fn feedback_resource_send_discarded(mut feedback_resource:
                                                          *mut wl_resource) {
    wp_presentation_feedback_send_discarded(feedback_resource);
    wl_resource_destroy(feedback_resource);
}
unsafe extern "C" fn feedback_handle_surface_commit(mut listener:
                                                        *mut wl_listener,
                                                    mut data:
                                                        *mut libc::c_void) {
    let mut feedback: *mut wlr_presentation_feedback =
        (listener as *mut libc::c_char).offset(-72) as
            *mut wlr_presentation_feedback;
    if (*feedback).committed {
        if !(*feedback).sampled {
            // The content update has been superseded
            wlr_presentation_feedback_destroy(feedback);
        }
    } else { (*feedback).committed = 1i32 != 0 };
}
unsafe extern "C" fn feedback_unset_surface(mut feedback:
                                                *mut wlr_presentation_feedback) {
    if (*feedback).surface.is_null() { return }
    (*feedback).surface = 0 as *mut wlr_surface;
    wl_list_remove(&mut (*feedback).surface_commit.link);
    wl_list_remove(&mut (*feedback).surface_destroy.link);
}
unsafe extern "C" fn feedback_handle_surface_destroy(mut listener:
                                                         *mut wl_listener,
                                                     mut data:
                                                         *mut libc::c_void) {
    let mut feedback: *mut wlr_presentation_feedback =
        (listener as *mut libc::c_char).offset(-96) as
            *mut wlr_presentation_feedback;
    if (*feedback).sampled {
        // The compositor might have a handle on this feedback
        feedback_unset_surface(feedback);
    } else { wlr_presentation_feedback_destroy(feedback); };
}
unsafe extern "C" fn presentation_from_resource(mut resource:
                                                    *mut wl_resource)
 -> *mut wlr_presentation {
    if wl_resource_instance_of(resource, &wp_presentation_interface,
                               &presentation_impl as
                                   *const wp_presentation_interface as
                                   *const libc::c_void) != 0 {
    } else {
        __assert_fail(b"wl_resource_instance_of(resource, &wp_presentation_interface, &presentation_impl)\x00"
                          as *const u8 as *const libc::c_char,
                      b"../types/wlr_presentation_time.c\x00" as *const u8 as
                          *const libc::c_char, 88i32 as libc::c_uint,
                      (*::std::mem::transmute::<&[u8; 74],
                                                &[libc::c_char; 74]>(b"struct wlr_presentation *presentation_from_resource(struct wl_resource *)\x00")).as_ptr());
    };
    return wl_resource_get_user_data(resource) as *mut wlr_presentation;
}
unsafe extern "C" fn presentation_handle_feedback(mut client: *mut wl_client,
                                                  mut presentation_resource:
                                                      *mut wl_resource,
                                                  mut surface_resource:
                                                      *mut wl_resource,
                                                  mut id: uint32_t) {
    let mut presentation: *mut wlr_presentation =
        presentation_from_resource(presentation_resource);
    let mut surface: *mut wlr_surface =
        wlr_surface_from_resource(surface_resource);
    let mut found: bool = 0i32 != 0;
    let mut feedback: *mut wlr_presentation_feedback =
        0 as *mut wlr_presentation_feedback;
    feedback =
        ((*presentation).feedbacks.next as *mut libc::c_char).offset(-16) as
            *mut wlr_presentation_feedback;
    while &mut (*feedback).link as *mut wl_list !=
              &mut (*presentation).feedbacks as *mut wl_list {
        if (*feedback).surface == surface && !(*feedback).committed {
            found = 1i32 != 0;
            break ;
        } else {
            feedback =
                ((*feedback).link.next as *mut libc::c_char).offset(-16) as
                    *mut wlr_presentation_feedback
        }
    }
    if !found {
        feedback =
            calloc(1i32 as libc::c_ulong,
                   ::std::mem::size_of::<wlr_presentation_feedback>() as
                       libc::c_ulong) as *mut wlr_presentation_feedback;
        if feedback.is_null() { wl_client_post_no_memory(client); return }
        (*feedback).surface = surface;
        wl_list_init(&mut (*feedback).resources);
        (*feedback).surface_commit.notify =
            Some(feedback_handle_surface_commit as
                     unsafe extern "C" fn(_: *mut wl_listener,
                                          _: *mut libc::c_void) -> ());
        wl_signal_add(&mut (*surface).events.commit,
                      &mut (*feedback).surface_commit);
        (*feedback).surface_destroy.notify =
            Some(feedback_handle_surface_destroy as
                     unsafe extern "C" fn(_: *mut wl_listener,
                                          _: *mut libc::c_void) -> ());
        wl_signal_add(&mut (*surface).events.destroy,
                      &mut (*feedback).surface_destroy);
        wl_list_insert(&mut (*presentation).feedbacks, &mut (*feedback).link);
    }
    let mut version: uint32_t =
        wl_resource_get_version(presentation_resource) as uint32_t;
    let mut resource: *mut wl_resource =
        wl_resource_create(client, &wp_presentation_feedback_interface,
                           version as libc::c_int, id);
    if resource.is_null() { wl_client_post_no_memory(client); return }
    wl_resource_set_implementation(resource, 0 as *const libc::c_void,
                                   feedback as *mut libc::c_void,
                                   Some(feedback_handle_resource_destroy as
                                            unsafe extern "C" fn(_:
                                                                     *mut wl_resource)
                                                -> ()));
    wl_list_insert(&mut (*feedback).resources,
                   wl_resource_get_link(resource));
}
unsafe extern "C" fn presentation_handle_destroy(mut client: *mut wl_client,
                                                 mut resource:
                                                     *mut wl_resource) {
    wl_resource_destroy(resource);
}
static mut presentation_impl: wp_presentation_interface =
    {
    
        {
            let mut init =
                wp_presentation_interface{destroy:
                                              Some(presentation_handle_destroy
                                                       as
                                                       unsafe extern "C" fn(_:
                                                                                *mut wl_client,
                                                                            _:
                                                                                *mut wl_resource)
                                                           -> ()),
                                          feedback:
                                              Some(presentation_handle_feedback
                                                       as
                                                       unsafe extern "C" fn(_:
                                                                                *mut wl_client,
                                                                            _:
                                                                                *mut wl_resource,
                                                                            _:
                                                                                *mut wl_resource,
                                                                            _:
                                                                                uint32_t)
                                                           -> ()),};
            init
        }
};
unsafe extern "C" fn presentation_bind(mut client: *mut wl_client,
                                       mut data: *mut libc::c_void,
                                       mut version: uint32_t,
                                       mut id: uint32_t) {
    let mut presentation: *mut wlr_presentation =
        data as *mut wlr_presentation;
    let mut resource: *mut wl_resource =
        wl_resource_create(client, &wp_presentation_interface,
                           version as libc::c_int, id);
    if resource.is_null() { wl_client_post_no_memory(client); return }
    wl_resource_set_implementation(resource,
                                   &presentation_impl as
                                       *const wp_presentation_interface as
                                       *const libc::c_void,
                                   presentation as *mut libc::c_void, None);
    wp_presentation_send_clock_id(resource,
                                  (*presentation).clock as uint32_t);
}
unsafe extern "C" fn handle_display_destroy(mut listener: *mut wl_listener,
                                            mut data: *mut libc::c_void) {
    let mut presentation: *mut wlr_presentation =
        (listener as *mut libc::c_char).offset(-48) as *mut wlr_presentation;
    wlr_signal_emit_safe(&mut (*presentation).events.destroy,
                         presentation as *mut libc::c_void);
    wl_list_remove(&mut (*presentation).display_destroy.link);
    wl_global_destroy((*presentation).global);
    free(presentation as *mut libc::c_void);
}
#[no_mangle]
pub unsafe extern "C" fn wlr_presentation_create(mut display: *mut wl_display,
                                                 mut backend:
                                                     *mut wlr_backend)
 -> *mut wlr_presentation {
    let mut presentation: *mut wlr_presentation =
        calloc(1i32 as libc::c_ulong,
               ::std::mem::size_of::<wlr_presentation>() as libc::c_ulong) as
            *mut wlr_presentation;
    if presentation.is_null() { return 0 as *mut wlr_presentation }
    (*presentation).global =
        wl_global_create(display, &wp_presentation_interface, 1i32,
                         presentation as *mut libc::c_void,
                         Some(presentation_bind as
                                  unsafe extern "C" fn(_: *mut wl_client,
                                                       _: *mut libc::c_void,
                                                       _: uint32_t,
                                                       _: uint32_t) -> ()));
    if (*presentation).global.is_null() {
        free(presentation as *mut libc::c_void);
        return 0 as *mut wlr_presentation
    }
    (*presentation).clock = wlr_backend_get_presentation_clock(backend);
    wl_list_init(&mut (*presentation).feedbacks);
    wl_signal_init(&mut (*presentation).events.destroy);
    (*presentation).display_destroy.notify =
        Some(handle_display_destroy as
                 unsafe extern "C" fn(_: *mut wl_listener,
                                      _: *mut libc::c_void) -> ());
    wl_display_add_destroy_listener(display,
                                    &mut (*presentation).display_destroy);
    return presentation;
}
#[no_mangle]
pub unsafe extern "C" fn wlr_presentation_feedback_send_presented(mut feedback:
                                                                      *mut wlr_presentation_feedback,
                                                                  mut event:
                                                                      *mut wlr_presentation_event) {
    let mut resource: *mut wl_resource = 0 as *mut wl_resource;
    let mut tmp: *mut wl_resource = 0 as *mut wl_resource;
    resource = 0 as *mut wl_resource;
    tmp = 0 as *mut wl_resource;
    resource = wl_resource_from_link((*feedback).resources.next);
    tmp = wl_resource_from_link((*(*feedback).resources.next).next);
    while wl_resource_get_link(resource) !=
              &mut (*feedback).resources as *mut wl_list {
        feedback_resource_send_presented(resource, event);
        resource = tmp;
        tmp = wl_resource_from_link((*wl_resource_get_link(resource)).next)
    }
    (*feedback).presented = 1i32 != 0;
}
#[no_mangle]
pub unsafe extern "C" fn wlr_presentation_surface_sampled(mut presentation:
                                                              *mut wlr_presentation,
                                                          mut surface:
                                                              *mut wlr_surface)
 -> *mut wlr_presentation_feedback {
    // TODO: maybe use a hashtable to optimize this function
    let mut feedback: *mut wlr_presentation_feedback =
        0 as *mut wlr_presentation_feedback;
    let mut feedback_tmp: *mut wlr_presentation_feedback =
        0 as *mut wlr_presentation_feedback;
    feedback =
        ((*presentation).feedbacks.next as *mut libc::c_char).offset(-16) as
            *mut wlr_presentation_feedback;
    feedback_tmp =
        ((*feedback).link.next as *mut libc::c_char).offset(-16) as
            *mut wlr_presentation_feedback;
    while &mut (*feedback).link as *mut wl_list !=
              &mut (*presentation).feedbacks as *mut wl_list {
        if (*feedback).surface == surface &&
               (*feedback).committed as libc::c_int != 0 &&
               !(*feedback).sampled {
            (*feedback).sampled = 1i32 != 0;
            return feedback
        }
        feedback = feedback_tmp;
        feedback_tmp =
            ((*feedback).link.next as *mut libc::c_char).offset(-16) as
                *mut wlr_presentation_feedback
    }
    return 0 as *mut wlr_presentation_feedback;
}
#[no_mangle]
pub unsafe extern "C" fn wlr_presentation_feedback_destroy(mut feedback:
                                                               *mut wlr_presentation_feedback) {
    if feedback.is_null() { return }
    if !(*feedback).presented {
        let mut resource: *mut wl_resource = 0 as *mut wl_resource;
        let mut tmp: *mut wl_resource = 0 as *mut wl_resource;
        resource = 0 as *mut wl_resource;
        tmp = 0 as *mut wl_resource;
        resource = wl_resource_from_link((*feedback).resources.next);
        tmp = wl_resource_from_link((*(*feedback).resources.next).next);
        while wl_resource_get_link(resource) !=
                  &mut (*feedback).resources as *mut wl_list {
            feedback_resource_send_discarded(resource);
            resource = tmp;
            tmp =
                wl_resource_from_link((*wl_resource_get_link(resource)).next)
        }
    }
    if wl_list_empty(&mut (*feedback).resources) != 0 {
    } else {
        __assert_fail(b"wl_list_empty(&feedback->resources)\x00" as *const u8
                          as *const libc::c_char,
                      b"../types/wlr_presentation_time.c\x00" as *const u8 as
                          *const libc::c_char, 240i32 as libc::c_uint,
                      (*::std::mem::transmute::<&[u8; 75],
                                                &[libc::c_char; 75]>(b"void wlr_presentation_feedback_destroy(struct wlr_presentation_feedback *)\x00")).as_ptr());
    };
    feedback_unset_surface(feedback);
    feedback_unset_output(feedback);
    wl_list_remove(&mut (*feedback).link);
    free(feedback as *mut libc::c_void);
}
#[no_mangle]
pub unsafe extern "C" fn wlr_presentation_event_from_output(mut event:
                                                                *mut wlr_presentation_event,
                                                            mut output_event:
                                                                *const wlr_output_event_present) {
    memset(event as *mut libc::c_void, 0i32,
           ::std::mem::size_of::<wlr_presentation_event>() as libc::c_ulong);
    (*event).output = (*output_event).output;
    (*event).tv_sec = (*(*output_event).when).tv_sec as uint64_t;
    (*event).tv_nsec = (*(*output_event).when).tv_nsec as uint32_t;
    (*event).refresh = (*output_event).refresh as uint32_t;
    (*event).seq = (*output_event).seq as uint64_t;
    (*event).flags = (*output_event).flags;
}
unsafe extern "C" fn feedback_unset_output(mut feedback:
                                               *mut wlr_presentation_feedback) {
    if (*feedback).output.is_null() { return }
    (*feedback).output = 0 as *mut wlr_output;
    wl_list_remove(&mut (*feedback).output_commit.link);
    wl_list_remove(&mut (*feedback).output_present.link);
    wl_list_remove(&mut (*feedback).output_destroy.link);
}
unsafe extern "C" fn feedback_handle_output_commit(mut listener:
                                                       *mut wl_listener,
                                                   mut data:
                                                       *mut libc::c_void) {
    let mut feedback: *mut wlr_presentation_feedback =
        (listener as *mut libc::c_char).offset(-120) as
            *mut wlr_presentation_feedback;
    if (*feedback).output_committed { return }
    (*feedback).output_committed = 1i32 != 0;
    (*feedback).output_commit_seq = (*(*feedback).output).commit_seq;
}
unsafe extern "C" fn feedback_handle_output_present(mut listener:
                                                        *mut wl_listener,
                                                    mut data:
                                                        *mut libc::c_void) {
    let mut feedback: *mut wlr_presentation_feedback =
        (listener as *mut libc::c_char).offset(-144) as
            *mut wlr_presentation_feedback;
    let mut output_event: *mut wlr_output_event_present =
        data as *mut wlr_output_event_present;
    if !(*feedback).output_committed ||
           (*output_event).commit_seq != (*feedback).output_commit_seq {
        return
    }
    let mut event: wlr_presentation_event =
        {
            let mut init =
                wlr_presentation_event{output: 0 as *mut wlr_output,
                                       tv_sec: 0,
                                       tv_nsec: 0,
                                       refresh: 0,
                                       seq: 0,
                                       flags: 0,};
            init
        };
    wlr_presentation_event_from_output(&mut event, output_event);
    wlr_presentation_feedback_send_presented(feedback, &mut event);
    wlr_presentation_feedback_destroy(feedback);
}
unsafe extern "C" fn feedback_handle_output_destroy(mut listener:
                                                        *mut wl_listener,
                                                    mut data:
                                                        *mut libc::c_void) {
    let mut feedback: *mut wlr_presentation_feedback =
        (listener as *mut libc::c_char).offset(-168) as
            *mut wlr_presentation_feedback;
    wlr_presentation_feedback_destroy(feedback);
}
#[no_mangle]
pub unsafe extern "C" fn wlr_presentation_surface_sampled_on_output(mut presentation:
                                                                        *mut wlr_presentation,
                                                                    mut surface:
                                                                        *mut wlr_surface,
                                                                    mut output:
                                                                        *mut wlr_output) {
    let mut feedback: *mut wlr_presentation_feedback =
        wlr_presentation_surface_sampled(presentation, surface);
    if feedback.is_null() { return }
    if (*feedback).output.is_null() {
    } else {
        __assert_fail(b"feedback->output == NULL\x00" as *const u8 as
                          *const libc::c_char,
                      b"../types/wlr_presentation_time.c\x00" as *const u8 as
                          *const libc::c_char, 314i32 as libc::c_uint,
                      (*::std::mem::transmute::<&[u8; 118],
                                                &[libc::c_char; 118]>(b"void wlr_presentation_surface_sampled_on_output(struct wlr_presentation *, struct wlr_surface *, struct wlr_output *)\x00")).as_ptr());
    };
    (*feedback).output = output;
    (*feedback).output_commit.notify =
        Some(feedback_handle_output_commit as
                 unsafe extern "C" fn(_: *mut wl_listener,
                                      _: *mut libc::c_void) -> ());
    wl_signal_add(&mut (*output).events.commit,
                  &mut (*feedback).output_commit);
    (*feedback).output_present.notify =
        Some(feedback_handle_output_present as
                 unsafe extern "C" fn(_: *mut wl_listener,
                                      _: *mut libc::c_void) -> ());
    wl_signal_add(&mut (*output).events.present,
                  &mut (*feedback).output_present);
    (*feedback).output_destroy.notify =
        Some(feedback_handle_output_destroy as
                 unsafe extern "C" fn(_: *mut wl_listener,
                                      _: *mut libc::c_void) -> ());
    wl_signal_add(&mut (*output).events.destroy,
                  &mut (*feedback).output_destroy);
}
