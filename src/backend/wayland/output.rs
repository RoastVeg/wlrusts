use libc;
extern "C" {
    pub type wl_proxy;
    pub type wl_display;
    /* Generated by wayland-scanner 1.17.0 */
    /* *
 * @page page_linux_dmabuf_unstable_v1 The linux_dmabuf_unstable_v1 protocol
 * @section page_ifaces_linux_dmabuf_unstable_v1 Interfaces
 * - @subpage page_iface_zwp_linux_dmabuf_v1 - factory for creating dmabuf-based wl_buffers
 * - @subpage page_iface_zwp_linux_buffer_params_v1 - parameters for creating a dmabuf-based wl_buffer
 * @section page_copyright_linux_dmabuf_unstable_v1 Copyright
 * <pre>
 *
 * Copyright © 2014, 2015 Collabora, Ltd.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 * </pre>
 */
    pub type wl_buffer;
    pub type wl_callback;
    pub type wl_compositor;
    pub type wl_keyboard;
    /* Generated by wayland-scanner 1.17.0 */
    /* *
 * @page page_presentation_time The presentation_time protocol
 * @section page_ifaces_presentation_time Interfaces
 * - @subpage page_iface_wp_presentation - timed presentation related wl_surface requests
 * - @subpage page_iface_wp_presentation_feedback - presentation time feedback event
 * @section page_copyright_presentation_time Copyright
 * <pre>
 *
 * Copyright © 2013-2014 Collabora, Ltd.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 * </pre>
 */
    /* Generated by wayland-scanner 1.17.0 */
    /* *
 * @page page_xdg_shell The xdg_shell protocol
 * @section page_ifaces_xdg_shell Interfaces
 * - @subpage page_iface_xdg_wm_base - create desktop-style surfaces
 * - @subpage page_iface_xdg_positioner - child surface positioner
 * - @subpage page_iface_xdg_surface - desktop user interface surface base interface
 * - @subpage page_iface_xdg_toplevel - toplevel surface
 * - @subpage page_iface_xdg_popup - short-lived, popup surfaces for menus
 * @section page_copyright_xdg_shell Copyright
 * <pre>
 *
 * Copyright © 2008-2013 Kristian Høgsberg
 * Copyright © 2013      Rafael Antognolli
 * Copyright © 2013      Jasper St. Pierre
 * Copyright © 2010-2013 Intel Corporation
 * Copyright © 2015-2017 Samsung Electronics Co., Ltd
 * Copyright © 2015-2017 Red Hat Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 * </pre>
 */
    pub type wl_output;
    pub type wl_pointer;
    pub type wl_registry;
    pub type wl_seat;
    pub type wl_surface;
    pub type wl_event_source;
    pub type wl_client;
    pub type wl_global;
    /*
 * This an unstable interface of wlroots. No guarantees are made regarding the
 * future consistency of this API.
 */
    pub type wlr_backend_impl;
    pub type wlr_renderer_impl;
    /*
 * This an unstable interface of wlroots. No guarantees are made regarding the
 * future consistency of this API.
 */
    pub type wlr_texture_impl;
    pub type wlr_surface;
    pub type wl_egl_window;
    pub type xkb_keymap;
    pub type xkb_state;
    pub type wlr_keyboard_impl;
    pub type wlr_keyboard_group;
    pub type wlr_pointer_impl;
    pub type wlr_tablet_pad_impl;
    pub type wlr_tablet_impl;
    pub type wlr_touch_impl;
    pub type wlr_switch_impl;
    /* Note: these are circular dependencies */
    pub type wlr_input_device_impl;
    pub type wp_presentation_feedback;
    pub type zxdg_toplevel_decoration_v1;
    /* Generated by wayland-scanner 1.17.0 */
    /* *
 * @page page_xdg_decoration_unstable_v1 The xdg_decoration_unstable_v1 protocol
 * @section page_ifaces_xdg_decoration_unstable_v1 Interfaces
 * - @subpage page_iface_zxdg_decoration_manager_v1 - window decoration manager
 * - @subpage page_iface_zxdg_toplevel_decoration_v1 - decoration object for a toplevel surface
 * @section page_copyright_xdg_decoration_unstable_v1 Copyright
 * <pre>
 *
 * Copyright © 2018 Simon Ser
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 * </pre>
 */
    pub type xdg_toplevel;
    pub type xdg_surface;
    pub type zwp_tablet_manager_v2;
    pub type zwp_relative_pointer_v1;
    pub type zwp_pointer_gesture_pinch_v1;
    pub type zwp_pointer_gesture_swipe_v1;
    pub type zwp_relative_pointer_manager_v1;
    pub type zwp_linux_dmabuf_v1;
    pub type wp_presentation;
    pub type zwp_pointer_gestures_v1;
    pub type zxdg_decoration_manager_v1;
    pub type xdg_wm_base;
    pub type zwp_linux_buffer_params_v1;
    #[no_mangle]
    fn __assert_fail(__assertion: *const libc::c_char,
                     __file: *const libc::c_char, __line: libc::c_uint,
                     __function: *const libc::c_char) -> !;
    #[no_mangle]
    fn snprintf(_: *mut libc::c_char, _: libc::c_ulong,
                _: *const libc::c_char, _: ...) -> libc::c_int;
    #[no_mangle]
    fn calloc(_: libc::c_ulong, _: libc::c_ulong) -> *mut libc::c_void;
    #[no_mangle]
    fn free(__ptr: *mut libc::c_void);
    #[no_mangle]
    fn strncpy(_: *mut libc::c_char, _: *const libc::c_char, _: libc::c_ulong)
     -> *mut libc::c_char;
    #[no_mangle]
    fn strerror(_: libc::c_int) -> *mut libc::c_char;
    #[no_mangle]
    fn wl_list_init(list: *mut wl_list);
    #[no_mangle]
    fn wl_proxy_marshal(p: *mut wl_proxy, opcode: uint32_t, _: ...);
    #[no_mangle]
    fn wl_proxy_marshal_constructor(proxy: *mut wl_proxy, opcode: uint32_t,
                                    interface: *const wl_interface, _: ...)
     -> *mut wl_proxy;
    #[no_mangle]
    fn wl_proxy_destroy(proxy: *mut wl_proxy);
    #[no_mangle]
    fn wl_proxy_add_listener(proxy: *mut wl_proxy,
                             implementation:
                                 *mut Option<unsafe extern "C" fn() -> ()>,
                             data: *mut libc::c_void) -> libc::c_int;
    #[no_mangle]
    fn wl_proxy_set_user_data(proxy: *mut wl_proxy,
                              user_data: *mut libc::c_void);
    #[no_mangle]
    fn wl_display_roundtrip(display: *mut wl_display) -> libc::c_int;
    #[no_mangle]
    static wl_callback_interface: wl_interface;
    #[no_mangle]
    static wl_buffer_interface: wl_interface;
    #[no_mangle]
    static wl_surface_interface: wl_interface;
    #[no_mangle]
    fn wl_list_insert(list: *mut wl_list, elm: *mut wl_list);
    #[no_mangle]
    fn wl_list_remove(elm: *mut wl_list);
    /*
 * This an unstable interface of wlroots. No guarantees are made regarding the
 * future consistency of this API.
 */
    #[no_mangle]
    fn wlr_output_send_present(output: *mut wlr_output,
                               event: *mut wlr_output_event_present);
    #[no_mangle]
    fn wlr_output_send_frame(output: *mut wlr_output);
    #[no_mangle]
    fn wlr_output_update_enabled(output: *mut wlr_output, enabled: bool);
    #[no_mangle]
    fn wlr_output_update_custom_mode(output: *mut wlr_output, width: int32_t,
                                     height: int32_t, refresh: int32_t);
    #[no_mangle]
    fn wlr_output_init(output: *mut wlr_output, backend: *mut wlr_backend,
                       impl_0: *const wlr_output_impl,
                       display: *mut wl_display);
    #[no_mangle]
    fn wlr_output_transform_invert(tr: wl_output_transform)
     -> wl_output_transform;
    #[no_mangle]
    fn pixman_region32_rectangles(region: *mut pixman_region32_t,
                                  n_rects: *mut libc::c_int)
     -> *mut pixman_box32_t;
    #[no_mangle]
    fn wlr_drm_format_set_has(set: *const wlr_drm_format_set,
                              format: uint32_t, modifier: uint64_t) -> bool;
    /* *
 * Returns a surface for the given native window
 * The window must match the remote display the wlr_egl was created with.
 */
    #[no_mangle]
    fn wlr_egl_create_surface(egl: *mut wlr_egl, window: *mut libc::c_void)
     -> EGLSurface;
    #[no_mangle]
    fn wlr_egl_make_current(egl: *mut wlr_egl, surface: EGLSurface,
                            buffer_age: *mut libc::c_int) -> bool;
    #[no_mangle]
    fn wlr_egl_swap_buffers(egl: *mut wlr_egl, surface: EGLSurface,
                            damage: *mut pixman_region32_t) -> bool;
    #[no_mangle]
    fn wlr_egl_destroy_surface(egl: *mut wlr_egl, surface: EGLSurface)
     -> bool;
    /* *
 * Transforms a box inside a `width` x `height` box.
 */
    #[no_mangle]
    fn wlr_box_transform(dest: *mut wlr_box, box_0: *const wlr_box,
                         transform: wl_output_transform, width: libc::c_int,
                         height: libc::c_int);
    /* *
 * Reference the buffer.
 */
    #[no_mangle]
    fn wlr_buffer_ref(buffer: *mut wlr_buffer) -> *mut wlr_buffer;
    /* *
 * Unreference the buffer. After this call, `buffer` may not be accessed
 * anymore.
 */
    #[no_mangle]
    fn wlr_buffer_unref(buffer: *mut wlr_buffer);
    /* *
 * Reads the DMA-BUF attributes of the buffer. If this buffer isn't a DMA-BUF,
 * returns false.
 */
    #[no_mangle]
    fn wlr_buffer_get_dmabuf(buffer: *mut wlr_buffer,
                             attribs: *mut wlr_dmabuf_attributes) -> bool;
    #[no_mangle]
    fn wlr_output_destroy(output: *mut wlr_output);
    #[no_mangle]
    fn wlr_renderer_begin(r: *mut wlr_renderer, width: libc::c_int,
                          height: libc::c_int);
    #[no_mangle]
    fn wlr_renderer_end(r: *mut wlr_renderer);
    #[no_mangle]
    fn wlr_renderer_clear(r: *mut wlr_renderer, color: *const libc::c_float);
    /* *
 * Renders the requested texture using the provided matrix.
 */
    #[no_mangle]
    fn wlr_render_texture_with_matrix(r: *mut wlr_renderer,
                                      texture: *mut wlr_texture,
                                      matrix: *const libc::c_float,
                                      alpha: libc::c_float) -> bool;
    #[no_mangle]
    fn wlr_texture_get_size(texture: *mut wlr_texture,
                            width: *mut libc::c_int,
                            height: *mut libc::c_int);
    /* * Writes a 2D orthographic projection matrix to mat of (width, height) with a
 *  specified wl_output_transform*/
    #[no_mangle]
    fn wlr_matrix_projection(mat: *mut libc::c_float, width: libc::c_int,
                             height: libc::c_int,
                             transform: wl_output_transform);
    /* * Shortcut for the various matrix operations involved in projecting the
 *  specified wlr_box onto a given orthographic projection with a given
 *  rotation. The result is written to mat, which can be applied to each
 *  coordinate of the box to get a new coordinate from [-1,1]. */
    #[no_mangle]
    fn wlr_matrix_project_box(mat: *mut libc::c_float, box_0: *const wlr_box,
                              transform: wl_output_transform,
                              rotation: libc::c_float,
                              projection: *const libc::c_float);
    #[no_mangle]
    fn __errno_location() -> *mut libc::c_int;
    #[no_mangle]
    fn _wlr_log(verbosity: wlr_log_importance, format: *const libc::c_char,
                _: ...);
    #[no_mangle]
    fn get_wl_backend_from_backend(backend: *mut wlr_backend)
     -> *mut wlr_wl_backend;
    #[no_mangle]
    fn create_wl_pointer(wl_pointer: *mut wl_pointer,
                         output: *mut wlr_wl_output);
    #[no_mangle]
    fn wl_egl_window_resize(egl_window: *mut wl_egl_window,
                            width: libc::c_int, height: libc::c_int,
                            dx: libc::c_int, dy: libc::c_int);
    #[no_mangle]
    fn wl_egl_window_destroy(egl_window: *mut wl_egl_window);
    #[no_mangle]
    fn wl_egl_window_create(surface: *mut wl_surface, width: libc::c_int,
                            height: libc::c_int) -> *mut wl_egl_window;
    #[no_mangle]
    fn wlr_signal_emit_safe(signal: *mut wl_signal, data: *mut libc::c_void);
    /* *
 * @page page_iface_zwp_linux_buffer_params_v1 zwp_linux_buffer_params_v1
 * @section page_iface_zwp_linux_buffer_params_v1_desc Description
 *
 * This temporary object is a collection of dmabufs and other
 * parameters that together form a single logical buffer. The temporary
 * object may eventually create one wl_buffer unless cancelled by
 * destroying it before requesting 'create'.
 *
 * Single-planar formats only require one dmabuf, however
 * multi-planar formats may require more than one dmabuf. For all
 * formats, an 'add' request must be called once per plane (even if the
 * underlying dmabuf fd is identical).
 *
 * You must use consecutive plane indices ('plane_idx' argument for 'add')
 * from zero to the number of planes used by the drm_fourcc format code.
 * All planes required by the format must be given exactly once, but can
 * be given in any order. Each plane index can be set only once.
 * @section page_iface_zwp_linux_buffer_params_v1_api API
 * See @ref iface_zwp_linux_buffer_params_v1.
 */
/* *
 * @defgroup iface_zwp_linux_buffer_params_v1 The zwp_linux_buffer_params_v1 interface
 *
 * This temporary object is a collection of dmabufs and other
 * parameters that together form a single logical buffer. The temporary
 * object may eventually create one wl_buffer unless cancelled by
 * destroying it before requesting 'create'.
 *
 * Single-planar formats only require one dmabuf, however
 * multi-planar formats may require more than one dmabuf. For all
 * formats, an 'add' request must be called once per plane (even if the
 * underlying dmabuf fd is identical).
 *
 * You must use consecutive plane indices ('plane_idx' argument for 'add')
 * from zero to the number of planes used by the drm_fourcc format code.
 * All planes required by the format must be given exactly once, but can
 * be given in any order. Each plane index can be set only once.
 */
    #[no_mangle]
    static zwp_linux_buffer_params_v1_interface: wl_interface;
    /* *
 * @page page_iface_wp_presentation_feedback wp_presentation_feedback
 * @section page_iface_wp_presentation_feedback_desc Description
 *
 * A presentation_feedback object returns an indication that a
 * wl_surface content update has become visible to the user.
 * One object corresponds to one content update submission
 * (wl_surface.commit). There are two possible outcomes: the
 * content update is presented to the user, and a presentation
 * timestamp delivered; or, the user did not see the content
 * update because it was superseded or its surface destroyed,
 * and the content update is discarded.
 *
 * Once a presentation_feedback object has delivered a 'presented'
 * or 'discarded' event it is automatically destroyed.
 * @section page_iface_wp_presentation_feedback_api API
 * See @ref iface_wp_presentation_feedback.
 */
/* *
 * @defgroup iface_wp_presentation_feedback The wp_presentation_feedback interface
 *
 * A presentation_feedback object returns an indication that a
 * wl_surface content update has become visible to the user.
 * One object corresponds to one content update submission
 * (wl_surface.commit). There are two possible outcomes: the
 * content update is presented to the user, and a presentation
 * timestamp delivered; or, the user did not see the content
 * update because it was superseded or its surface destroyed,
 * and the content update is discarded.
 *
 * Once a presentation_feedback object has delivered a 'presented'
 * or 'discarded' event it is automatically destroyed.
 */
    #[no_mangle]
    static wp_presentation_feedback_interface: wl_interface;
    /* *
 * @page page_iface_zxdg_toplevel_decoration_v1 zxdg_toplevel_decoration_v1
 * @section page_iface_zxdg_toplevel_decoration_v1_desc Description
 *
 * The decoration object allows the compositor to toggle server-side window
 * decorations for a toplevel surface. The client can request to switch to
 * another mode.
 *
 * The xdg_toplevel_decoration object must be destroyed before its
 * xdg_toplevel.
 * @section page_iface_zxdg_toplevel_decoration_v1_api API
 * See @ref iface_zxdg_toplevel_decoration_v1.
 */
/* *
 * @defgroup iface_zxdg_toplevel_decoration_v1 The zxdg_toplevel_decoration_v1 interface
 *
 * The decoration object allows the compositor to toggle server-side window
 * decorations for a toplevel surface. The client can request to switch to
 * another mode.
 *
 * The xdg_toplevel_decoration object must be destroyed before its
 * xdg_toplevel.
 */
    #[no_mangle]
    static zxdg_toplevel_decoration_v1_interface: wl_interface;
    /* *
 * @page page_iface_xdg_surface xdg_surface
 * @section page_iface_xdg_surface_desc Description
 *
 * An interface that may be implemented by a wl_surface, for
 * implementations that provide a desktop-style user interface.
 *
 * It provides a base set of functionality required to construct user
 * interface elements requiring management by the compositor, such as
 * toplevel windows, menus, etc. The types of functionality are split into
 * xdg_surface roles.
 *
 * Creating an xdg_surface does not set the role for a wl_surface. In order
 * to map an xdg_surface, the client must create a role-specific object
 * using, e.g., get_toplevel, get_popup. The wl_surface for any given
 * xdg_surface can have at most one role, and may not be assigned any role
 * not based on xdg_surface.
 *
 * A role must be assigned before any other requests are made to the
 * xdg_surface object.
 *
 * The client must call wl_surface.commit on the corresponding wl_surface
 * for the xdg_surface state to take effect.
 *
 * Creating an xdg_surface from a wl_surface which has a buffer attached or
 * committed is a client error, and any attempts by a client to attach or
 * manipulate a buffer prior to the first xdg_surface.configure call must
 * also be treated as errors.
 *
 * Mapping an xdg_surface-based role surface is defined as making it
 * possible for the surface to be shown by the compositor. Note that
 * a mapped surface is not guaranteed to be visible once it is mapped.
 *
 * For an xdg_surface to be mapped by the compositor, the following
 * conditions must be met:
 * (1) the client has assigned an xdg_surface-based role to the surface
 * (2) the client has set and committed the xdg_surface state and the
 * role-dependent state to the surface
 * (3) the client has committed a buffer to the surface
 *
 * A newly-unmapped surface is considered to have met condition (1) out
 * of the 3 required conditions for mapping a surface if its role surface
 * has not been destroyed.
 * @section page_iface_xdg_surface_api API
 * See @ref iface_xdg_surface.
 */
/* *
 * @defgroup iface_xdg_surface The xdg_surface interface
 *
 * An interface that may be implemented by a wl_surface, for
 * implementations that provide a desktop-style user interface.
 *
 * It provides a base set of functionality required to construct user
 * interface elements requiring management by the compositor, such as
 * toplevel windows, menus, etc. The types of functionality are split into
 * xdg_surface roles.
 *
 * Creating an xdg_surface does not set the role for a wl_surface. In order
 * to map an xdg_surface, the client must create a role-specific object
 * using, e.g., get_toplevel, get_popup. The wl_surface for any given
 * xdg_surface can have at most one role, and may not be assigned any role
 * not based on xdg_surface.
 *
 * A role must be assigned before any other requests are made to the
 * xdg_surface object.
 *
 * The client must call wl_surface.commit on the corresponding wl_surface
 * for the xdg_surface state to take effect.
 *
 * Creating an xdg_surface from a wl_surface which has a buffer attached or
 * committed is a client error, and any attempts by a client to attach or
 * manipulate a buffer prior to the first xdg_surface.configure call must
 * also be treated as errors.
 *
 * Mapping an xdg_surface-based role surface is defined as making it
 * possible for the surface to be shown by the compositor. Note that
 * a mapped surface is not guaranteed to be visible once it is mapped.
 *
 * For an xdg_surface to be mapped by the compositor, the following
 * conditions must be met:
 * (1) the client has assigned an xdg_surface-based role to the surface
 * (2) the client has set and committed the xdg_surface state and the
 * role-dependent state to the surface
 * (3) the client has committed a buffer to the surface
 *
 * A newly-unmapped surface is considered to have met condition (1) out
 * of the 3 required conditions for mapping a surface if its role surface
 * has not been destroyed.
 */
    #[no_mangle]
    static xdg_surface_interface: wl_interface;
    /* *
 * @page page_iface_xdg_toplevel xdg_toplevel
 * @section page_iface_xdg_toplevel_desc Description
 *
 * This interface defines an xdg_surface role which allows a surface to,
 * among other things, set window-like properties such as maximize,
 * fullscreen, and minimize, set application-specific metadata like title and
 * id, and well as trigger user interactive operations such as interactive
 * resize and move.
 *
 * Unmapping an xdg_toplevel means that the surface cannot be shown
 * by the compositor until it is explicitly mapped again.
 * All active operations (e.g., move, resize) are canceled and all
 * attributes (e.g. title, state, stacking, ...) are discarded for
 * an xdg_toplevel surface when it is unmapped.
 *
 * Attaching a null buffer to a toplevel unmaps the surface.
 * @section page_iface_xdg_toplevel_api API
 * See @ref iface_xdg_toplevel.
 */
/* *
 * @defgroup iface_xdg_toplevel The xdg_toplevel interface
 *
 * This interface defines an xdg_surface role which allows a surface to,
 * among other things, set window-like properties such as maximize,
 * fullscreen, and minimize, set application-specific metadata like title and
 * id, and well as trigger user interactive operations such as interactive
 * resize and move.
 *
 * Unmapping an xdg_toplevel means that the surface cannot be shown
 * by the compositor until it is explicitly mapped again.
 * All active operations (e.g., move, resize) are canceled and all
 * attributes (e.g. title, state, stacking, ...) are discarded for
 * an xdg_toplevel surface when it is unmapped.
 *
 * Attaching a null buffer to a toplevel unmaps the surface.
 */
    #[no_mangle]
    static xdg_toplevel_interface: wl_interface;
}
pub type __uint16_t = libc::c_ushort;
pub type __int32_t = libc::c_int;
pub type __uint32_t = libc::c_uint;
pub type __uint64_t = libc::c_ulong;
pub type __time_t = libc::c_long;
pub type __syscall_slong_t = libc::c_long;
pub type int32_t = __int32_t;
pub type uint16_t = __uint16_t;
pub type uint32_t = __uint32_t;
pub type uint64_t = __uint64_t;
pub type size_t = libc::c_ulong;
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wl_object {
    pub interface: *const wl_interface,
    pub implementation: *const libc::c_void,
    pub id: uint32_t,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wl_interface {
    pub name: *const libc::c_char,
    pub version: libc::c_int,
    pub method_count: libc::c_int,
    pub methods: *const wl_message,
    pub event_count: libc::c_int,
    pub events: *const wl_message,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wl_message {
    pub name: *const libc::c_char,
    pub signature: *const libc::c_char,
    pub types: *mut *const wl_interface,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wl_list {
    pub prev: *mut wl_list,
    pub next: *mut wl_list,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wl_array {
    pub size: size_t,
    pub alloc: size_t,
    pub data: *mut libc::c_void,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wl_listener {
    pub link: wl_list,
    pub notify: wl_notify_func_t,
}
pub type wl_notify_func_t
    =
    Option<unsafe extern "C" fn(_: *mut wl_listener, _: *mut libc::c_void)
               -> ()>;
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wl_callback_listener {
    pub done: Option<unsafe extern "C" fn(_: *mut libc::c_void,
                                          _: *mut wl_callback, _: uint32_t)
                         -> ()>,
}
pub type wl_output_subpixel = libc::c_uint;
pub const WL_OUTPUT_SUBPIXEL_VERTICAL_BGR: wl_output_subpixel = 5;
pub const WL_OUTPUT_SUBPIXEL_VERTICAL_RGB: wl_output_subpixel = 4;
pub const WL_OUTPUT_SUBPIXEL_HORIZONTAL_BGR: wl_output_subpixel = 3;
pub const WL_OUTPUT_SUBPIXEL_HORIZONTAL_RGB: wl_output_subpixel = 2;
pub const WL_OUTPUT_SUBPIXEL_NONE: wl_output_subpixel = 1;
pub const WL_OUTPUT_SUBPIXEL_UNKNOWN: wl_output_subpixel = 0;
pub type wl_output_transform = libc::c_uint;
pub const WL_OUTPUT_TRANSFORM_FLIPPED_270: wl_output_transform = 7;
pub const WL_OUTPUT_TRANSFORM_FLIPPED_180: wl_output_transform = 6;
pub const WL_OUTPUT_TRANSFORM_FLIPPED_90: wl_output_transform = 5;
pub const WL_OUTPUT_TRANSFORM_FLIPPED: wl_output_transform = 4;
pub const WL_OUTPUT_TRANSFORM_270: wl_output_transform = 3;
pub const WL_OUTPUT_TRANSFORM_180: wl_output_transform = 2;
pub const WL_OUTPUT_TRANSFORM_90: wl_output_transform = 1;
pub const WL_OUTPUT_TRANSFORM_NORMAL: wl_output_transform = 0;
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wl_resource {
    pub object: wl_object,
    pub destroy: wl_resource_destroy_func_t,
    pub link: wl_list,
    pub destroy_signal: wl_signal,
    pub client: *mut wl_client,
    pub data: *mut libc::c_void,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wl_signal {
    pub listener_list: wl_list,
}
pub type wl_resource_destroy_func_t
    =
    Option<unsafe extern "C" fn(_: *mut wl_resource) -> ()>;
pub type EGLDisplay = *mut libc::c_void;
pub type EGLConfig = *mut libc::c_void;
pub type EGLSurface = *mut libc::c_void;
pub type EGLContext = *mut libc::c_void;
pub type EGLenum = libc::c_uint;
/*
 * 32 bit regions
 */
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct pixman_region32_data {
    pub size: libc::c_long,
    pub numRects: libc::c_long,
}
pub type pixman_region32_data_t = pixman_region32_data;
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct pixman_box32 {
    pub x1: int32_t,
    pub y1: int32_t,
    pub x2: int32_t,
    pub y2: int32_t,
}
pub type pixman_box32_t = pixman_box32;
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct pixman_region32 {
    pub extents: pixman_box32_t,
    pub data: *mut pixman_region32_data_t,
}
pub type pixman_region32_t = pixman_region32;
/*
 * This an unstable interface of wlroots. No guarantees are made regarding the
 * future consistency of this API.
 */
pub type wlr_dmabuf_attributes_flags = libc::c_uint;
pub const WLR_DMABUF_ATTRIBUTES_FLAGS_BOTTOM_FIRST:
          wlr_dmabuf_attributes_flags =
    4;
pub const WLR_DMABUF_ATTRIBUTES_FLAGS_INTERLACED: wlr_dmabuf_attributes_flags
          =
    2;
pub const WLR_DMABUF_ATTRIBUTES_FLAGS_Y_INVERT: wlr_dmabuf_attributes_flags =
    1;
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wlr_dmabuf_attributes {
    pub width: int32_t,
    pub height: int32_t,
    pub format: uint32_t,
    pub flags: uint32_t,
    pub modifier: uint64_t,
    pub n_planes: libc::c_int,
    pub offset: [uint32_t; 4],
    pub stride: [uint32_t; 4],
    pub fd: [libc::c_int; 4],
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wlr_drm_format {
    pub format: uint32_t,
    pub len: size_t,
    pub cap: size_t,
    pub modifiers: [uint64_t; 0],
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wlr_drm_format_set {
    pub len: size_t,
    pub cap: size_t,
    pub formats: *mut *mut wlr_drm_format,
}
/*
 * This an unstable interface of wlroots. No guarantees are made regarding the
 * future consistency of this API.
 */
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wlr_egl {
    pub platform: EGLenum,
    pub display: EGLDisplay,
    pub config: EGLConfig,
    pub context: EGLContext,
    pub exts_str: *const libc::c_char,
    pub exts: C2RustUnnamed,
    pub wl_display: *mut wl_display,
    pub dmabuf_formats: wlr_drm_format_set,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct C2RustUnnamed {
    pub bind_wayland_display_wl: bool,
    pub buffer_age_ext: bool,
    pub image_base_khr: bool,
    pub image_dma_buf_export_mesa: bool,
    pub image_dmabuf_import_ext: bool,
    pub image_dmabuf_import_modifiers_ext: bool,
    pub swap_buffers_with_damage_ext: bool,
    pub swap_buffers_with_damage_khr: bool,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wlr_backend {
    pub impl_0: *const wlr_backend_impl,
    pub events: C2RustUnnamed_0,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct C2RustUnnamed_0 {
    pub destroy: wl_signal,
    pub new_input: wl_signal,
    pub new_output: wl_signal,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wlr_renderer {
    pub impl_0: *const wlr_renderer_impl,
    pub events: C2RustUnnamed_1,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct C2RustUnnamed_1 {
    pub destroy: wl_signal,
}
/*
 * This an unstable interface of wlroots. No guarantees are made regarding the
 * future consistency of this API.
 */
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wlr_box {
    pub x: libc::c_int,
    pub y: libc::c_int,
    pub width: libc::c_int,
    pub height: libc::c_int,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
/*
 * This an unstable interface of wlroots. No guarantees are made regarding the
 * future consistency of this API.
 */
/* *
 * A client buffer.
 */
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wlr_buffer {
    pub resource: *mut wl_resource,
    pub texture: *mut wlr_texture,
    pub released: bool,
    pub n_refs: size_t,
    pub resource_destroy: wl_listener,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wlr_texture {
    pub impl_0: *const wlr_texture_impl,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wlr_output_mode {
    pub width: int32_t,
    pub height: int32_t,
    pub refresh: int32_t,
    pub preferred: bool,
    pub link: wl_list,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wlr_output_cursor {
    pub output: *mut wlr_output,
    pub x: libc::c_double,
    pub y: libc::c_double,
    pub enabled: bool,
    pub visible: bool,
    pub width: uint32_t,
    pub height: uint32_t,
    pub hotspot_x: int32_t,
    pub hotspot_y: int32_t,
    pub link: wl_list,
    pub texture: *mut wlr_texture,
    pub surface: *mut wlr_surface,
    pub surface_commit: wl_listener,
    pub surface_destroy: wl_listener,
    pub events: C2RustUnnamed_2,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct C2RustUnnamed_2 {
    pub destroy: wl_signal,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wlr_output {
    pub impl_0: *const wlr_output_impl,
    pub backend: *mut wlr_backend,
    pub display: *mut wl_display,
    pub global: *mut wl_global,
    pub resources: wl_list,
    pub name: [libc::c_char; 24],
    pub make: [libc::c_char; 56],
    pub model: [libc::c_char; 16],
    pub serial: [libc::c_char; 16],
    pub phys_width: int32_t,
    pub phys_height: int32_t,
    pub modes: wl_list,
    pub current_mode: *mut wlr_output_mode,
    pub width: int32_t,
    pub height: int32_t,
    pub refresh: int32_t,
    pub enabled: bool,
    pub scale: libc::c_float,
    pub subpixel: wl_output_subpixel,
    pub transform: wl_output_transform,
    pub needs_frame: bool,
    pub damage: pixman_region32_t,
    pub frame_pending: bool,
    pub transform_matrix: [libc::c_float; 9],
    pub pending: wlr_output_state,
    pub commit_seq: uint32_t,
    pub events: C2RustUnnamed_3,
    pub idle_frame: *mut wl_event_source,
    pub idle_done: *mut wl_event_source,
    pub attach_render_locks: libc::c_int,
    pub cursors: wl_list,
    pub hardware_cursor: *mut wlr_output_cursor,
    pub software_cursor_locks: libc::c_int,
    pub display_destroy: wl_listener,
    pub data: *mut libc::c_void,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct C2RustUnnamed_3 {
    pub frame: wl_signal,
    pub needs_frame: wl_signal,
    pub precommit: wl_signal,
    pub commit: wl_signal,
    pub present: wl_signal,
    pub enable: wl_signal,
    pub mode: wl_signal,
    pub scale: wl_signal,
    pub transform: wl_signal,
    pub destroy: wl_signal,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wlr_output_state {
    pub committed: uint32_t,
    pub damage: pixman_region32_t,
    pub buffer_type: wlr_output_state_buffer_type,
    pub buffer: *mut wlr_buffer,
}
pub type wlr_output_state_buffer_type = libc::c_uint;
pub const WLR_OUTPUT_STATE_BUFFER_SCANOUT: wlr_output_state_buffer_type = 1;
pub const WLR_OUTPUT_STATE_BUFFER_RENDER: wlr_output_state_buffer_type = 0;
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wlr_output_impl {
    pub enable: Option<unsafe extern "C" fn(_: *mut wlr_output, _: bool)
                           -> bool>,
    pub set_mode: Option<unsafe extern "C" fn(_: *mut wlr_output,
                                              _: *mut wlr_output_mode)
                             -> bool>,
    pub set_custom_mode: Option<unsafe extern "C" fn(_: *mut wlr_output,
                                                     _: int32_t, _: int32_t,
                                                     _: int32_t) -> bool>,
    pub set_cursor: Option<unsafe extern "C" fn(_: *mut wlr_output,
                                                _: *mut wlr_texture,
                                                _: int32_t,
                                                _: wl_output_transform,
                                                _: int32_t, _: int32_t,
                                                _: bool) -> bool>,
    pub move_cursor: Option<unsafe extern "C" fn(_: *mut wlr_output,
                                                 _: libc::c_int,
                                                 _: libc::c_int) -> bool>,
    pub destroy: Option<unsafe extern "C" fn(_: *mut wlr_output) -> ()>,
    pub attach_render: Option<unsafe extern "C" fn(_: *mut wlr_output,
                                                   _: *mut libc::c_int)
                                  -> bool>,
    pub commit: Option<unsafe extern "C" fn(_: *mut wlr_output) -> bool>,
    pub set_gamma: Option<unsafe extern "C" fn(_: *mut wlr_output, _: size_t,
                                               _: *const uint16_t,
                                               _: *const uint16_t,
                                               _: *const uint16_t) -> bool>,
    pub get_gamma_size: Option<unsafe extern "C" fn(_: *mut wlr_output)
                                   -> size_t>,
    pub export_dmabuf: Option<unsafe extern "C" fn(_: *mut wlr_output,
                                                   _:
                                                       *mut wlr_dmabuf_attributes)
                                  -> bool>,
    pub schedule_frame: Option<unsafe extern "C" fn(_: *mut wlr_output)
                                   -> bool>,
    pub attach_buffer: Option<unsafe extern "C" fn(_: *mut wlr_output,
                                                   _: *mut wlr_buffer)
                                  -> bool>,
}
pub type wlr_output_state_field = libc::c_uint;
pub const WLR_OUTPUT_STATE_DAMAGE: wlr_output_state_field = 2;
pub const WLR_OUTPUT_STATE_BUFFER: wlr_output_state_field = 1;
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wlr_output_event_present {
    pub output: *mut wlr_output,
    pub commit_seq: uint32_t,
    pub when: *mut timespec,
    pub seq: libc::c_uint,
    pub refresh: libc::c_int,
    pub flags: uint32_t,
}
/*
 * This is a stable interface of wlroots. Future changes will be limited to:
 *
 * - New functions
 * - New struct members
 * - New enum members
 *
 * Note that wlroots does not make an ABI compatibility promise - in the future,
 * the layout and size of structs used by wlroots may change, requiring code
 * depending on this header to be recompiled (but not edited).
 *
 * Breaking changes are announced by email and follow a 1-year deprecation
 * schedule. Send an email to ~sircmpwn/wlroots-announce+subscribe@lists.sr.ht
 * to receive these announcements.
 */
pub type wlr_log_importance = libc::c_uint;
pub const WLR_LOG_IMPORTANCE_LAST: wlr_log_importance = 4;
pub const WLR_DEBUG: wlr_log_importance = 3;
pub const WLR_INFO: wlr_log_importance = 2;
pub const WLR_ERROR: wlr_log_importance = 1;
pub const WLR_SILENT: wlr_log_importance = 0;
pub type wlr_input_device_type = libc::c_uint;
pub const WLR_INPUT_DEVICE_SWITCH: wlr_input_device_type = 5;
pub const WLR_INPUT_DEVICE_TABLET_PAD: wlr_input_device_type = 4;
pub const WLR_INPUT_DEVICE_TABLET_TOOL: wlr_input_device_type = 3;
pub const WLR_INPUT_DEVICE_TOUCH: wlr_input_device_type = 2;
pub const WLR_INPUT_DEVICE_POINTER: wlr_input_device_type = 1;
pub const WLR_INPUT_DEVICE_KEYBOARD: wlr_input_device_type = 0;
pub type xkb_mod_index_t = uint32_t;
pub type xkb_mod_mask_t = uint32_t;
pub type xkb_led_index_t = uint32_t;
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wlr_keyboard_modifiers {
    pub depressed: xkb_mod_mask_t,
    pub latched: xkb_mod_mask_t,
    pub locked: xkb_mod_mask_t,
    pub group: xkb_mod_mask_t,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wlr_keyboard {
    pub impl_0: *const wlr_keyboard_impl,
    pub group: *mut wlr_keyboard_group,
    pub keymap_string: *mut libc::c_char,
    pub keymap_size: size_t,
    pub keymap: *mut xkb_keymap,
    pub xkb_state: *mut xkb_state,
    pub led_indexes: [xkb_led_index_t; 3],
    pub mod_indexes: [xkb_mod_index_t; 8],
    pub keycodes: [uint32_t; 32],
    pub num_keycodes: size_t,
    pub modifiers: wlr_keyboard_modifiers,
    pub repeat_info: C2RustUnnamed_5,
    pub events: C2RustUnnamed_4,
    pub data: *mut libc::c_void,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct C2RustUnnamed_4 {
    pub key: wl_signal,
    pub modifiers: wl_signal,
    pub keymap: wl_signal,
    pub repeat_info: wl_signal,
    pub destroy: wl_signal,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct C2RustUnnamed_5 {
    pub rate: int32_t,
    pub delay: int32_t,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wlr_pointer {
    pub impl_0: *const wlr_pointer_impl,
    pub events: C2RustUnnamed_6,
    pub data: *mut libc::c_void,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct C2RustUnnamed_6 {
    pub motion: wl_signal,
    pub motion_absolute: wl_signal,
    pub button: wl_signal,
    pub axis: wl_signal,
    pub frame: wl_signal,
    pub swipe_begin: wl_signal,
    pub swipe_update: wl_signal,
    pub swipe_end: wl_signal,
    pub pinch_begin: wl_signal,
    pub pinch_update: wl_signal,
    pub pinch_end: wl_signal,
}
/*
 * This an unstable interface of wlroots. No guarantees are made regarding the
 * future consistency of this API.
 */
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wlr_input_device {
    pub impl_0: *const wlr_input_device_impl,
    pub type_0: wlr_input_device_type,
    pub vendor: libc::c_uint,
    pub product: libc::c_uint,
    pub name: *mut libc::c_char,
    pub width_mm: libc::c_double,
    pub height_mm: libc::c_double,
    pub output_name: *mut libc::c_char,
    pub c2rust_unnamed: C2RustUnnamed_8,
    pub events: C2RustUnnamed_7,
    pub data: *mut libc::c_void,
    pub link: wl_list,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct C2RustUnnamed_7 {
    pub destroy: wl_signal,
}
#[derive ( Copy, Clone )]
#[repr ( C )]
pub union C2RustUnnamed_8 {
    pub _device: *mut libc::c_void,
    pub keyboard: *mut wlr_keyboard,
    pub pointer: *mut wlr_pointer,
    pub switch_device: *mut wlr_switch,
    pub touch: *mut wlr_touch,
    pub tablet: *mut wlr_tablet,
    pub tablet_pad: *mut wlr_tablet_pad,
}
/*
 * This an unstable interface of wlroots. No guarantees are made regarding the
 * future consistency of this API.
 */
/*
 * NOTE: the wlr tablet pad implementation does not currently support tablets
 * with more than one mode. I don't own any such hardware so I cannot test it
 * and it is too complicated to make a meaningful implementation of blindly.
 */
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wlr_tablet_pad {
    pub impl_0: *mut wlr_tablet_pad_impl,
    pub events: C2RustUnnamed_9,
    pub button_count: size_t,
    pub ring_count: size_t,
    pub strip_count: size_t,
    pub groups: wl_list,
    pub paths: wlr_list,
    pub data: *mut libc::c_void,
}
/*
 * This an unstable interface of wlroots. No guarantees are made regarding the
 * future consistency of this API.
 */
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wlr_list {
    pub capacity: size_t,
    pub length: size_t,
    pub items: *mut *mut libc::c_void,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct C2RustUnnamed_9 {
    pub button: wl_signal,
    pub ring: wl_signal,
    pub strip: wl_signal,
    pub attach_tablet: wl_signal,
}
/*
 * This an unstable interface of wlroots. No guarantees are made regarding the
 * future consistency of this API.
 */
/*
 * Copy+Paste from libinput, but this should neither use libinput, nor
 * tablet-unstable-v2 headers, so we can't include them
 */
/* * A generic pen */
/* * Eraser */
/* * A paintbrush-like tool */
/* * Physical drawing tool, e.g. Wacom Inking Pen */
/* * An airbrush-like tool */
/* * A mouse bound to the tablet */
/* * A mouse tool with a lens */
/* * A rotary device with positional and rotation data */
// Capabilities
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wlr_tablet {
    pub impl_0: *mut wlr_tablet_impl,
    pub events: C2RustUnnamed_10,
    pub name: *mut libc::c_char,
    pub paths: wlr_list,
    pub data: *mut libc::c_void,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct C2RustUnnamed_10 {
    pub axis: wl_signal,
    pub proximity: wl_signal,
    pub tip: wl_signal,
    pub button: wl_signal,
}
/*
 * This an unstable interface of wlroots. No guarantees are made regarding the
 * future consistency of this API.
 */
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wlr_touch {
    pub impl_0: *const wlr_touch_impl,
    pub events: C2RustUnnamed_11,
    pub data: *mut libc::c_void,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct C2RustUnnamed_11 {
    pub down: wl_signal,
    pub up: wl_signal,
    pub motion: wl_signal,
    pub cancel: wl_signal,
}
/*
 * This an unstable interface of wlroots. No guarantees are made regarding the
 * future consistency of this API.
 */
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wlr_switch {
    pub impl_0: *mut wlr_switch_impl,
    pub events: C2RustUnnamed_12,
    pub data: *mut libc::c_void,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct C2RustUnnamed_12 {
    pub toggle: wl_signal,
}
pub type wlr_axis_source = libc::c_uint;
pub const WLR_AXIS_SOURCE_WHEEL_TILT: wlr_axis_source = 3;
pub const WLR_AXIS_SOURCE_CONTINUOUS: wlr_axis_source = 2;
pub const WLR_AXIS_SOURCE_FINGER: wlr_axis_source = 1;
pub const WLR_AXIS_SOURCE_WHEEL: wlr_axis_source = 0;
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wlr_wl_output {
    pub wlr_output: wlr_output,
    pub backend: *mut wlr_wl_backend,
    pub link: wl_list,
    pub surface: *mut wl_surface,
    pub frame_callback: *mut wl_callback,
    pub xdg_surface: *mut xdg_surface,
    pub xdg_toplevel: *mut xdg_toplevel,
    pub zxdg_toplevel_decoration_v1: *mut zxdg_toplevel_decoration_v1,
    pub egl_window: *mut wl_egl_window,
    pub egl_surface: EGLSurface,
    pub pending_wl_buffer: *mut wl_buffer,
    pub current_wl_buffer: *mut wl_buffer,
    pub current_buffer: *mut wlr_buffer,
    pub presentation_feedbacks: wl_list,
    pub enter_serial: uint32_t,
    pub cursor: C2RustUnnamed_13,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct C2RustUnnamed_13 {
    pub surface: *mut wl_surface,
    pub egl_window: *mut wl_egl_window,
    pub hotspot_x: int32_t,
    pub hotspot_y: int32_t,
    pub width: int32_t,
    pub height: int32_t,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wlr_wl_backend {
    pub backend: wlr_backend,
    pub started: bool,
    pub local_display: *mut wl_display,
    pub devices: wl_list,
    pub outputs: wl_list,
    pub egl: wlr_egl,
    pub renderer: *mut wlr_renderer,
    pub requested_outputs: size_t,
    pub last_output_num: size_t,
    pub local_display_destroy: wl_listener,
    pub remote_display: *mut wl_display,
    pub remote_display_src: *mut wl_event_source,
    pub registry: *mut wl_registry,
    pub compositor: *mut wl_compositor,
    pub xdg_wm_base: *mut xdg_wm_base,
    pub zxdg_decoration_manager_v1: *mut zxdg_decoration_manager_v1,
    pub zwp_pointer_gestures_v1: *mut zwp_pointer_gestures_v1,
    pub presentation: *mut wp_presentation,
    pub zwp_linux_dmabuf_v1: *mut zwp_linux_dmabuf_v1,
    pub zwp_relative_pointer_manager_v1: *mut zwp_relative_pointer_manager_v1,
    pub seat: *mut wl_seat,
    pub pointer: *mut wl_pointer,
    pub keyboard: *mut wl_keyboard,
    pub current_pointer: *mut wlr_wl_pointer,
    pub tablet_manager: *mut zwp_tablet_manager_v2,
    pub seat_name: *mut libc::c_char,
    pub linux_dmabuf_v1_formats: wlr_drm_format_set,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wlr_wl_pointer {
    pub wlr_pointer: wlr_pointer,
    pub input_device: *mut wlr_wl_input_device,
    pub wl_pointer: *mut wl_pointer,
    pub gesture_swipe: *mut zwp_pointer_gesture_swipe_v1,
    pub gesture_pinch: *mut zwp_pointer_gesture_pinch_v1,
    pub relative_pointer: *mut zwp_relative_pointer_v1,
    pub axis_source: wlr_axis_source,
    pub axis_discrete: int32_t,
    pub output: *mut wlr_wl_output,
    pub output_destroy: wl_listener,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wlr_wl_input_device {
    pub wlr_input_device: wlr_input_device,
    pub fingers: uint32_t,
    pub backend: *mut wlr_wl_backend,
    pub resource: *mut libc::c_void,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wlr_wl_presentation_feedback {
    pub output: *mut wlr_wl_output,
    pub link: wl_list,
    pub feedback: *mut wp_presentation_feedback,
    pub commit_seq: uint32_t,
}
/* *
 * @ingroup iface_xdg_toplevel
 */
/* *
 * @ingroup iface_xdg_toplevel
 */
/* *
 * @ingroup iface_xdg_toplevel
 */
/* *
 * @ingroup iface_xdg_toplevel
 */
/* XDG_TOPLEVEL_STATE_ENUM */
/* *
 * @ingroup iface_xdg_toplevel
 * @struct xdg_toplevel_listener
 */
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct xdg_toplevel_listener {
    pub configure: Option<unsafe extern "C" fn(_: *mut libc::c_void,
                                               _: *mut xdg_toplevel,
                                               _: int32_t, _: int32_t,
                                               _: *mut wl_array) -> ()>,
    pub close: Option<unsafe extern "C" fn(_: *mut libc::c_void,
                                           _: *mut xdg_toplevel) -> ()>,
}
/* WP_PRESENTATION_FEEDBACK_KIND_ENUM */
/* *
 * @ingroup iface_wp_presentation_feedback
 * @struct wp_presentation_feedback_listener
 */
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wp_presentation_feedback_listener {
    pub sync_output: Option<unsafe extern "C" fn(_: *mut libc::c_void,
                                                 _:
                                                     *mut wp_presentation_feedback,
                                                 _: *mut wl_output) -> ()>,
    pub presented: Option<unsafe extern "C" fn(_: *mut libc::c_void,
                                               _:
                                                   *mut wp_presentation_feedback,
                                               _: uint32_t, _: uint32_t,
                                               _: uint32_t, _: uint32_t,
                                               _: uint32_t, _: uint32_t,
                                               _: uint32_t) -> ()>,
    pub discarded: Option<unsafe extern "C" fn(_: *mut libc::c_void,
                                               _:
                                                   *mut wp_presentation_feedback)
                              -> ()>,
}
/* *
	 * bottom field first
	 */
pub const ZWP_LINUX_BUFFER_PARAMS_V1_FLAGS_BOTTOM_FIRST:
          zwp_linux_buffer_params_v1_flags =
    4;
/* *
	 * content is interlaced
	 */
pub const ZWP_LINUX_BUFFER_PARAMS_V1_FLAGS_INTERLACED:
          zwp_linux_buffer_params_v1_flags =
    2;
/* *
	 * contents are y-inverted
	 */
pub const ZWP_LINUX_BUFFER_PARAMS_V1_FLAGS_Y_INVERT:
          zwp_linux_buffer_params_v1_flags =
    1;
/* XDG_SURFACE_ERROR_ENUM */
/* *
 * @ingroup iface_xdg_surface
 * @struct xdg_surface_listener
 */
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct xdg_surface_listener {
    pub configure: Option<unsafe extern "C" fn(_: *mut libc::c_void,
                                               _: *mut xdg_surface,
                                               _: uint32_t) -> ()>,
}
/* *
	 * server-side window decoration
	 */
pub const ZXDG_TOPLEVEL_DECORATION_V1_MODE_SERVER_SIDE:
          zxdg_toplevel_decoration_v1_mode =
    2;
/* ZWP_LINUX_BUFFER_PARAMS_V1_ERROR_ENUM */
pub type zwp_linux_buffer_params_v1_flags = libc::c_uint;
/* ZXDG_TOPLEVEL_DECORATION_V1_ERROR_ENUM */
/* *
 * @ingroup iface_zxdg_toplevel_decoration_v1
 * window decoration modes
 *
 * These values describe window decoration modes.
 */
pub type zxdg_toplevel_decoration_v1_mode = libc::c_uint;
/* *
	 * no server-side window decoration
	 */
pub const ZXDG_TOPLEVEL_DECORATION_V1_MODE_CLIENT_SIDE:
          zxdg_toplevel_decoration_v1_mode =
    1;
#[inline]
unsafe extern "C" fn wl_callback_add_listener(mut wl_callback:
                                                  *mut wl_callback,
                                              mut listener:
                                                  *const wl_callback_listener,
                                              mut data: *mut libc::c_void)
 -> libc::c_int {
    return wl_proxy_add_listener(wl_callback as *mut wl_proxy,
                                 listener as
                                     *mut Option<unsafe extern "C" fn()
                                                     -> ()>, data);
}
#[inline]
unsafe extern "C" fn wl_callback_destroy(mut wl_callback: *mut wl_callback) {
    wl_proxy_destroy(wl_callback as *mut wl_proxy);
}
#[inline]
unsafe extern "C" fn wl_compositor_create_surface(mut wl_compositor:
                                                      *mut wl_compositor)
 -> *mut wl_surface {
    let mut id: *mut wl_proxy = 0 as *mut wl_proxy;
    id =
        wl_proxy_marshal_constructor(wl_compositor as *mut wl_proxy,
                                     0i32 as uint32_t,
                                     &wl_surface_interface as
                                         *const wl_interface,
                                     0 as *mut libc::c_void);
    return id as *mut wl_surface;
}
#[inline]
unsafe extern "C" fn wl_buffer_destroy(mut wl_buffer: *mut wl_buffer) {
    wl_proxy_marshal(wl_buffer as *mut wl_proxy, 0i32 as uint32_t);
    wl_proxy_destroy(wl_buffer as *mut wl_proxy);
}
#[inline]
unsafe extern "C" fn wl_surface_set_user_data(mut wl_surface: *mut wl_surface,
                                              mut user_data:
                                                  *mut libc::c_void) {
    wl_proxy_set_user_data(wl_surface as *mut wl_proxy, user_data);
}
#[inline]
unsafe extern "C" fn wl_surface_destroy(mut wl_surface: *mut wl_surface) {
    wl_proxy_marshal(wl_surface as *mut wl_proxy, 0i32 as uint32_t);
    wl_proxy_destroy(wl_surface as *mut wl_proxy);
}
#[inline]
unsafe extern "C" fn wl_surface_attach(mut wl_surface: *mut wl_surface,
                                       mut buffer: *mut wl_buffer,
                                       mut x: int32_t, mut y: int32_t) {
    wl_proxy_marshal(wl_surface as *mut wl_proxy, 1i32 as uint32_t, buffer, x,
                     y);
}
#[inline]
unsafe extern "C" fn wl_surface_frame(mut wl_surface: *mut wl_surface)
 -> *mut wl_callback {
    let mut callback: *mut wl_proxy = 0 as *mut wl_proxy;
    callback =
        wl_proxy_marshal_constructor(wl_surface as *mut wl_proxy,
                                     3i32 as uint32_t,
                                     &wl_callback_interface as
                                         *const wl_interface,
                                     0 as *mut libc::c_void);
    return callback as *mut wl_callback;
}
#[inline]
unsafe extern "C" fn wl_surface_commit(mut wl_surface: *mut wl_surface) {
    wl_proxy_marshal(wl_surface as *mut wl_proxy, 6i32 as uint32_t);
}
#[inline]
unsafe extern "C" fn wl_surface_damage_buffer(mut wl_surface: *mut wl_surface,
                                              mut x: int32_t, mut y: int32_t,
                                              mut width: int32_t,
                                              mut height: int32_t) {
    wl_proxy_marshal(wl_surface as *mut wl_proxy, 9i32 as uint32_t, x, y,
                     width, height);
}
#[inline]
unsafe extern "C" fn wl_pointer_set_cursor(mut wl_pointer: *mut wl_pointer,
                                           mut serial: uint32_t,
                                           mut surface: *mut wl_surface,
                                           mut hotspot_x: int32_t,
                                           mut hotspot_y: int32_t) {
    wl_proxy_marshal(wl_pointer as *mut wl_proxy, 0i32 as uint32_t, serial,
                     surface, hotspot_x, hotspot_y);
}
/* *
 * @ingroup iface_zwp_linux_dmabuf_v1
 *
 * This temporary object is used to collect multiple dmabuf handles into
 * a single batch to create a wl_buffer. It can only be used once and
 * should be destroyed after a 'created' or 'failed' event has been
 * received.
 */
#[inline]
unsafe extern "C" fn zwp_linux_dmabuf_v1_create_params(mut zwp_linux_dmabuf_v1:
                                                           *mut zwp_linux_dmabuf_v1)
 -> *mut zwp_linux_buffer_params_v1 {
    let mut params_id: *mut wl_proxy = 0 as *mut wl_proxy;
    params_id =
        wl_proxy_marshal_constructor(zwp_linux_dmabuf_v1 as *mut wl_proxy,
                                     1i32 as uint32_t,
                                     &zwp_linux_buffer_params_v1_interface as
                                         *const wl_interface,
                                     0 as *mut libc::c_void);
    return params_id as *mut zwp_linux_buffer_params_v1;
}
/* *
 * @ingroup iface_zwp_linux_buffer_params_v1
 *
 * This request adds one dmabuf to the set in this
 * zwp_linux_buffer_params_v1.
 *
 * The 64-bit unsigned value combined from modifier_hi and modifier_lo
 * is the dmabuf layout modifier. DRM AddFB2 ioctl calls this the
 * fb modifier, which is defined in drm_mode.h of Linux UAPI.
 * This is an opaque token. Drivers use this token to express tiling,
 * compression, etc. driver-specific modifications to the base format
 * defined by the DRM fourcc code.
 *
 * Warning: It should be an error if the format/modifier pair was not
 * advertised with the modifier event. This is not enforced yet because
 * some implementations always accept DRM_FORMAT_MOD_INVALID. Also
 * version 2 of this protocol does not have the modifier event.
 *
 * This request raises the PLANE_IDX error if plane_idx is too large.
 * The error PLANE_SET is raised if attempting to set a plane that
 * was already set.
 */
#[inline]
unsafe extern "C" fn zwp_linux_buffer_params_v1_add(mut zwp_linux_buffer_params_v1:
                                                        *mut zwp_linux_buffer_params_v1,
                                                    mut fd: int32_t,
                                                    mut plane_idx: uint32_t,
                                                    mut offset: uint32_t,
                                                    mut stride: uint32_t,
                                                    mut modifier_hi: uint32_t,
                                                    mut modifier_lo:
                                                        uint32_t) {
    wl_proxy_marshal(zwp_linux_buffer_params_v1 as *mut wl_proxy,
                     1i32 as uint32_t, fd, plane_idx, offset, stride,
                     modifier_hi, modifier_lo);
}
/* *
 * @ingroup iface_zwp_linux_buffer_params_v1
 *
 * This asks for immediate creation of a wl_buffer by importing the
 * added dmabufs.
 *
 * In case of import success, no event is sent from the server, and the
 * wl_buffer is ready to be used by the client.
 *
 * Upon import failure, either of the following may happen, as seen fit
 * by the implementation:
 * - the client is terminated with one of the following fatal protocol
 * errors:
 * - INCOMPLETE, INVALID_FORMAT, INVALID_DIMENSIONS, OUT_OF_BOUNDS,
 * in case of argument errors such as mismatch between the number
 * of planes and the format, bad format, non-positive width or
 * height, or bad offset or stride.
 * - INVALID_WL_BUFFER, in case the cause for failure is unknown or
 * plaform specific.
 * - the server creates an invalid wl_buffer, marks it as failed and
 * sends a 'failed' event to the client. The result of using this
 * invalid wl_buffer as an argument in any request by the client is
 * defined by the compositor implementation.
 *
 * This takes the same arguments as a 'create' request, and obeys the
 * same restrictions.
 */
#[inline]
unsafe extern "C" fn zwp_linux_buffer_params_v1_create_immed(mut zwp_linux_buffer_params_v1:
                                                                 *mut zwp_linux_buffer_params_v1,
                                                             mut width:
                                                                 int32_t,
                                                             mut height:
                                                                 int32_t,
                                                             mut format:
                                                                 uint32_t,
                                                             mut flags:
                                                                 uint32_t)
 -> *mut wl_buffer {
    let mut buffer_id: *mut wl_proxy = 0 as *mut wl_proxy;
    buffer_id =
        wl_proxy_marshal_constructor(zwp_linux_buffer_params_v1 as
                                         *mut wl_proxy, 3i32 as uint32_t,
                                     &wl_buffer_interface as
                                         *const wl_interface,
                                     0 as *mut libc::c_void, width, height,
                                     format, flags);
    return buffer_id as *mut wl_buffer;
}
/* *
 * @ingroup iface_wp_presentation
 *
 * Request presentation feedback for the current content submission
 * on the given surface. This creates a new presentation_feedback
 * object, which will deliver the feedback information once. If
 * multiple presentation_feedback objects are created for the same
 * submission, they will all deliver the same information.
 *
 * For details on what information is returned, see the
 * presentation_feedback interface.
 */
#[inline]
unsafe extern "C" fn wp_presentation_feedback(mut wp_presentation:
                                                  *mut wp_presentation,
                                              mut surface: *mut wl_surface)
 -> *mut wp_presentation_feedback {
    let mut callback: *mut wl_proxy = 0 as *mut wl_proxy;
    callback =
        wl_proxy_marshal_constructor(wp_presentation as *mut wl_proxy,
                                     1i32 as uint32_t,
                                     &wp_presentation_feedback_interface as
                                         *const wl_interface, surface,
                                     0 as *mut libc::c_void);
    return callback as *mut wp_presentation_feedback;
}
/* *
 * @ingroup iface_wp_presentation_feedback
 */
#[inline]
unsafe extern "C" fn wp_presentation_feedback_add_listener(mut wp_presentation_feedback_0:
                                                               *mut wp_presentation_feedback,
                                                           mut listener:
                                                               *const wp_presentation_feedback_listener,
                                                           mut data:
                                                               *mut libc::c_void)
 -> libc::c_int {
    return wl_proxy_add_listener(wp_presentation_feedback_0 as *mut wl_proxy,
                                 listener as
                                     *mut Option<unsafe extern "C" fn()
                                                     -> ()>, data);
}
/* * @ingroup iface_wp_presentation_feedback */
#[inline]
unsafe extern "C" fn wp_presentation_feedback_destroy(mut wp_presentation_feedback_0:
                                                          *mut wp_presentation_feedback) {
    wl_proxy_destroy(wp_presentation_feedback_0 as *mut wl_proxy);
}
/* *
 * @ingroup iface_zxdg_decoration_manager_v1
 *
 * Create a new decoration object associated with the given toplevel.
 *
 * Creating an xdg_toplevel_decoration from an xdg_toplevel which has a
 * buffer attached or committed is a client error, and any attempts by a
 * client to attach or manipulate a buffer prior to the first
 * xdg_toplevel_decoration.configure event must also be treated as
 * errors.
 */
#[inline]
unsafe extern "C" fn zxdg_decoration_manager_v1_get_toplevel_decoration(mut zxdg_decoration_manager_v1:
                                                                            *mut zxdg_decoration_manager_v1,
                                                                        mut toplevel:
                                                                            *mut xdg_toplevel)
 -> *mut zxdg_toplevel_decoration_v1 {
    let mut id: *mut wl_proxy = 0 as *mut wl_proxy;
    id =
        wl_proxy_marshal_constructor(zxdg_decoration_manager_v1 as
                                         *mut wl_proxy, 1i32 as uint32_t,
                                     &zxdg_toplevel_decoration_v1_interface as
                                         *const wl_interface,
                                     0 as *mut libc::c_void, toplevel);
    return id as *mut zxdg_toplevel_decoration_v1;
}
/* *
 * @ingroup iface_zxdg_toplevel_decoration_v1
 *
 * Switch back to a mode without any server-side decorations at the next
 * commit.
 */
#[inline]
unsafe extern "C" fn zxdg_toplevel_decoration_v1_destroy(mut zxdg_toplevel_decoration_v1:
                                                             *mut zxdg_toplevel_decoration_v1) {
    wl_proxy_marshal(zxdg_toplevel_decoration_v1 as *mut wl_proxy,
                     0i32 as uint32_t);
    wl_proxy_destroy(zxdg_toplevel_decoration_v1 as *mut wl_proxy);
}
/* *
 * @ingroup iface_zxdg_toplevel_decoration_v1
 *
 * Set the toplevel surface decoration mode. This informs the compositor
 * that the client prefers the provided decoration mode.
 *
 * After requesting a decoration mode, the compositor will respond by
 * emitting a xdg_surface.configure event. The client should then update
 * its content, drawing it without decorations if the received mode is
 * server-side decorations. The client must also acknowledge the configure
 * when committing the new content (see xdg_surface.ack_configure).
 *
 * The compositor can decide not to use the client's mode and enforce a
 * different mode instead.
 *
 * Clients whose decoration mode depend on the xdg_toplevel state may send
 * a set_mode request in response to a xdg_surface.configure event and wait
 * for the next xdg_surface.configure event to prevent unwanted state.
 * Such clients are responsible for preventing configure loops and must
 * make sure not to send multiple successive set_mode requests with the
 * same decoration mode.
 */
#[inline]
unsafe extern "C" fn zxdg_toplevel_decoration_v1_set_mode(mut zxdg_toplevel_decoration_v1:
                                                              *mut zxdg_toplevel_decoration_v1,
                                                          mut mode:
                                                              uint32_t) {
    wl_proxy_marshal(zxdg_toplevel_decoration_v1 as *mut wl_proxy,
                     1i32 as uint32_t, mode);
}
/* *
 * @ingroup iface_xdg_wm_base
 *
 * This creates an xdg_surface for the given surface. While xdg_surface
 * itself is not a role, the corresponding surface may only be assigned
 * a role extending xdg_surface, such as xdg_toplevel or xdg_popup.
 *
 * This creates an xdg_surface for the given surface. An xdg_surface is
 * used as basis to define a role to a given surface, such as xdg_toplevel
 * or xdg_popup. It also manages functionality shared between xdg_surface
 * based surface roles.
 *
 * See the documentation of xdg_surface for more details about what an
 * xdg_surface is and how it is used.
 */
#[inline]
unsafe extern "C" fn xdg_wm_base_get_xdg_surface(mut xdg_wm_base:
                                                     *mut xdg_wm_base,
                                                 mut surface: *mut wl_surface)
 -> *mut xdg_surface {
    let mut id: *mut wl_proxy = 0 as *mut wl_proxy;
    id =
        wl_proxy_marshal_constructor(xdg_wm_base as *mut wl_proxy,
                                     2i32 as uint32_t,
                                     &xdg_surface_interface as
                                         *const wl_interface,
                                     0 as *mut libc::c_void, surface);
    return id as *mut xdg_surface;
}
/* *
 * @ingroup iface_xdg_surface
 */
#[inline]
unsafe extern "C" fn xdg_surface_add_listener(mut xdg_surface:
                                                  *mut xdg_surface,
                                              mut listener:
                                                  *const xdg_surface_listener,
                                              mut data: *mut libc::c_void)
 -> libc::c_int {
    return wl_proxy_add_listener(xdg_surface as *mut wl_proxy,
                                 listener as
                                     *mut Option<unsafe extern "C" fn()
                                                     -> ()>, data);
}
/* *
 * @ingroup iface_xdg_surface
 *
 * Destroy the xdg_surface object. An xdg_surface must only be destroyed
 * after its role object has been destroyed.
 */
#[inline]
unsafe extern "C" fn xdg_surface_destroy(mut xdg_surface: *mut xdg_surface) {
    wl_proxy_marshal(xdg_surface as *mut wl_proxy, 0i32 as uint32_t);
    wl_proxy_destroy(xdg_surface as *mut wl_proxy);
}
/* *
 * @ingroup iface_xdg_surface
 *
 * This creates an xdg_toplevel object for the given xdg_surface and gives
 * the associated wl_surface the xdg_toplevel role.
 *
 * See the documentation of xdg_toplevel for more details about what an
 * xdg_toplevel is and how it is used.
 */
#[inline]
unsafe extern "C" fn xdg_surface_get_toplevel(mut xdg_surface:
                                                  *mut xdg_surface)
 -> *mut xdg_toplevel {
    let mut id: *mut wl_proxy = 0 as *mut wl_proxy;
    id =
        wl_proxy_marshal_constructor(xdg_surface as *mut wl_proxy,
                                     1i32 as uint32_t,
                                     &xdg_toplevel_interface as
                                         *const wl_interface,
                                     0 as *mut libc::c_void);
    return id as *mut xdg_toplevel;
}
/* *
 * @ingroup iface_xdg_surface
 *
 * When a configure event is received, if a client commits the
 * surface in response to the configure event, then the client
 * must make an ack_configure request sometime before the commit
 * request, passing along the serial of the configure event.
 *
 * For instance, for toplevel surfaces the compositor might use this
 * information to move a surface to the top left only when the client has
 * drawn itself for the maximized or fullscreen state.
 *
 * If the client receives multiple configure events before it
 * can respond to one, it only has to ack the last configure event.
 *
 * A client is not required to commit immediately after sending
 * an ack_configure request - it may even ack_configure several times
 * before its next surface commit.
 *
 * A client may send multiple ack_configure requests before committing, but
 * only the last request sent before a commit indicates which configure
 * event the client really is responding to.
 */
#[inline]
unsafe extern "C" fn xdg_surface_ack_configure(mut xdg_surface:
                                                   *mut xdg_surface,
                                               mut serial: uint32_t) {
    wl_proxy_marshal(xdg_surface as *mut wl_proxy, 4i32 as uint32_t, serial);
}
/* *
 * @ingroup iface_xdg_toplevel
 */
#[inline]
unsafe extern "C" fn xdg_toplevel_add_listener(mut xdg_toplevel:
                                                   *mut xdg_toplevel,
                                               mut listener:
                                                   *const xdg_toplevel_listener,
                                               mut data: *mut libc::c_void)
 -> libc::c_int {
    return wl_proxy_add_listener(xdg_toplevel as *mut wl_proxy,
                                 listener as
                                     *mut Option<unsafe extern "C" fn()
                                                     -> ()>, data);
}
/* *
 * @ingroup iface_xdg_toplevel
 *
 * This request destroys the role surface and unmaps the surface;
 * see "Unmapping" behavior in interface section for details.
 */
#[inline]
unsafe extern "C" fn xdg_toplevel_destroy(mut xdg_toplevel:
                                              *mut xdg_toplevel) {
    wl_proxy_marshal(xdg_toplevel as *mut wl_proxy, 0i32 as uint32_t);
    wl_proxy_destroy(xdg_toplevel as *mut wl_proxy);
}
/* *
 * @ingroup iface_xdg_toplevel
 *
 * Set a short title for the surface.
 *
 * This string may be used to identify the surface in a task bar,
 * window list, or other user interface elements provided by the
 * compositor.
 *
 * The string must be encoded in UTF-8.
 */
#[inline]
unsafe extern "C" fn xdg_toplevel_set_title(mut xdg_toplevel:
                                                *mut xdg_toplevel,
                                            mut title: *const libc::c_char) {
    wl_proxy_marshal(xdg_toplevel as *mut wl_proxy, 2i32 as uint32_t, title);
}
/* *
 * @ingroup iface_xdg_toplevel
 *
 * Set an application identifier for the surface.
 *
 * The app ID identifies the general class of applications to which
 * the surface belongs. The compositor can use this to group multiple
 * surfaces together, or to determine how to launch a new application.
 *
 * For D-Bus activatable applications, the app ID is used as the D-Bus
 * service name.
 *
 * The compositor shell will try to group application surfaces together
 * by their app ID. As a best practice, it is suggested to select app
 * ID's that match the basename of the application's .desktop file.
 * For example, "org.freedesktop.FooViewer" where the .desktop file is
 * "org.freedesktop.FooViewer.desktop".
 *
 * Like other properties, a set_app_id request can be sent after the
 * xdg_toplevel has been mapped to update the property.
 *
 * See the desktop-entry specification [0] for more details on
 * application identifiers and how they relate to well-known D-Bus
 * names and .desktop files.
 *
 * [0] http://standards.freedesktop.org/desktop-entry-spec/
 */
#[inline]
unsafe extern "C" fn xdg_toplevel_set_app_id(mut xdg_toplevel:
                                                 *mut xdg_toplevel,
                                             mut app_id:
                                                 *const libc::c_char) {
    wl_proxy_marshal(xdg_toplevel as *mut wl_proxy, 3i32 as uint32_t, app_id);
}
unsafe extern "C" fn get_wl_output_from_output(mut wlr_output:
                                                   *mut wlr_output)
 -> *mut wlr_wl_output {
    if wlr_output_is_wl(wlr_output) as libc::c_int != 0 {
    } else {
        __assert_fail(b"wlr_output_is_wl(wlr_output)\x00" as *const u8 as
                          *const libc::c_char,
                      b"../backend/wayland/output.c\x00" as *const u8 as
                          *const libc::c_char, 26i32 as libc::c_uint,
                      (*::std::mem::transmute::<&[u8; 69],
                                                &[libc::c_char; 69]>(b"struct wlr_wl_output *get_wl_output_from_output(struct wlr_output *)\x00")).as_ptr());
    };
    return wlr_output as *mut wlr_wl_output;
}
unsafe extern "C" fn surface_frame_callback(mut data: *mut libc::c_void,
                                            mut cb: *mut wl_callback,
                                            mut time: uint32_t) {
    let mut output: *mut wlr_wl_output = data as *mut wlr_wl_output;
    if !output.is_null() {
    } else {
        __assert_fail(b"output\x00" as *const u8 as *const libc::c_char,
                      b"../backend/wayland/output.c\x00" as *const u8 as
                          *const libc::c_char, 33i32 as libc::c_uint,
                      (*::std::mem::transmute::<&[u8; 68],
                                                &[libc::c_char; 68]>(b"void surface_frame_callback(void *, struct wl_callback *, uint32_t)\x00")).as_ptr());
    };
    wl_callback_destroy(cb);
    (*output).frame_callback = 0 as *mut wl_callback;
    wlr_output_send_frame(&mut (*output).wlr_output);
}
static mut frame_listener: wl_callback_listener =
    unsafe {
        {
            let mut init =
                wl_callback_listener{done:
                                         Some(surface_frame_callback as
                                                  unsafe extern "C" fn(_:
                                                                           *mut libc::c_void,
                                                                       _:
                                                                           *mut wl_callback,
                                                                       _:
                                                                           uint32_t)
                                                      -> ()),};
            init
        }
    };
unsafe extern "C" fn presentation_feedback_destroy(mut feedback:
                                                       *mut wlr_wl_presentation_feedback) {
    wl_list_remove(&mut (*feedback).link);
    wp_presentation_feedback_destroy((*feedback).feedback);
    free(feedback as *mut libc::c_void);
}
unsafe extern "C" fn presentation_feedback_handle_sync_output(mut data:
                                                                  *mut libc::c_void,
                                                              mut feedback:
                                                                  *mut wp_presentation_feedback,
                                                              mut output:
                                                                  *mut wl_output) {
    // This space is intentionally left blank
}
unsafe extern "C" fn presentation_feedback_handle_presented(mut data:
                                                                *mut libc::c_void,
                                                            mut wp_feedback:
                                                                *mut wp_presentation_feedback,
                                                            mut tv_sec_hi:
                                                                uint32_t,
                                                            mut tv_sec_lo:
                                                                uint32_t,
                                                            mut tv_nsec:
                                                                uint32_t,
                                                            mut refresh_ns:
                                                                uint32_t,
                                                            mut seq_hi:
                                                                uint32_t,
                                                            mut seq_lo:
                                                                uint32_t,
                                                            mut flags:
                                                                uint32_t) {
    let mut feedback: *mut wlr_wl_presentation_feedback =
        data as *mut wlr_wl_presentation_feedback;
    let mut t: timespec =
        {
            let mut init =
                timespec{tv_sec:
                             ((tv_sec_hi as uint64_t) << 32i32 |
                                  tv_sec_lo as libc::c_ulong) as __time_t,
                         tv_nsec: tv_nsec as __syscall_slong_t,};
            init
        };
    let mut event: wlr_output_event_present =
        {
            let mut init =
                wlr_output_event_present{output: 0 as *mut wlr_output,
                                         commit_seq: (*feedback).commit_seq,
                                         when: &mut t,
                                         seq:
                                             ((seq_hi as uint64_t) << 32i32 |
                                                  seq_lo as libc::c_ulong) as
                                                 libc::c_uint,
                                         refresh: refresh_ns as libc::c_int,
                                         flags: flags,};
            init
        };
    wlr_output_send_present(&mut (*(*feedback).output).wlr_output,
                            &mut event);
    presentation_feedback_destroy(feedback);
}
unsafe extern "C" fn presentation_feedback_handle_discarded(mut data:
                                                                *mut libc::c_void,
                                                            mut wp_feedback:
                                                                *mut wp_presentation_feedback) {
    let mut feedback: *mut wlr_wl_presentation_feedback =
        data as *mut wlr_wl_presentation_feedback;
    wlr_output_send_present(&mut (*(*feedback).output).wlr_output,
                            0 as *mut wlr_output_event_present);
    presentation_feedback_destroy(feedback);
}
static mut presentation_feedback_listener: wp_presentation_feedback_listener =
    unsafe {
        {
            let mut init =
                wp_presentation_feedback_listener{sync_output:
                                                      Some(presentation_feedback_handle_sync_output
                                                               as
                                                               unsafe extern "C" fn(_:
                                                                                        *mut libc::c_void,
                                                                                    _:
                                                                                        *mut wp_presentation_feedback,
                                                                                    _:
                                                                                        *mut wl_output)
                                                                   -> ()),
                                                  presented:
                                                      Some(presentation_feedback_handle_presented
                                                               as
                                                               unsafe extern "C" fn(_:
                                                                                        *mut libc::c_void,
                                                                                    _:
                                                                                        *mut wp_presentation_feedback,
                                                                                    _:
                                                                                        uint32_t,
                                                                                    _:
                                                                                        uint32_t,
                                                                                    _:
                                                                                        uint32_t,
                                                                                    _:
                                                                                        uint32_t,
                                                                                    _:
                                                                                        uint32_t,
                                                                                    _:
                                                                                        uint32_t,
                                                                                    _:
                                                                                        uint32_t)
                                                                   -> ()),
                                                  discarded:
                                                      Some(presentation_feedback_handle_discarded
                                                               as
                                                               unsafe extern "C" fn(_:
                                                                                        *mut libc::c_void,
                                                                                    _:
                                                                                        *mut wp_presentation_feedback)
                                                                   -> ()),};
            init
        }
    };
unsafe extern "C" fn output_set_custom_mode(mut wlr_output: *mut wlr_output,
                                            mut width: int32_t,
                                            mut height: int32_t,
                                            mut refresh: int32_t) -> bool {
    let mut output: *mut wlr_wl_output =
        get_wl_output_from_output(wlr_output);
    wlr_egl_swap_buffers(&mut (*(*output).backend).egl, (*output).egl_surface,
                         0 as *mut pixman_region32_t);
    wl_egl_window_resize((*output).egl_window, width, height, 0i32, 0i32);
    wlr_output_update_custom_mode(&mut (*output).wlr_output, width, height,
                                  0i32);
    return 1i32 != 0;
}
unsafe extern "C" fn output_attach_render(mut wlr_output: *mut wlr_output,
                                          mut buffer_age: *mut libc::c_int)
 -> bool {
    let mut output: *mut wlr_wl_output =
        get_wl_output_from_output(wlr_output);
    return wlr_egl_make_current(&mut (*(*output).backend).egl,
                                (*output).egl_surface, buffer_age);
}
unsafe extern "C" fn output_attach_buffer(mut wlr_output: *mut wlr_output,
                                          mut buffer: *mut wlr_buffer)
 -> bool {
    let mut output: *mut wlr_wl_output =
        get_wl_output_from_output(wlr_output);
    let mut wl: *mut wlr_wl_backend = (*output).backend;
    let mut attribs: wlr_dmabuf_attributes =
        wlr_dmabuf_attributes{width: 0,
                              height: 0,
                              format: 0,
                              flags: 0,
                              modifier: 0,
                              n_planes: 0,
                              offset: [0; 4],
                              stride: [0; 4],
                              fd: [0; 4],};
    if !wlr_buffer_get_dmabuf(buffer, &mut attribs) { return 0i32 != 0 }
    if attribs.width != (*wlr_output).width ||
           attribs.height != (*wlr_output).height {
        return 0i32 != 0
    }
    if !wlr_drm_format_set_has(&mut (*wl).linux_dmabuf_v1_formats,
                               attribs.format, attribs.modifier) {
        return 0i32 != 0
    }
    let mut modifier_hi: uint32_t = (attribs.modifier >> 32i32) as uint32_t;
    let mut modifier_lo: uint32_t = attribs.modifier as uint32_t;
    let mut params: *mut zwp_linux_buffer_params_v1 =
        zwp_linux_dmabuf_v1_create_params((*wl).zwp_linux_dmabuf_v1);
    let mut i: libc::c_int = 0i32;
    while i < attribs.n_planes {
        zwp_linux_buffer_params_v1_add(params, attribs.fd[i as usize],
                                       i as uint32_t,
                                       attribs.offset[i as usize],
                                       attribs.stride[i as usize],
                                       modifier_hi, modifier_lo);
        i += 1
    }
    let mut flags: uint32_t = 0i32 as uint32_t;
    if attribs.flags &
           WLR_DMABUF_ATTRIBUTES_FLAGS_Y_INVERT as libc::c_int as libc::c_uint
           != 0 {
        flags |=
            ZWP_LINUX_BUFFER_PARAMS_V1_FLAGS_Y_INVERT as libc::c_int as
                libc::c_uint
    }
    if attribs.flags &
           WLR_DMABUF_ATTRIBUTES_FLAGS_INTERLACED as libc::c_int as
               libc::c_uint != 0 {
        flags |=
            ZWP_LINUX_BUFFER_PARAMS_V1_FLAGS_INTERLACED as libc::c_int as
                libc::c_uint
    }
    if attribs.flags &
           WLR_DMABUF_ATTRIBUTES_FLAGS_BOTTOM_FIRST as libc::c_int as
               libc::c_uint != 0 {
        flags |=
            ZWP_LINUX_BUFFER_PARAMS_V1_FLAGS_BOTTOM_FIRST as libc::c_int as
                libc::c_uint
    }
    let mut wl_buffer: *mut wl_buffer =
        zwp_linux_buffer_params_v1_create_immed(params, attribs.width,
                                                attribs.height,
                                                attribs.format, flags);
    // TODO: handle create() errors
    wl_surface_attach((*output).surface, wl_buffer, 0i32, 0i32);
    if !(*output).pending_wl_buffer.is_null() {
        wl_buffer_destroy((*output).pending_wl_buffer);
    }
    (*output).pending_wl_buffer = wl_buffer;
    return 1i32 != 0;
}
unsafe extern "C" fn output_commit(mut wlr_output: *mut wlr_output) -> bool {
    let mut output: *mut wlr_wl_output =
        get_wl_output_from_output(wlr_output);
    if !(*output).frame_callback.is_null() {
        _wlr_log(WLR_ERROR,
                 b"[%s:%d] Skipping buffer swap\x00" as *const u8 as
                     *const libc::c_char,
                 b"../backend/wayland/output.c\x00" as *const u8 as
                     *const libc::c_char, 170i32);
        return 0i32 != 0
    }
    (*output).frame_callback = wl_surface_frame((*output).surface);
    wl_callback_add_listener((*output).frame_callback, &frame_listener,
                             output as *mut libc::c_void);
    let mut damage: *mut pixman_region32_t = 0 as *mut pixman_region32_t;
    if (*wlr_output).pending.committed &
           WLR_OUTPUT_STATE_DAMAGE as libc::c_int as libc::c_uint != 0 {
        damage = &mut (*wlr_output).pending.damage
    }
    wlr_buffer_unref((*output).current_buffer);
    (*output).current_buffer = 0 as *mut wlr_buffer;
    if !(*output).current_wl_buffer.is_null() {
        wl_buffer_destroy((*output).current_wl_buffer);
        (*output).current_wl_buffer = 0 as *mut wl_buffer
    }
    let mut wp_feedback: *mut wp_presentation_feedback =
        0 as *mut wp_presentation_feedback;
    if !(*(*output).backend).presentation.is_null() {
        wp_feedback =
            wp_presentation_feedback((*(*output).backend).presentation,
                                     (*output).surface)
    }
    if (*wlr_output).pending.committed &
           WLR_OUTPUT_STATE_BUFFER as libc::c_int as libc::c_uint != 0 {
    } else {
        __assert_fail(b"wlr_output->pending.committed & WLR_OUTPUT_STATE_BUFFER\x00"
                          as *const u8 as *const libc::c_char,
                      b"../backend/wayland/output.c\x00" as *const u8 as
                          *const libc::c_char, 195i32 as libc::c_uint,
                      (*::std::mem::transmute::<&[u8; 41],
                                                &[libc::c_char; 41]>(b"_Bool output_commit(struct wlr_output *)\x00")).as_ptr());
    };
    match (*wlr_output).pending.buffer_type as libc::c_uint {
        0 => {
            if !wlr_egl_swap_buffers(&mut (*(*output).backend).egl,
                                     (*output).egl_surface, damage) {
                return 0i32 != 0
            }
        }
        1 => {
            if damage.is_null() {
                wl_surface_damage_buffer((*output).surface, 0i32, 0i32,
                                         2147483647i32, 2147483647i32);
            } else {
                let mut rects_len: libc::c_int = 0;
                let mut rects: *mut pixman_box32_t =
                    pixman_region32_rectangles(damage, &mut rects_len);
                let mut i: libc::c_int = 0i32;
                while i < rects_len {
                    let mut r: *mut pixman_box32_t =
                        &mut *rects.offset(i as isize) as *mut pixman_box32_t;
                    wl_surface_damage_buffer((*output).surface, (*r).x1,
                                             (*r).y1, (*r).x2 - (*r).x1,
                                             (*r).y2 - (*r).y1);
                    i += 1
                }
            }
            wl_surface_commit((*output).surface);
            (*output).current_buffer =
                wlr_buffer_ref((*wlr_output).pending.buffer);
            (*output).current_wl_buffer = (*output).pending_wl_buffer;
            (*output).pending_wl_buffer = 0 as *mut wl_buffer
        }
        _ => { }
    }
    if !wp_feedback.is_null() {
        let mut feedback: *mut wlr_wl_presentation_feedback =
            calloc(1i32 as libc::c_ulong,
                   ::std::mem::size_of::<wlr_wl_presentation_feedback>() as
                       libc::c_ulong) as *mut wlr_wl_presentation_feedback;
        if feedback.is_null() {
            wp_presentation_feedback_destroy(wp_feedback);
            return 0i32 != 0
        }
        (*feedback).output = output;
        (*feedback).feedback = wp_feedback;
        (*feedback).commit_seq =
            (*output).wlr_output.commit_seq.wrapping_add(1i32 as
                                                             libc::c_uint);
        wl_list_insert(&mut (*output).presentation_feedbacks,
                       &mut (*feedback).link);
        wp_presentation_feedback_add_listener(wp_feedback,
                                              &presentation_feedback_listener,
                                              feedback as *mut libc::c_void);
    } else {
        wlr_output_send_present(wlr_output,
                                0 as *mut wlr_output_event_present);
    }
    return 1i32 != 0;
}
unsafe extern "C" fn output_set_cursor(mut wlr_output: *mut wlr_output,
                                       mut texture: *mut wlr_texture,
                                       mut scale: int32_t,
                                       mut transform: wl_output_transform,
                                       mut hotspot_x: int32_t,
                                       mut hotspot_y: int32_t,
                                       mut update_texture: bool) -> bool {
    let mut output: *mut wlr_wl_output =
        get_wl_output_from_output(wlr_output);
    let mut backend: *mut wlr_wl_backend = (*output).backend;
    let mut hotspot: wlr_box =
        {
            let mut init =
                wlr_box{x: hotspot_x, y: hotspot_y, width: 0, height: 0,};
            init
        };
    wlr_box_transform(&mut hotspot, &mut hotspot,
                      wlr_output_transform_invert((*wlr_output).transform),
                      (*output).cursor.width, (*output).cursor.height);
    // TODO: use output->wlr_output.transform to transform pixels and hotpot
    (*output).cursor.hotspot_x = hotspot.x;
    (*output).cursor.hotspot_y = hotspot.y;
    if !update_texture {
        // Update hotspot without changing cursor image
        update_wl_output_cursor(output);
        return 1i32 != 0
    }
    if (*output).cursor.surface.is_null() {
        (*output).cursor.surface =
            wl_compositor_create_surface((*backend).compositor)
    }
    let mut surface: *mut wl_surface = (*output).cursor.surface;
    if !texture.is_null() {
        let mut width: libc::c_int = 0;
        let mut height: libc::c_int = 0;
        wlr_texture_get_size(texture, &mut width, &mut height);
        width =
            (width as libc::c_float * (*wlr_output).scale /
                 scale as libc::c_float) as libc::c_int;
        height =
            (height as libc::c_float * (*wlr_output).scale /
                 scale as libc::c_float) as libc::c_int;
        (*output).cursor.width = width;
        (*output).cursor.height = height;
        if (*output).cursor.egl_window.is_null() {
            (*output).cursor.egl_window =
                wl_egl_window_create(surface, width, height)
        }
        wl_egl_window_resize((*output).cursor.egl_window, width, height, 0i32,
                             0i32);
        let mut egl_surface: EGLSurface =
            wlr_egl_create_surface(&mut (*backend).egl,
                                   (*output).cursor.egl_window as
                                       *mut libc::c_void);
        wlr_egl_make_current(&mut (*backend).egl, egl_surface,
                             0 as *mut libc::c_int);
        let mut cursor_box: wlr_box =
            {
                let mut init =
                    wlr_box{x: 0, y: 0, width: width, height: height,};
                init
            };
        let mut projection: [libc::c_float; 9] = [0.; 9];
        wlr_matrix_projection(projection.as_mut_ptr(), width, height,
                              (*wlr_output).transform);
        let mut matrix: [libc::c_float; 9] = [0.; 9];
        wlr_matrix_project_box(matrix.as_mut_ptr(), &mut cursor_box,
                               transform, 0i32 as libc::c_float,
                               projection.as_mut_ptr() as
                                   *const libc::c_float);
        wlr_renderer_begin((*backend).renderer, width, height);
        wlr_renderer_clear((*backend).renderer,
                           [0.0f64 as libc::c_float, 0.0f64 as libc::c_float,
                            0.0f64 as libc::c_float,
                            0.0f64 as libc::c_float].as_mut_ptr() as
                               *const libc::c_float);
        wlr_render_texture_with_matrix((*backend).renderer, texture,
                                       matrix.as_mut_ptr() as
                                           *const libc::c_float,
                                       1.0f64 as libc::c_float);
        wlr_renderer_end((*backend).renderer);
        wlr_egl_swap_buffers(&mut (*backend).egl, egl_surface,
                             0 as *mut pixman_region32_t);
        wlr_egl_destroy_surface(&mut (*backend).egl, egl_surface);
    } else {
        wl_surface_attach(surface, 0 as *mut wl_buffer, 0i32, 0i32);
        wl_surface_commit(surface);
    }
    update_wl_output_cursor(output);
    return 1i32 != 0;
}
unsafe extern "C" fn output_destroy(mut wlr_output: *mut wlr_output) {
    let mut output: *mut wlr_wl_output =
        get_wl_output_from_output(wlr_output);
    if output.is_null() { return }
    wl_list_remove(&mut (*output).link);
    if !(*output).cursor.egl_window.is_null() {
        wl_egl_window_destroy((*output).cursor.egl_window);
    }
    if !(*output).cursor.surface.is_null() {
        wl_surface_destroy((*output).cursor.surface);
    }
    if !(*output).frame_callback.is_null() {
        wl_callback_destroy((*output).frame_callback);
    }
    let mut feedback: *mut wlr_wl_presentation_feedback =
        0 as *mut wlr_wl_presentation_feedback;
    let mut feedback_tmp: *mut wlr_wl_presentation_feedback =
        0 as *mut wlr_wl_presentation_feedback;
    feedback =
        ((*output).presentation_feedbacks.next as
             *mut libc::c_char).offset(-8) as
            *mut wlr_wl_presentation_feedback;
    feedback_tmp =
        ((*feedback).link.next as *mut libc::c_char).offset(-8) as
            *mut wlr_wl_presentation_feedback;
    while &mut (*feedback).link as *mut wl_list !=
              &mut (*output).presentation_feedbacks as *mut wl_list {
        presentation_feedback_destroy(feedback);
        feedback = feedback_tmp;
        feedback_tmp =
            ((*feedback).link.next as *mut libc::c_char).offset(-8) as
                *mut wlr_wl_presentation_feedback
    }
    wlr_egl_destroy_surface(&mut (*(*output).backend).egl,
                            (*output).egl_surface);
    wl_egl_window_destroy((*output).egl_window);
    if !(*output).zxdg_toplevel_decoration_v1.is_null() {
        zxdg_toplevel_decoration_v1_destroy((*output).zxdg_toplevel_decoration_v1);
    }
    xdg_toplevel_destroy((*output).xdg_toplevel);
    xdg_surface_destroy((*output).xdg_surface);
    wl_surface_destroy((*output).surface);
    free(output as *mut libc::c_void);
}
#[no_mangle]
pub unsafe extern "C" fn update_wl_output_cursor(mut output:
                                                     *mut wlr_wl_output) {
    if !(*(*output).backend).pointer.is_null() && (*output).enter_serial != 0
       {
        wl_pointer_set_cursor((*(*output).backend).pointer,
                              (*output).enter_serial,
                              (*output).cursor.surface,
                              (*output).cursor.hotspot_x,
                              (*output).cursor.hotspot_y);
    };
}
unsafe extern "C" fn output_move_cursor(mut _output: *mut wlr_output,
                                        mut x: libc::c_int,
                                        mut y: libc::c_int) -> bool {
    // TODO: only return true if x == current x and y == current y
    return 1i32 != 0;
}
unsafe extern "C" fn output_schedule_frame(mut wlr_output: *mut wlr_output)
 -> bool {
    let mut output: *mut wlr_wl_output =
        get_wl_output_from_output(wlr_output);
    if !(*output).frame_callback.is_null() {
        _wlr_log(WLR_ERROR,
                 b"[%s:%d] Skipping frame scheduling\x00" as *const u8 as
                     *const libc::c_char,
                 b"../backend/wayland/output.c\x00" as *const u8 as
                     *const libc::c_char, 374i32);
        return 1i32 != 0
    }
    (*output).frame_callback = wl_surface_frame((*output).surface);
    wl_callback_add_listener((*output).frame_callback, &frame_listener,
                             output as *mut libc::c_void);
    wl_surface_commit((*output).surface);
    return 1i32 != 0;
}
static mut output_impl: wlr_output_impl =
    unsafe {
        {
            let mut init =
                wlr_output_impl{enable: None,
                                set_mode: None,
                                set_custom_mode:
                                    Some(output_set_custom_mode as
                                             unsafe extern "C" fn(_:
                                                                      *mut wlr_output,
                                                                  _: int32_t,
                                                                  _: int32_t,
                                                                  _: int32_t)
                                                 -> bool),
                                set_cursor:
                                    Some(output_set_cursor as
                                             unsafe extern "C" fn(_:
                                                                      *mut wlr_output,
                                                                  _:
                                                                      *mut wlr_texture,
                                                                  _: int32_t,
                                                                  _:
                                                                      wl_output_transform,
                                                                  _: int32_t,
                                                                  _: int32_t,
                                                                  _: bool)
                                                 -> bool),
                                move_cursor:
                                    Some(output_move_cursor as
                                             unsafe extern "C" fn(_:
                                                                      *mut wlr_output,
                                                                  _:
                                                                      libc::c_int,
                                                                  _:
                                                                      libc::c_int)
                                                 -> bool),
                                destroy:
                                    Some(output_destroy as
                                             unsafe extern "C" fn(_:
                                                                      *mut wlr_output)
                                                 -> ()),
                                attach_render:
                                    Some(output_attach_render as
                                             unsafe extern "C" fn(_:
                                                                      *mut wlr_output,
                                                                  _:
                                                                      *mut libc::c_int)
                                                 -> bool),
                                commit:
                                    Some(output_commit as
                                             unsafe extern "C" fn(_:
                                                                      *mut wlr_output)
                                                 -> bool),
                                set_gamma: None,
                                get_gamma_size: None,
                                export_dmabuf: None,
                                schedule_frame:
                                    Some(output_schedule_frame as
                                             unsafe extern "C" fn(_:
                                                                      *mut wlr_output)
                                                 -> bool),
                                attach_buffer:
                                    Some(output_attach_buffer as
                                             unsafe extern "C" fn(_:
                                                                      *mut wlr_output,
                                                                  _:
                                                                      *mut wlr_buffer)
                                                 -> bool),};
            init
        }
    };
#[no_mangle]
pub unsafe extern "C" fn wlr_output_is_wl(mut wlr_output: *mut wlr_output)
 -> bool {
    return (*wlr_output).impl_0 == &output_impl as *const wlr_output_impl;
}
unsafe extern "C" fn xdg_surface_handle_configure(mut data: *mut libc::c_void,
                                                  mut xdg_surface:
                                                      *mut xdg_surface,
                                                  mut serial: uint32_t) {
    let mut output: *mut wlr_wl_output = data as *mut wlr_wl_output;
    if !output.is_null() && (*output).xdg_surface == xdg_surface {
    } else {
        __assert_fail(b"output && output->xdg_surface == xdg_surface\x00" as
                          *const u8 as *const libc::c_char,
                      b"../backend/wayland/output.c\x00" as *const u8 as
                          *const libc::c_char, 402i32 as libc::c_uint,
                      (*::std::mem::transmute::<&[u8; 74],
                                                &[libc::c_char; 74]>(b"void xdg_surface_handle_configure(void *, struct xdg_surface *, uint32_t)\x00")).as_ptr());
    };
    xdg_surface_ack_configure(xdg_surface, serial);
    // nothing else?
}
static mut xdg_surface_listener: xdg_surface_listener =
    unsafe {
        {
            let mut init =
                xdg_surface_listener{configure:
                                         Some(xdg_surface_handle_configure as
                                                  unsafe extern "C" fn(_:
                                                                           *mut libc::c_void,
                                                                       _:
                                                                           *mut xdg_surface,
                                                                       _:
                                                                           uint32_t)
                                                      -> ()),};
            init
        }
    };
unsafe extern "C" fn xdg_toplevel_handle_configure(mut data:
                                                       *mut libc::c_void,
                                                   mut xdg_toplevel:
                                                       *mut xdg_toplevel,
                                                   mut width: int32_t,
                                                   mut height: int32_t,
                                                   mut states:
                                                       *mut wl_array) {
    let mut output: *mut wlr_wl_output = data as *mut wlr_wl_output;
    if !output.is_null() && (*output).xdg_toplevel == xdg_toplevel {
    } else {
        __assert_fail(b"output && output->xdg_toplevel == xdg_toplevel\x00" as
                          *const u8 as *const libc::c_char,
                      b"../backend/wayland/output.c\x00" as *const u8 as
                          *const libc::c_char, 417i32 as libc::c_uint,
                      (*::std::mem::transmute::<&[u8; 103],
                                                &[libc::c_char; 103]>(b"void xdg_toplevel_handle_configure(void *, struct xdg_toplevel *, int32_t, int32_t, struct wl_array *)\x00")).as_ptr());
    };
    if width == 0i32 || height == 0i32 { return }
    // loop over states for maximized etc?
    output_set_custom_mode(&mut (*output).wlr_output, width, height, 0i32);
}
unsafe extern "C" fn xdg_toplevel_handle_close(mut data: *mut libc::c_void,
                                               mut xdg_toplevel:
                                                   *mut xdg_toplevel) {
    let mut output: *mut wlr_wl_output = data as *mut wlr_wl_output;
    if !output.is_null() && (*output).xdg_toplevel == xdg_toplevel {
    } else {
        __assert_fail(b"output && output->xdg_toplevel == xdg_toplevel\x00" as
                          *const u8 as *const libc::c_char,
                      b"../backend/wayland/output.c\x00" as *const u8 as
                          *const libc::c_char, 429i32 as libc::c_uint,
                      (*::std::mem::transmute::<&[u8; 62],
                                                &[libc::c_char; 62]>(b"void xdg_toplevel_handle_close(void *, struct xdg_toplevel *)\x00")).as_ptr());
    };
    wlr_output_destroy(output as *mut wlr_output);
}
static mut xdg_toplevel_listener: xdg_toplevel_listener =
    unsafe {
        {
            let mut init =
                xdg_toplevel_listener{configure:
                                          Some(xdg_toplevel_handle_configure
                                                   as
                                                   unsafe extern "C" fn(_:
                                                                            *mut libc::c_void,
                                                                        _:
                                                                            *mut xdg_toplevel,
                                                                        _:
                                                                            int32_t,
                                                                        _:
                                                                            int32_t,
                                                                        _:
                                                                            *mut wl_array)
                                                       -> ()),
                                      close:
                                          Some(xdg_toplevel_handle_close as
                                                   unsafe extern "C" fn(_:
                                                                            *mut libc::c_void,
                                                                        _:
                                                                            *mut xdg_toplevel)
                                                       -> ()),};
            init
        }
    };
#[no_mangle]
pub unsafe extern "C" fn wlr_wl_output_create(mut wlr_backend:
                                                  *mut wlr_backend)
 -> *mut wlr_output {
    let mut current_block: u64;
    let mut backend: *mut wlr_wl_backend =
        get_wl_backend_from_backend(wlr_backend);
    if !(*backend).started {
        (*backend).requested_outputs =
            (*backend).requested_outputs.wrapping_add(1);
        return 0 as *mut wlr_output
    }
    let mut output: *mut wlr_wl_output = 0 as *mut wlr_wl_output;
    output =
        calloc(::std::mem::size_of::<wlr_wl_output>() as libc::c_ulong,
               1i32 as libc::c_ulong) as *mut wlr_wl_output;
    if output.is_null() {
        _wlr_log(WLR_ERROR,
                 b"[%s:%d] Failed to allocate wlr_wl_output\x00" as *const u8
                     as *const libc::c_char,
                 b"../backend/wayland/output.c\x00" as *const u8 as
                     *const libc::c_char, 448i32);
        return 0 as *mut wlr_output
    }
    wlr_output_init(&mut (*output).wlr_output, &mut (*backend).backend,
                    &output_impl, (*backend).local_display);
    let mut wlr_output: *mut wlr_output = &mut (*output).wlr_output;
    wlr_output_update_custom_mode(wlr_output, 1280i32, 720i32, 0i32);
    strncpy((*wlr_output).make.as_mut_ptr(),
            b"wayland\x00" as *const u8 as *const libc::c_char,
            ::std::mem::size_of::<[libc::c_char; 56]>() as libc::c_ulong);
    strncpy((*wlr_output).model.as_mut_ptr(),
            b"wayland\x00" as *const u8 as *const libc::c_char,
            ::std::mem::size_of::<[libc::c_char; 16]>() as libc::c_ulong);
    (*backend).last_output_num = (*backend).last_output_num.wrapping_add(1);
    snprintf((*wlr_output).name.as_mut_ptr(),
             ::std::mem::size_of::<[libc::c_char; 24]>() as libc::c_ulong,
             b"WL-%zd\x00" as *const u8 as *const libc::c_char,
             (*backend).last_output_num);
    (*output).backend = backend;
    wl_list_init(&mut (*output).presentation_feedbacks);
    (*output).surface = wl_compositor_create_surface((*backend).compositor);
    if (*output).surface.is_null() {
        _wlr_log(WLR_ERROR,
                 b"[%s:%d] Could not create output surface: %s\x00" as
                     *const u8 as *const libc::c_char,
                 b"../backend/wayland/output.c\x00" as *const u8 as
                     *const libc::c_char, 466i32,
                 strerror(*__errno_location()));
    } else {
        wl_surface_set_user_data((*output).surface,
                                 output as *mut libc::c_void);
        (*output).xdg_surface =
            xdg_wm_base_get_xdg_surface((*backend).xdg_wm_base,
                                        (*output).surface);
        if (*output).xdg_surface.is_null() {
            _wlr_log(WLR_ERROR,
                     b"[%s:%d] Could not get xdg surface: %s\x00" as *const u8
                         as *const libc::c_char,
                     b"../backend/wayland/output.c\x00" as *const u8 as
                         *const libc::c_char, 473i32,
                     strerror(*__errno_location()));
        } else {
            (*output).xdg_toplevel =
                xdg_surface_get_toplevel((*output).xdg_surface);
            if (*output).xdg_toplevel.is_null() {
                _wlr_log(WLR_ERROR,
                         b"[%s:%d] Could not get xdg toplevel: %s\x00" as
                             *const u8 as *const libc::c_char,
                         b"../backend/wayland/output.c\x00" as *const u8 as
                             *const libc::c_char, 479i32,
                         strerror(*__errno_location()));
            } else {
                if !(*backend).zxdg_decoration_manager_v1.is_null() {
                    (*output).zxdg_toplevel_decoration_v1 =
                        zxdg_decoration_manager_v1_get_toplevel_decoration((*backend).zxdg_decoration_manager_v1,
                                                                           (*output).xdg_toplevel);
                    if (*output).zxdg_toplevel_decoration_v1.is_null() {
                        _wlr_log(WLR_ERROR,
                                 b"[%s:%d] Could not get xdg toplevel decoration: %s\x00"
                                     as *const u8 as *const libc::c_char,
                                 b"../backend/wayland/output.c\x00" as
                                     *const u8 as *const libc::c_char, 488i32,
                                 strerror(*__errno_location()));
                        current_block = 10309420061553805284;
                    } else {
                        zxdg_toplevel_decoration_v1_set_mode((*output).zxdg_toplevel_decoration_v1,
                                                             ZXDG_TOPLEVEL_DECORATION_V1_MODE_SERVER_SIDE
                                                                 as
                                                                 libc::c_int
                                                                 as uint32_t);
                        current_block = 17788412896529399552;
                    }
                } else { current_block = 17788412896529399552; }
                match current_block {
                    10309420061553805284 => { }
                    _ => {
                        wlr_wl_output_set_title(wlr_output,
                                                0 as *const libc::c_char);
                        xdg_toplevel_set_app_id((*output).xdg_toplevel,
                                                b"wlroots\x00" as *const u8 as
                                                    *const libc::c_char);
                        xdg_surface_add_listener((*output).xdg_surface,
                                                 &mut xdg_surface_listener,
                                                 output as *mut libc::c_void);
                        xdg_toplevel_add_listener((*output).xdg_toplevel,
                                                  &mut xdg_toplevel_listener,
                                                  output as
                                                      *mut libc::c_void);
                        wl_surface_commit((*output).surface);
                        (*output).egl_window =
                            wl_egl_window_create((*output).surface,
                                                 (*wlr_output).width,
                                                 (*wlr_output).height);
                        (*output).egl_surface =
                            wlr_egl_create_surface(&mut (*backend).egl,
                                                   (*output).egl_window as
                                                       *mut libc::c_void);
                        wl_display_roundtrip((*(*output).backend).remote_display);
                        // start rendering loop per callbacks by rendering first frame
                        if wlr_egl_make_current(&mut (*(*output).backend).egl,
                                                (*output).egl_surface,
                                                0 as *mut libc::c_int) {
                            wlr_renderer_begin((*backend).renderer,
                                               (*wlr_output).width,
                                               (*wlr_output).height);
                            wlr_renderer_clear((*backend).renderer,
                                               [1.0f64 as libc::c_float,
                                                1.0f64 as libc::c_float,
                                                1.0f64 as libc::c_float,
                                                1.0f64 as
                                                    libc::c_float].as_mut_ptr()
                                                   as *const libc::c_float);
                            wlr_renderer_end((*backend).renderer);
                            (*output).frame_callback =
                                wl_surface_frame((*output).surface);
                            wl_callback_add_listener((*output).frame_callback,
                                                     &frame_listener,
                                                     output as
                                                         *mut libc::c_void);
                            if wlr_egl_swap_buffers(&mut (*(*output).backend).egl,
                                                    (*output).egl_surface,
                                                    0 as
                                                        *mut pixman_region32_t)
                               {
                                wl_list_insert(&mut (*backend).outputs,
                                               &mut (*output).link);
                                wlr_output_update_enabled(wlr_output,
                                                          1i32 != 0);
                                wlr_signal_emit_safe(&mut (*backend).backend.events.new_output,
                                                     wlr_output as
                                                         *mut libc::c_void);
                                if !(*backend).pointer.is_null() {
                                    create_wl_pointer((*backend).pointer,
                                                      output);
                                }
                                return wlr_output
                            }
                        }
                    }
                }
            }
        }
    }
    wlr_output_destroy(&mut (*output).wlr_output);
    return 0 as *mut wlr_output;
}
#[no_mangle]
pub unsafe extern "C" fn wlr_wl_output_set_title(mut output: *mut wlr_output,
                                                 mut title:
                                                     *const libc::c_char) {
    let mut wl_output: *mut wlr_wl_output = get_wl_output_from_output(output);
    let mut wl_title: [libc::c_char; 32] = [0; 32];
    if title.is_null() {
        if snprintf(wl_title.as_mut_ptr(),
                    ::std::mem::size_of::<[libc::c_char; 32]>() as
                        libc::c_ulong,
                    b"wlroots - %s\x00" as *const u8 as *const libc::c_char,
                    (*output).name.as_mut_ptr()) <= 0i32 {
            return
        }
        title = wl_title.as_mut_ptr()
    }
    xdg_toplevel_set_title((*wl_output).xdg_toplevel, title);
}
/* *
 * Adds a new output to this backend. You may remove outputs by destroying them.
 * Note that if called before initializing the backend, this will return NULL
 * and your outputs will be created during initialization (and given to you via
 * the output_add signal).
 */
/* *
 * True if the given backend is a wlr_wl_backend.
 */
/* *
 * True if the given input device is a wlr_wl_input_device.
 */
/* *
 * True if the given output is a wlr_wl_output.
 */
/* *
 * Sets the title of a wlr_output which is a Wayland window.
 */
/* *
 * Returns the remote wl_surface used by the Wayland output.
 */
#[no_mangle]
pub unsafe extern "C" fn wlr_wl_output_get_surface(mut output:
                                                       *mut wlr_output)
 -> *mut wl_surface {
    let mut wl_output: *mut wlr_wl_output = get_wl_output_from_output(output);
    return (*wl_output).surface;
}
