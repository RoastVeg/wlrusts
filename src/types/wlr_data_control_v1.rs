use libc;
extern "C" {
    pub type wl_display;
    /* Generated by wayland-scanner 1.17.0 */
    pub type wl_client;
    pub type wl_global;
    pub type xkb_keymap;
    pub type xkb_state;
    pub type wlr_keyboard_impl;
    pub type wlr_keyboard_group;
    pub type wlr_texture;
    pub type wlr_renderer;
    #[no_mangle]
    fn __assert_fail(__assertion: *const libc::c_char,
                     __file: *const libc::c_char, __line: libc::c_uint,
                     __function: *const libc::c_char) -> !;
    #[no_mangle]
    fn calloc(_: libc::c_ulong, _: libc::c_ulong) -> *mut libc::c_void;
    #[no_mangle]
    fn free(__ptr: *mut libc::c_void);
    #[no_mangle]
    fn strcmp(_: *const libc::c_char, _: *const libc::c_char) -> libc::c_int;
    #[no_mangle]
    fn strdup(__s: *const libc::c_char) -> *mut libc::c_char;
    #[no_mangle]
    fn close(__fd: libc::c_int) -> libc::c_int;
    #[no_mangle]
    fn wl_display_next_serial(display: *mut wl_display) -> uint32_t;
    #[no_mangle]
    fn wl_display_add_destroy_listener(display: *mut wl_display,
                                       listener: *mut wl_listener);
    #[no_mangle]
    fn wl_global_create(display: *mut wl_display,
                        interface: *const wl_interface, version: libc::c_int,
                        data: *mut libc::c_void, bind: wl_global_bind_func_t)
     -> *mut wl_global;
    #[no_mangle]
    fn wl_global_destroy(global: *mut wl_global);
    #[no_mangle]
    fn wl_client_post_no_memory(client: *mut wl_client);
    #[no_mangle]
    fn wl_resource_post_event(resource: *mut wl_resource, opcode: uint32_t,
                              _: ...);
    #[no_mangle]
    fn wl_resource_post_error(resource: *mut wl_resource, code: uint32_t,
                              msg: *const libc::c_char, _: ...);
    #[no_mangle]
    fn wl_resource_post_no_memory(resource: *mut wl_resource);
    #[no_mangle]
    fn wl_resource_create(client: *mut wl_client,
                          interface: *const wl_interface,
                          version: libc::c_int, id: uint32_t)
     -> *mut wl_resource;
    #[no_mangle]
    fn wl_resource_set_implementation(resource: *mut wl_resource,
                                      implementation: *const libc::c_void,
                                      data: *mut libc::c_void,
                                      destroy: wl_resource_destroy_func_t);
    #[no_mangle]
    fn wl_resource_destroy(resource: *mut wl_resource);
    #[no_mangle]
    fn wl_resource_get_client(resource: *mut wl_resource) -> *mut wl_client;
    #[no_mangle]
    fn wl_resource_set_user_data(resource: *mut wl_resource,
                                 data: *mut libc::c_void);
    #[no_mangle]
    fn wl_resource_get_user_data(resource: *mut wl_resource)
     -> *mut libc::c_void;
    #[no_mangle]
    fn wl_resource_get_version(resource: *mut wl_resource) -> libc::c_int;
    #[no_mangle]
    fn wl_resource_instance_of(resource: *mut wl_resource,
                               interface: *const wl_interface,
                               implementation: *const libc::c_void)
     -> libc::c_int;
    #[no_mangle]
    fn wl_list_init(list: *mut wl_list);
    #[no_mangle]
    fn wl_list_insert(list: *mut wl_list, elm: *mut wl_list);
    #[no_mangle]
    fn wl_list_remove(elm: *mut wl_list);
    #[no_mangle]
    fn wl_array_init(array: *mut wl_array);
    #[no_mangle]
    fn wl_array_release(array: *mut wl_array);
    #[no_mangle]
    fn wl_array_add(array: *mut wl_array, size: size_t) -> *mut libc::c_void;
    #[no_mangle]
    fn wlr_seat_client_from_resource(resource: *mut wl_resource)
     -> *mut wlr_seat_client;
    /* *
 * Requests a selection to be set for the seat. If the request comes from
 * a client, then set `client` to be the matching seat client so that this
 * function can verify that the serial provided was once sent to the client
 * on this seat.
 */
    #[no_mangle]
    fn wlr_seat_request_set_selection(seat: *mut wlr_seat,
                                      client: *mut wlr_seat_client,
                                      source: *mut wlr_data_source,
                                      serial: uint32_t);
    /* *
 * Initializes the data source with the provided implementation.
 */
    #[no_mangle]
    fn wlr_data_source_init(source: *mut wlr_data_source,
                            impl_0: *const wlr_data_source_impl);
    /* *
 * Sends the data as the specified MIME type over the passed file descriptor,
 * then close it.
 */
    #[no_mangle]
    fn wlr_data_source_send(source: *mut wlr_data_source,
                            mime_type: *const libc::c_char, fd: int32_t);
    /* *
 * Notifies the data source it is no longer valid and should be destroyed. That
 * destroys immediately the data source.
 */
    #[no_mangle]
    fn wlr_data_source_destroy(source: *mut wlr_data_source);
    #[no_mangle]
    fn wlr_primary_selection_source_init(source:
                                             *mut wlr_primary_selection_source,
                                         impl_0:
                                             *const wlr_primary_selection_source_impl);
    #[no_mangle]
    fn wlr_primary_selection_source_destroy(source:
                                                *mut wlr_primary_selection_source);
    #[no_mangle]
    fn wlr_primary_selection_source_send(source:
                                             *mut wlr_primary_selection_source,
                                         mime_type: *const libc::c_char,
                                         fd: libc::c_int);
    /* *
 * Request setting the primary selection. If `client` is not null, then the
 * serial will be checked against the set of serials sent to the client on that
 * seat.
 */
    #[no_mangle]
    fn wlr_seat_request_set_primary_selection(seat: *mut wlr_seat,
                                              client: *mut wlr_seat_client,
                                              source:
                                                  *mut wlr_primary_selection_source,
                                              serial: uint32_t);
    #[no_mangle]
    fn _wlr_log(verbosity: wlr_log_importance, format: *const libc::c_char,
                _: ...);
    #[no_mangle]
    fn wlr_signal_emit_safe(signal: *mut wl_signal, data: *mut libc::c_void);
    /* *
 * @page page_iface_zwlr_data_control_manager_v1 zwlr_data_control_manager_v1
 * @section page_iface_zwlr_data_control_manager_v1_desc Description
 *
 * This interface is a manager that allows creating per-seat data device
 * controls.
 * @section page_iface_zwlr_data_control_manager_v1_api API
 * See @ref iface_zwlr_data_control_manager_v1.
 */
/* *
 * @defgroup iface_zwlr_data_control_manager_v1 The zwlr_data_control_manager_v1 interface
 *
 * This interface is a manager that allows creating per-seat data device
 * controls.
 */
    #[no_mangle]
    static zwlr_data_control_manager_v1_interface: wl_interface;
    /* *
 * @page page_iface_zwlr_data_control_device_v1 zwlr_data_control_device_v1
 * @section page_iface_zwlr_data_control_device_v1_desc Description
 *
 * This interface allows a client to manage a seat's selection.
 *
 * When the seat is destroyed, this object becomes inert.
 * @section page_iface_zwlr_data_control_device_v1_api API
 * See @ref iface_zwlr_data_control_device_v1.
 */
/* *
 * @defgroup iface_zwlr_data_control_device_v1 The zwlr_data_control_device_v1 interface
 *
 * This interface allows a client to manage a seat's selection.
 *
 * When the seat is destroyed, this object becomes inert.
 */
    #[no_mangle]
    static zwlr_data_control_device_v1_interface: wl_interface;
    /* *
 * @page page_iface_zwlr_data_control_source_v1 zwlr_data_control_source_v1
 * @section page_iface_zwlr_data_control_source_v1_desc Description
 *
 * The wlr_data_control_source object is the source side of a
 * wlr_data_control_offer. It is created by the source client in a data
 * transfer and provides a way to describe the offered data and a way to
 * respond to requests to transfer the data.
 * @section page_iface_zwlr_data_control_source_v1_api API
 * See @ref iface_zwlr_data_control_source_v1.
 */
/* *
 * @defgroup iface_zwlr_data_control_source_v1 The zwlr_data_control_source_v1 interface
 *
 * The wlr_data_control_source object is the source side of a
 * wlr_data_control_offer. It is created by the source client in a data
 * transfer and provides a way to describe the offered data and a way to
 * respond to requests to transfer the data.
 */
    #[no_mangle]
    static zwlr_data_control_source_v1_interface: wl_interface;
    /* *
 * @page page_iface_zwlr_data_control_offer_v1 zwlr_data_control_offer_v1
 * @section page_iface_zwlr_data_control_offer_v1_desc Description
 *
 * A wlr_data_control_offer represents a piece of data offered for transfer
 * by another client (the source client). The offer describes the different
 * MIME types that the data can be converted to and provides the mechanism
 * for transferring the data directly from the source client.
 * @section page_iface_zwlr_data_control_offer_v1_api API
 * See @ref iface_zwlr_data_control_offer_v1.
 */
/* *
 * @defgroup iface_zwlr_data_control_offer_v1 The zwlr_data_control_offer_v1 interface
 *
 * A wlr_data_control_offer represents a piece of data offered for transfer
 * by another client (the source client). The offer describes the different
 * MIME types that the data can be converted to and provides the mechanism
 * for transferring the data directly from the source client.
 */
    #[no_mangle]
    static zwlr_data_control_offer_v1_interface: wl_interface;
}
pub type size_t = libc::c_ulong;
pub type __int32_t = libc::c_int;
pub type __uint32_t = libc::c_uint;
pub type __time_t = libc::c_long;
pub type __syscall_slong_t = libc::c_long;
pub type int32_t = __int32_t;
pub type uint32_t = __uint32_t;

#[repr(C)]#[derive(Copy, Clone)]
pub struct wl_object {
    pub interface: *const wl_interface,
    pub implementation: *const libc::c_void,
    pub id: uint32_t,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct wl_interface {
    pub name: *const libc::c_char,
    pub version: libc::c_int,
    pub method_count: libc::c_int,
    pub methods: *const wl_message,
    pub event_count: libc::c_int,
    pub events: *const wl_message,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct wl_message {
    pub name: *const libc::c_char,
    pub signature: *const libc::c_char,
    pub types: *mut *const wl_interface,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct wl_list {
    pub prev: *mut wl_list,
    pub next: *mut wl_list,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct wl_array {
    pub size: size_t,
    pub alloc: size_t,
    pub data: *mut libc::c_void,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct wl_listener {
    pub link: wl_list,
    pub notify: wl_notify_func_t,
}
pub type wl_notify_func_t
    =
    Option<unsafe extern "C" fn(_: *mut wl_listener, _: *mut libc::c_void)
               -> ()>;
pub type wl_global_bind_func_t
    =
    Option<unsafe extern "C" fn(_: *mut wl_client, _: *mut libc::c_void,
                                _: uint32_t, _: uint32_t) -> ()>;

#[repr(C)]#[derive(Copy, Clone)]
pub struct wl_resource {
    pub object: wl_object,
    pub destroy: wl_resource_destroy_func_t,
    pub link: wl_list,
    pub destroy_signal: wl_signal,
    pub client: *mut wl_client,
    pub data: *mut libc::c_void,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct wl_signal {
    pub listener_list: wl_list,
}
pub type wl_resource_destroy_func_t
    =
    Option<unsafe extern "C" fn(_: *mut wl_resource) -> ()>;

#[repr(C)]#[derive(Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
/*
 * This an unstable interface of wlroots. No guarantees are made regarding the
 * future consistency of this API.
 */
pub type wlr_button_state = libc::c_uint;
pub const WLR_BUTTON_PRESSED: wlr_button_state = 1;
pub const WLR_BUTTON_RELEASED: wlr_button_state = 0;
pub type xkb_mod_index_t = uint32_t;
pub type xkb_mod_mask_t = uint32_t;
pub type xkb_led_index_t = uint32_t;

#[repr(C)]#[derive(Copy, Clone)]
pub struct wlr_keyboard_modifiers {
    pub depressed: xkb_mod_mask_t,
    pub latched: xkb_mod_mask_t,
    pub locked: xkb_mod_mask_t,
    pub group: xkb_mod_mask_t,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct wlr_keyboard {
    pub impl_0: *const crate::src::backend::headless::input_device::wlr_keyboard_impl,
    pub group: *mut crate::src::types::wlr_keyboard_group::wlr_keyboard_group,
    pub keymap_string: *mut libc::c_char,
    pub keymap_size: size_t,
    pub keymap: *mut xkb_keymap,
    pub xkb_state: *mut xkb_state,
    pub led_indexes: [xkb_led_index_t; 3],
    pub mod_indexes: [xkb_mod_index_t; 8],
    pub keycodes: [uint32_t; 32],
    pub num_keycodes: size_t,
    pub modifiers: wlr_keyboard_modifiers,
    pub repeat_info: C2RustUnnamed_0,
    pub events: C2RustUnnamed,
    pub data: *mut libc::c_void,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct C2RustUnnamed {
    pub key: wl_signal,
    pub modifiers: wl_signal,
    pub keymap: wl_signal,
    pub repeat_info: wl_signal,
    pub destroy: wl_signal,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct C2RustUnnamed_0 {
    pub rate: int32_t,
    pub delay: int32_t,
}
pub type wlr_axis_source = libc::c_uint;
pub const WLR_AXIS_SOURCE_WHEEL_TILT: wlr_axis_source = 3;
pub const WLR_AXIS_SOURCE_CONTINUOUS: wlr_axis_source = 2;
pub const WLR_AXIS_SOURCE_FINGER: wlr_axis_source = 1;
pub const WLR_AXIS_SOURCE_WHEEL: wlr_axis_source = 0;
pub type wlr_axis_orientation = libc::c_uint;
pub const WLR_AXIS_ORIENTATION_HORIZONTAL: wlr_axis_orientation = 1;
pub const WLR_AXIS_ORIENTATION_VERTICAL: wlr_axis_orientation = 0;
/*
 * 32 bit regions
 */

#[repr(C)]#[derive(Copy, Clone)]
pub struct pixman_region32_data {
    pub size: libc::c_long,
    pub numRects: libc::c_long,
}
pub type pixman_region32_data_t = pixman_region32_data;

#[repr(C)]#[derive(Copy, Clone)]
pub struct pixman_box32 {
    pub x1: int32_t,
    pub y1: int32_t,
    pub x2: int32_t,
    pub y2: int32_t,
}
pub type pixman_box32_t = pixman_box32;

#[repr(C)]#[derive(Copy, Clone)]
pub struct pixman_region32 {
    pub extents: pixman_box32_t,
    pub data: *mut pixman_region32_data_t,
}
pub type pixman_region32_t = pixman_region32;
pub type wl_data_device_manager_dnd_action = libc::c_uint;
pub const WL_DATA_DEVICE_MANAGER_DND_ACTION_ASK:
          wl_data_device_manager_dnd_action =
    4;
pub const WL_DATA_DEVICE_MANAGER_DND_ACTION_MOVE:
          wl_data_device_manager_dnd_action =
    2;
pub const WL_DATA_DEVICE_MANAGER_DND_ACTION_COPY:
          wl_data_device_manager_dnd_action =
    1;
pub const WL_DATA_DEVICE_MANAGER_DND_ACTION_NONE:
          wl_data_device_manager_dnd_action =
    0;
pub type wl_output_transform = libc::c_uint;
pub const WL_OUTPUT_TRANSFORM_FLIPPED_270: wl_output_transform = 7;
pub const WL_OUTPUT_TRANSFORM_FLIPPED_180: wl_output_transform = 6;
pub const WL_OUTPUT_TRANSFORM_FLIPPED_90: wl_output_transform = 5;
pub const WL_OUTPUT_TRANSFORM_FLIPPED: wl_output_transform = 4;
pub const WL_OUTPUT_TRANSFORM_270: wl_output_transform = 3;
pub const WL_OUTPUT_TRANSFORM_180: wl_output_transform = 2;
pub const WL_OUTPUT_TRANSFORM_90: wl_output_transform = 1;
pub const WL_OUTPUT_TRANSFORM_NORMAL: wl_output_transform = 0;
/*
 * This an unstable interface of wlroots. No guarantees are made regarding the
 * future consistency of this API.
 */
/* *
 * A client buffer.
 */

#[repr(C)]#[derive(Copy, Clone)]
pub struct wlr_buffer {
    pub resource: *mut wl_resource,
    pub texture: *mut crate::src::backend::drm::atomic::wlr_texture,
    pub released: bool,
    pub n_refs: size_t,
    pub resource_destroy: wl_listener,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct wlr_surface {
    pub resource: *mut wl_resource,
    pub renderer: *mut crate::src::backend::drm::atomic::wlr_renderer,
    pub buffer: *mut wlr_buffer,
    pub sx: libc::c_int,
    pub sy: libc::c_int,
    pub buffer_damage: pixman_region32_t,
    pub opaque_region: pixman_region32_t,
    pub input_region: pixman_region32_t,
    pub current: wlr_surface_state,
    pub pending: wlr_surface_state,
    pub previous: wlr_surface_state,
    pub role: *const wlr_surface_role,
    pub role_data: *mut libc::c_void,
    pub events: C2RustUnnamed_1,
    pub subsurfaces: wl_list,
    pub subsurface_pending_list: wl_list,
    pub renderer_destroy: wl_listener,
    pub data: *mut libc::c_void,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct C2RustUnnamed_1 {
    pub commit: wl_signal,
    pub new_subsurface: wl_signal,
    pub destroy: wl_signal,
}
/*
 * This an unstable interface of wlroots. No guarantees are made regarding the
 * future consistency of this API.
 */
// enum wlr_surface_state_field
// relative to previous position
// clipped to bounds
// wl_resource
// in surface-local coordinates

#[repr(C)]#[derive(Copy, Clone)]
pub struct wlr_surface_role {
    pub name: *const libc::c_char,
    pub commit: Option<unsafe extern "C" fn(_: *mut wlr_surface) -> ()>,
    pub precommit: Option<unsafe extern "C" fn(_: *mut wlr_surface) -> ()>,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct wlr_surface_state {
    pub committed: uint32_t,
    pub buffer_resource: *mut wl_resource,
    pub dx: int32_t,
    pub dy: int32_t,
    pub surface_damage: pixman_region32_t,
    pub buffer_damage: pixman_region32_t,
    pub opaque: pixman_region32_t,
    pub input: pixman_region32_t,
    pub transform: wl_output_transform,
    pub scale: int32_t,
    pub frame_callback_list: wl_list,
    pub width: libc::c_int,
    pub height: libc::c_int,
    pub buffer_width: libc::c_int,
    pub buffer_height: libc::c_int,
    pub buffer_destroy: wl_listener,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct wlr_serial_range {
    pub min_incl: uint32_t,
    pub max_incl: uint32_t,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct wlr_serial_ringset {
    pub data: [wlr_serial_range; 128],
    pub end: libc::c_int,
    pub count: libc::c_int,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct wlr_seat_client {
    pub client: *mut wl_client,
    pub seat: *mut wlr_seat,
    pub link: wl_list,
    pub resources: wl_list,
    pub pointers: wl_list,
    pub keyboards: wl_list,
    pub touches: wl_list,
    pub data_devices: wl_list,
    pub events: C2RustUnnamed_2,
    pub serials: wlr_serial_ringset,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct C2RustUnnamed_2 {
    pub destroy: wl_signal,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct wlr_seat {
    pub global: *mut wl_global,
    pub display: *mut wl_display,
    pub clients: wl_list,
    pub name: *mut libc::c_char,
    pub capabilities: uint32_t,
    pub last_event: timespec,
    pub selection_source: *mut wlr_data_source,
    pub selection_serial: uint32_t,
    pub selection_offers: wl_list,
    pub primary_selection_source: *mut wlr_primary_selection_source,
    pub primary_selection_serial: uint32_t,
    pub drag: *mut wlr_drag,
    pub drag_source: *mut wlr_data_source,
    pub drag_serial: uint32_t,
    pub drag_offers: wl_list,
    pub pointer_state: wlr_seat_pointer_state,
    pub keyboard_state: wlr_seat_keyboard_state,
    pub touch_state: wlr_seat_touch_state,
    pub display_destroy: wl_listener,
    pub selection_source_destroy: wl_listener,
    pub primary_selection_source_destroy: wl_listener,
    pub drag_source_destroy: wl_listener,
    pub events: C2RustUnnamed_3,
    pub data: *mut libc::c_void,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct C2RustUnnamed_3 {
    pub pointer_grab_begin: wl_signal,
    pub pointer_grab_end: wl_signal,
    pub keyboard_grab_begin: wl_signal,
    pub keyboard_grab_end: wl_signal,
    pub touch_grab_begin: wl_signal,
    pub touch_grab_end: wl_signal,
    pub request_set_cursor: wl_signal,
    pub request_set_selection: wl_signal,
    pub set_selection: wl_signal,
    pub request_set_primary_selection: wl_signal,
    pub set_primary_selection: wl_signal,
    pub request_start_drag: wl_signal,
    pub start_drag: wl_signal,
    pub destroy: wl_signal,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct wlr_seat_touch_state {
    pub seat: *mut wlr_seat,
    pub touch_points: wl_list,
    pub grab_serial: uint32_t,
    pub grab_id: uint32_t,
    pub grab: *mut wlr_seat_touch_grab,
    pub default_grab: *mut wlr_seat_touch_grab,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct wlr_seat_touch_grab {
    pub interface: *const wlr_touch_grab_interface,
    pub seat: *mut wlr_seat,
    pub data: *mut libc::c_void,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct wlr_touch_grab_interface {
    pub down: Option<unsafe extern "C" fn(_: *mut wlr_seat_touch_grab,
                                          _: uint32_t,
                                          _: *mut wlr_touch_point)
                         -> uint32_t>,
    pub up: Option<unsafe extern "C" fn(_: *mut wlr_seat_touch_grab,
                                        _: uint32_t, _: *mut wlr_touch_point)
                       -> ()>,
    pub motion: Option<unsafe extern "C" fn(_: *mut wlr_seat_touch_grab,
                                            _: uint32_t,
                                            _: *mut wlr_touch_point) -> ()>,
    pub enter: Option<unsafe extern "C" fn(_: *mut wlr_seat_touch_grab,
                                           _: uint32_t,
                                           _: *mut wlr_touch_point) -> ()>,
    pub cancel: Option<unsafe extern "C" fn(_: *mut wlr_seat_touch_grab)
                           -> ()>,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct wlr_touch_point {
    pub touch_id: int32_t,
    pub surface: *mut wlr_surface,
    pub client: *mut wlr_seat_client,
    pub focus_surface: *mut wlr_surface,
    pub focus_client: *mut wlr_seat_client,
    pub sx: libc::c_double,
    pub sy: libc::c_double,
    pub surface_destroy: wl_listener,
    pub focus_surface_destroy: wl_listener,
    pub client_destroy: wl_listener,
    pub events: C2RustUnnamed_4,
    pub link: wl_list,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct C2RustUnnamed_4 {
    pub destroy: wl_signal,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct wlr_seat_keyboard_state {
    pub seat: *mut wlr_seat,
    pub keyboard: *mut wlr_keyboard,
    pub focused_client: *mut wlr_seat_client,
    pub focused_surface: *mut wlr_surface,
    pub keyboard_destroy: wl_listener,
    pub keyboard_keymap: wl_listener,
    pub keyboard_repeat_info: wl_listener,
    pub surface_destroy: wl_listener,
    pub grab: *mut wlr_seat_keyboard_grab,
    pub default_grab: *mut wlr_seat_keyboard_grab,
    pub events: C2RustUnnamed_5,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct C2RustUnnamed_5 {
    pub focus_change: wl_signal,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct wlr_seat_keyboard_grab {
    pub interface: *const wlr_keyboard_grab_interface,
    pub seat: *mut wlr_seat,
    pub data: *mut libc::c_void,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct wlr_keyboard_grab_interface {
    pub enter: Option<unsafe extern "C" fn(_: *mut wlr_seat_keyboard_grab,
                                           _: *mut wlr_surface,
                                           _: *mut uint32_t, _: size_t,
                                           _: *mut wlr_keyboard_modifiers)
                          -> ()>,
    pub key: Option<unsafe extern "C" fn(_: *mut wlr_seat_keyboard_grab,
                                         _: uint32_t, _: uint32_t,
                                         _: uint32_t) -> ()>,
    pub modifiers: Option<unsafe extern "C" fn(_: *mut wlr_seat_keyboard_grab,
                                               _: *mut wlr_keyboard_modifiers)
                              -> ()>,
    pub cancel: Option<unsafe extern "C" fn(_: *mut wlr_seat_keyboard_grab)
                           -> ()>,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct wlr_seat_pointer_state {
    pub seat: *mut wlr_seat,
    pub focused_client: *mut wlr_seat_client,
    pub focused_surface: *mut wlr_surface,
    pub sx: libc::c_double,
    pub sy: libc::c_double,
    pub grab: *mut wlr_seat_pointer_grab,
    pub default_grab: *mut wlr_seat_pointer_grab,
    pub buttons: [uint32_t; 16],
    pub button_count: size_t,
    pub grab_button: uint32_t,
    pub grab_serial: uint32_t,
    pub grab_time: uint32_t,
    pub surface_destroy: wl_listener,
    pub events: C2RustUnnamed_6,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct C2RustUnnamed_6 {
    pub focus_change: wl_signal,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct wlr_seat_pointer_grab {
    pub interface: *const wlr_pointer_grab_interface,
    pub seat: *mut wlr_seat,
    pub data: *mut libc::c_void,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct wlr_pointer_grab_interface {
    pub enter: Option<unsafe extern "C" fn(_: *mut wlr_seat_pointer_grab,
                                           _: *mut wlr_surface,
                                           _: libc::c_double,
                                           _: libc::c_double) -> ()>,
    pub motion: Option<unsafe extern "C" fn(_: *mut wlr_seat_pointer_grab,
                                            _: uint32_t, _: libc::c_double,
                                            _: libc::c_double) -> ()>,
    pub button: Option<unsafe extern "C" fn(_: *mut wlr_seat_pointer_grab,
                                            _: uint32_t, _: uint32_t,
                                            _: wlr_button_state) -> uint32_t>,
    pub axis: Option<unsafe extern "C" fn(_: *mut wlr_seat_pointer_grab,
                                          _: uint32_t,
                                          _: wlr_axis_orientation,
                                          _: libc::c_double, _: int32_t,
                                          _: wlr_axis_source) -> ()>,
    pub frame: Option<unsafe extern "C" fn(_: *mut wlr_seat_pointer_grab)
                          -> ()>,
    pub cancel: Option<unsafe extern "C" fn(_: *mut wlr_seat_pointer_grab)
                           -> ()>,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct wlr_data_source {
    pub impl_0: *const wlr_data_source_impl,
    pub mime_types: wl_array,
    pub actions: int32_t,
    pub accepted: bool,
    pub current_dnd_action: wl_data_device_manager_dnd_action,
    pub compositor_action: uint32_t,
    pub events: C2RustUnnamed_7,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct C2RustUnnamed_7 {
    pub destroy: wl_signal,
}
/* *
 * A data source implementation. Only the `send` function is mandatory. Refer to
 * the matching wl_data_source_* functions documentation to know what they do.
 */

#[repr(C)]#[derive(Copy, Clone)]
pub struct wlr_data_source_impl {
    pub send: Option<unsafe extern "C" fn(_: *mut wlr_data_source,
                                          _: *const libc::c_char, _: int32_t)
                         -> ()>,
    pub accept: Option<unsafe extern "C" fn(_: *mut wlr_data_source,
                                            _: uint32_t,
                                            _: *const libc::c_char) -> ()>,
    pub destroy: Option<unsafe extern "C" fn(_: *mut wlr_data_source) -> ()>,
    pub dnd_drop: Option<unsafe extern "C" fn(_: *mut wlr_data_source) -> ()>,
    pub dnd_finish: Option<unsafe extern "C" fn(_: *mut wlr_data_source)
                               -> ()>,
    pub dnd_action: Option<unsafe extern "C" fn(_: *mut wlr_data_source,
                                                _:
                                                    wl_data_device_manager_dnd_action)
                               -> ()>,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct wlr_drag {
    pub grab_type: wlr_drag_grab_type,
    pub keyboard_grab: wlr_seat_keyboard_grab,
    pub pointer_grab: wlr_seat_pointer_grab,
    pub touch_grab: wlr_seat_touch_grab,
    pub seat: *mut wlr_seat,
    pub seat_client: *mut wlr_seat_client,
    pub focus_client: *mut wlr_seat_client,
    pub icon: *mut wlr_drag_icon,
    pub focus: *mut wlr_surface,
    pub source: *mut wlr_data_source,
    pub started: bool,
    pub dropped: bool,
    pub cancelling: bool,
    pub grab_touch_id: int32_t,
    pub touch_id: int32_t,
    pub events: C2RustUnnamed_8,
    pub point_destroy: wl_listener,
    pub source_destroy: wl_listener,
    pub seat_client_destroy: wl_listener,
    pub icon_destroy: wl_listener,
    pub data: *mut libc::c_void,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct C2RustUnnamed_8 {
    pub focus: wl_signal,
    pub motion: wl_signal,
    pub drop: wl_signal,
    pub destroy: wl_signal,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct wlr_drag_icon {
    pub drag: *mut wlr_drag,
    pub surface: *mut wlr_surface,
    pub mapped: bool,
    pub events: C2RustUnnamed_9,
    pub surface_destroy: wl_listener,
    pub data: *mut libc::c_void,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct C2RustUnnamed_9 {
    pub map: wl_signal,
    pub unmap: wl_signal,
    pub destroy: wl_signal,
}
pub type wlr_drag_grab_type = libc::c_uint;
pub const WLR_DRAG_GRAB_KEYBOARD_TOUCH: wlr_drag_grab_type = 2;
pub const WLR_DRAG_GRAB_KEYBOARD_POINTER: wlr_drag_grab_type = 1;
pub const WLR_DRAG_GRAB_KEYBOARD: wlr_drag_grab_type = 0;

#[repr(C)]#[derive(Copy, Clone)]
pub struct wlr_primary_selection_source {
    pub impl_0: *const wlr_primary_selection_source_impl,
    pub mime_types: wl_array,
    pub events: C2RustUnnamed_10,
    pub data: *mut libc::c_void,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct C2RustUnnamed_10 {
    pub destroy: wl_signal,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct wlr_primary_selection_source_impl {
    pub send: Option<unsafe extern "C" fn(_:
                                              *mut wlr_primary_selection_source,
                                          _: *const libc::c_char,
                                          _: libc::c_int) -> ()>,
    pub destroy: Option<unsafe extern "C" fn(_:
                                                 *mut wlr_primary_selection_source)
                            -> ()>,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct wlr_data_control_manager_v1 {
    pub global: *mut wl_global,
    pub devices: wl_list,
    pub events: C2RustUnnamed_11,
    pub display_destroy: wl_listener,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct C2RustUnnamed_11 {
    pub destroy: wl_signal,
    pub new_device: wl_signal,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct wlr_data_control_device_v1 {
    pub resource: *mut wl_resource,
    pub manager: *mut wlr_data_control_manager_v1,
    pub link: wl_list,
    pub seat: *mut wlr_seat,
    pub selection_offer_resource: *mut wl_resource,
    pub primary_selection_offer_resource: *mut wl_resource,
    pub seat_destroy: wl_listener,
    pub seat_set_selection: wl_listener,
    pub seat_set_primary_selection: wl_listener,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct data_control_source {
    pub resource: *mut wl_resource,
    pub mime_types: wl_array,
    pub finalized: bool,
    pub active_source: *mut wlr_data_source,
    pub active_primary_source: *mut wlr_primary_selection_source,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct data_offer {
    pub resource: *mut wl_resource,
    pub device: *mut wlr_data_control_device_v1,
    pub is_primary: bool,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct client_data_source {
    pub source: wlr_data_source,
    pub resource: *mut wl_resource,
}

#[repr(C)]#[derive(Copy, Clone)]
pub struct client_primary_selection_source {
    pub source: wlr_primary_selection_source,
    pub resource: *mut wl_resource,
}
/* *
 * @ingroup iface_zwlr_data_control_manager_v1
 * @struct zwlr_data_control_manager_v1_interface
 */

#[repr(C)]#[derive(Copy, Clone)]
pub struct zwlr_data_control_manager_v1_interface {
    pub create_data_source: Option<unsafe extern "C" fn(_: *mut wl_client,
                                                        _: *mut wl_resource,
                                                        _: uint32_t) -> ()>,
    pub get_data_device: Option<unsafe extern "C" fn(_: *mut wl_client,
                                                     _: *mut wl_resource,
                                                     _: uint32_t,
                                                     _: *mut wl_resource)
                                    -> ()>,
    pub destroy: Option<unsafe extern "C" fn(_: *mut wl_client,
                                             _: *mut wl_resource) -> ()>,
}
/* *
 * @ingroup iface_zwlr_data_control_offer_v1
 * @struct zwlr_data_control_offer_v1_interface
 */

#[repr(C)]#[derive(Copy, Clone)]
pub struct zwlr_data_control_offer_v1_interface {
    pub receive: Option<unsafe extern "C" fn(_: *mut wl_client,
                                             _: *mut wl_resource,
                                             _: *const libc::c_char,
                                             _: int32_t) -> ()>,
    pub destroy: Option<unsafe extern "C" fn(_: *mut wl_client,
                                             _: *mut wl_resource) -> ()>,
}
/* ZWLR_DATA_CONTROL_DEVICE_V1_ERROR_ENUM */
/* *
 * @ingroup iface_zwlr_data_control_device_v1
 * @struct zwlr_data_control_device_v1_interface
 */

#[repr(C)]#[derive(Copy, Clone)]
pub struct zwlr_data_control_device_v1_interface {
    pub set_selection: Option<unsafe extern "C" fn(_: *mut wl_client,
                                                   _: *mut wl_resource,
                                                   _: *mut wl_resource)
                                  -> ()>,
    pub destroy: Option<unsafe extern "C" fn(_: *mut wl_client,
                                             _: *mut wl_resource) -> ()>,
    pub set_primary_selection: Option<unsafe extern "C" fn(_: *mut wl_client,
                                                           _:
                                                               *mut wl_resource,
                                                           _:
                                                               *mut wl_resource)
                                          -> ()>,
}
/* ZWLR_DATA_CONTROL_SOURCE_V1_ERROR_ENUM */
/* *
 * @ingroup iface_zwlr_data_control_source_v1
 * @struct zwlr_data_control_source_v1_interface
 */

#[repr(C)]#[derive(Copy, Clone)]
pub struct zwlr_data_control_source_v1_interface {
    pub offer: Option<unsafe extern "C" fn(_: *mut wl_client,
                                           _: *mut wl_resource,
                                           _: *const libc::c_char) -> ()>,
    pub destroy: Option<unsafe extern "C" fn(_: *mut wl_client,
                                             _: *mut wl_resource) -> ()>,
}
/*
 * This is a stable interface of wlroots. Future changes will be limited to:
 *
 * - New functions
 * - New struct members
 * - New enum members
 *
 * Note that wlroots does not make an ABI compatibility promise - in the future,
 * the layout and size of structs used by wlroots may change, requiring code
 * depending on this header to be recompiled (but not edited).
 *
 * Breaking changes are announced by email and follow a 1-year deprecation
 * schedule. Send an email to ~sircmpwn/wlroots-announce+subscribe@lists.sr.ht
 * to receive these announcements.
 */
pub type wlr_log_importance = libc::c_uint;
pub const WLR_LOG_IMPORTANCE_LAST: wlr_log_importance = 4;
pub const WLR_DEBUG: wlr_log_importance = 3;
pub const WLR_INFO: wlr_log_importance = 2;
pub const WLR_ERROR: wlr_log_importance = 1;
pub const WLR_SILENT: wlr_log_importance = 0;
/* *
	 * offer sent after wlr_data_control_device.set_selection
	 */
pub const ZWLR_DATA_CONTROL_SOURCE_V1_ERROR_INVALID_OFFER:
          zwlr_data_control_source_v1_error =
    1;
/* *
	 * source given to set_selection or set_primary_selection was already used before
	 */
pub const ZWLR_DATA_CONTROL_DEVICE_V1_ERROR_USED_SOURCE:
          zwlr_data_control_device_v1_error =
    1;
/* *
 * @ingroup iface_zwlr_data_control_manager_v1
 */
/* *
 * @ingroup iface_zwlr_data_control_manager_v1
 */
/* *
 * @ingroup iface_zwlr_data_control_manager_v1
 */
pub type zwlr_data_control_device_v1_error = libc::c_uint;
pub type zwlr_data_control_source_v1_error = libc::c_uint;
#[inline]
unsafe extern "C" fn wl_signal_init(mut signal: *mut wl_signal) {
    wl_list_init(&mut (*signal).listener_list);
}
#[inline]
unsafe extern "C" fn wl_signal_add(mut signal: *mut wl_signal,
                                   mut listener: *mut wl_listener) {
    wl_list_insert((*signal).listener_list.prev, &mut (*listener).link);
}
/* *
 * @ingroup iface_zwlr_data_control_device_v1
 */
/* *
 * @ingroup iface_zwlr_data_control_device_v1
 */
/* *
 * @ingroup iface_zwlr_data_control_device_v1
 */
/* *
 * @ingroup iface_zwlr_data_control_device_v1
 * Sends an data_offer event to the client owning the resource.
 * @param resource_ The client's resource
 */
#[inline]
unsafe extern "C" fn zwlr_data_control_device_v1_send_data_offer(mut resource_:
                                                                     *mut wl_resource,
                                                                 mut id:
                                                                     *mut wl_resource) {
    wl_resource_post_event(resource_, 0i32 as uint32_t, id);
}
/* *
 * @ingroup iface_zwlr_data_control_device_v1
 * Sends an selection event to the client owning the resource.
 * @param resource_ The client's resource
 */
#[inline]
unsafe extern "C" fn zwlr_data_control_device_v1_send_selection(mut resource_:
                                                                    *mut wl_resource,
                                                                mut id:
                                                                    *mut wl_resource) {
    wl_resource_post_event(resource_, 1i32 as uint32_t, id);
}
/* *
 * @ingroup iface_zwlr_data_control_device_v1
 * Sends an finished event to the client owning the resource.
 * @param resource_ The client's resource
 */
#[inline]
unsafe extern "C" fn zwlr_data_control_device_v1_send_finished(mut resource_:
                                                                   *mut wl_resource) {
    wl_resource_post_event(resource_, 2i32 as uint32_t);
}
/* *
 * @ingroup iface_zwlr_data_control_device_v1
 * Sends an primary_selection event to the client owning the resource.
 * @param resource_ The client's resource
 */
#[inline]
unsafe extern "C" fn zwlr_data_control_device_v1_send_primary_selection(mut resource_:
                                                                            *mut wl_resource,
                                                                        mut id:
                                                                            *mut wl_resource) {
    wl_resource_post_event(resource_, 3i32 as uint32_t, id);
}
/* *
 * @ingroup iface_zwlr_data_control_source_v1
 */
/* *
 * @ingroup iface_zwlr_data_control_source_v1
 */
/* *
 * @ingroup iface_zwlr_data_control_source_v1
 */
/* *
 * @ingroup iface_zwlr_data_control_source_v1
 */
/* *
 * @ingroup iface_zwlr_data_control_source_v1
 * Sends an send event to the client owning the resource.
 * @param resource_ The client's resource
 * @param mime_type MIME type for the data
 * @param fd file descriptor for the data
 */
#[inline]
unsafe extern "C" fn zwlr_data_control_source_v1_send_send(mut resource_:
                                                               *mut wl_resource,
                                                           mut mime_type:
                                                               *const libc::c_char,
                                                           mut fd: int32_t) {
    wl_resource_post_event(resource_, 0i32 as uint32_t, mime_type, fd);
}
/* *
 * @ingroup iface_zwlr_data_control_source_v1
 * Sends an cancelled event to the client owning the resource.
 * @param resource_ The client's resource
 */
#[inline]
unsafe extern "C" fn zwlr_data_control_source_v1_send_cancelled(mut resource_:
                                                                    *mut wl_resource) {
    wl_resource_post_event(resource_, 1i32 as uint32_t);
}
/* *
 * @ingroup iface_zwlr_data_control_offer_v1
 */
/* *
 * @ingroup iface_zwlr_data_control_offer_v1
 */
/* *
 * @ingroup iface_zwlr_data_control_offer_v1
 */
/* *
 * @ingroup iface_zwlr_data_control_offer_v1
 * Sends an offer event to the client owning the resource.
 * @param resource_ The client's resource
 * @param mime_type offered MIME type
 */
#[inline]
unsafe extern "C" fn zwlr_data_control_offer_v1_send_offer(mut resource_:
                                                               *mut wl_resource,
                                                           mut mime_type:
                                                               *const libc::c_char) {
    wl_resource_post_event(resource_, 0i32 as uint32_t, mime_type);
}
unsafe extern "C" fn source_from_resource(mut resource: *mut wl_resource)
 -> *mut data_control_source {
    if wl_resource_instance_of(resource,
                               &zwlr_data_control_source_v1_interface,
                               &source_impl as
                                   *const zwlr_data_control_source_v1_interface
                                   as *const libc::c_void) != 0 {
    } else {
        __assert_fail(b"wl_resource_instance_of(resource, &zwlr_data_control_source_v1_interface, &source_impl)\x00"
                          as *const u8 as *const libc::c_char,
                      b"../types/wlr_data_control_v1.c\x00" as *const u8 as
                          *const libc::c_char, 30i32 as libc::c_uint,
                      (*::std::mem::transmute::<&[u8; 71],
                                                &[libc::c_char; 71]>(b"struct data_control_source *source_from_resource(struct wl_resource *)\x00")).as_ptr());
    };
    return wl_resource_get_user_data(resource) as *mut data_control_source;
}
unsafe extern "C" fn source_handle_offer(mut client: *mut wl_client,
                                         mut resource: *mut wl_resource,
                                         mut mime_type: *const libc::c_char) {
    let mut source: *mut data_control_source = source_from_resource(resource);
    if source.is_null() { return }
    if (*source).finalized {
        wl_resource_post_error(resource,
                               ZWLR_DATA_CONTROL_SOURCE_V1_ERROR_INVALID_OFFER
                                   as libc::c_int as uint32_t,
                               b"cannot mutate offer after set_selection or set_primary_selection\x00"
                                   as *const u8 as *const libc::c_char);
        return
    }
    let mut mime_type_ptr: *mut *const libc::c_char =
        0 as *mut *const libc::c_char;
    mime_type_ptr = (*source).mime_types.data as *mut *const libc::c_char;
    while (mime_type_ptr as *const libc::c_char) <
              ((*source).mime_types.data as
                   *const libc::c_char).offset((*source).mime_types.size as
                                                   isize) {
        if strcmp(*mime_type_ptr, mime_type) == 0i32 {
            _wlr_log(WLR_DEBUG,
                     b"[%s:%d] Ignoring duplicate MIME type offer %s\x00" as
                         *const u8 as *const libc::c_char,
                     b"../types/wlr_data_control_v1.c\x00" as *const u8 as
                         *const libc::c_char, 53i32, mime_type);
            return
        }
        mime_type_ptr = mime_type_ptr.offset(1)
    }
    let mut dup_mime_type: *mut libc::c_char = strdup(mime_type);
    if dup_mime_type.is_null() {
        wl_resource_post_no_memory(resource);
        return
    }
    let mut p: *mut *mut libc::c_char =
        wl_array_add(&mut (*source).mime_types,
                     ::std::mem::size_of::<*mut libc::c_char>() as
                         libc::c_ulong) as *mut *mut libc::c_char;
    if p.is_null() {
        free(dup_mime_type as *mut libc::c_void);
        wl_resource_post_no_memory(resource);
        return
    }
    *p = dup_mime_type;
}
unsafe extern "C" fn source_handle_destroy(mut client: *mut wl_client,
                                           mut resource: *mut wl_resource) {
    wl_resource_destroy(resource);
}
static mut source_impl: zwlr_data_control_source_v1_interface =
    {
    
        {
            let mut init =
                zwlr_data_control_source_v1_interface{offer:
                                                          Some(source_handle_offer
                                                                   as
                                                                   unsafe extern "C" fn(_:
                                                                                            *mut wl_client,
                                                                                        _:
                                                                                            *mut wl_resource,
                                                                                        _:
                                                                                            *const libc::c_char)
                                                                       -> ()),
                                                      destroy:
                                                          Some(source_handle_destroy
                                                                   as
                                                                   unsafe extern "C" fn(_:
                                                                                            *mut wl_client,
                                                                                        _:
                                                                                            *mut wl_resource)
                                                                       ->
                                                                           ()),};
            init
        }
};
unsafe extern "C" fn data_control_source_destroy(mut source:
                                                     *mut data_control_source) {
    if source.is_null() { return }
    let mut p: *mut *mut libc::c_char = 0 as *mut *mut libc::c_char;
    p = (*source).mime_types.data as *mut *mut libc::c_char;
    while (p as *const libc::c_char) <
              ((*source).mime_types.data as
                   *const libc::c_char).offset((*source).mime_types.size as
                                                   isize) {
        free(*p as *mut libc::c_void);
        p = p.offset(1)
    }
    wl_array_release(&mut (*source).mime_types);
    // Prevent destructors below from calling this recursively.
    wl_resource_set_user_data((*source).resource, 0 as *mut libc::c_void);
    if !(*source).active_source.is_null() {
        wlr_data_source_destroy((*source).active_source);
    } else if !(*source).active_primary_source.is_null() {
        wlr_primary_selection_source_destroy((*source).active_primary_source);
    }
    free(source as *mut libc::c_void);
}
unsafe extern "C" fn source_handle_resource_destroy(mut resource:
                                                        *mut wl_resource) {
    let mut source: *mut data_control_source = source_from_resource(resource);
    data_control_source_destroy(source);
}
unsafe extern "C" fn client_data_source_from_source(mut wlr_source:
                                                        *mut wlr_data_source)
 -> *mut client_data_source {
    if (*wlr_source).impl_0 ==
           &client_source_impl as *const wlr_data_source_impl {
    } else {
        __assert_fail(b"wlr_source->impl == &client_source_impl\x00" as
                          *const u8 as *const libc::c_char,
                      b"../types/wlr_data_control_v1.c\x00" as *const u8 as
                          *const libc::c_char, 123i32 as libc::c_uint,
                      (*::std::mem::transmute::<&[u8; 84],
                                                &[libc::c_char; 84]>(b"struct client_data_source *client_data_source_from_source(struct wlr_data_source *)\x00")).as_ptr());
    };
    return wlr_source as *mut client_data_source;
}
unsafe extern "C" fn client_source_send(mut wlr_source: *mut wlr_data_source,
                                        mut mime_type: *const libc::c_char,
                                        mut fd: libc::c_int) {
    let mut source: *mut client_data_source =
        client_data_source_from_source(wlr_source);
    zwlr_data_control_source_v1_send_send((*source).resource, mime_type, fd);
    close(fd);
}
unsafe extern "C" fn client_source_destroy(mut wlr_source:
                                               *mut wlr_data_source) {
    let mut client_source: *mut client_data_source =
        client_data_source_from_source(wlr_source);
    let mut source: *mut data_control_source =
        source_from_resource((*client_source).resource);
    free(client_source as *mut libc::c_void);
    if source.is_null() { return }
    (*source).active_source = 0 as *mut wlr_data_source;
    zwlr_data_control_source_v1_send_cancelled((*source).resource);
    data_control_source_destroy(source);
}
static mut client_source_impl: wlr_data_source_impl =
    {
    
        {
            let mut init =
                wlr_data_source_impl{send:
                                         Some(client_source_send as
                                                  unsafe extern "C" fn(_:
                                                                           *mut wlr_data_source,
                                                                       _:
                                                                           *const libc::c_char,
                                                                       _:
                                                                           libc::c_int)
                                                      -> ()),
                                     accept: None,
                                     destroy:
                                         Some(client_source_destroy as
                                                  unsafe extern "C" fn(_:
                                                                           *mut wlr_data_source)
                                                      -> ()),
                                     dnd_drop: None,
                                     dnd_finish: None,
                                     dnd_action: None,};
            init
        }
};
unsafe extern "C" fn client_primary_selection_source_from_source(mut wlr_source:
                                                                     *mut wlr_primary_selection_source)
 -> *mut client_primary_selection_source {
    if (*wlr_source).impl_0 ==
           &client_primary_selection_source_impl as
               *const wlr_primary_selection_source_impl {
    } else {
        __assert_fail(b"wlr_source->impl == &client_primary_selection_source_impl\x00"
                          as *const u8 as *const libc::c_char,
                      b"../types/wlr_data_control_v1.c\x00" as *const u8 as
                          *const libc::c_char, 169i32 as libc::c_uint,
                      (*::std::mem::transmute::<&[u8; 123],
                                                &[libc::c_char; 123]>(b"struct client_primary_selection_source *client_primary_selection_source_from_source(struct wlr_primary_selection_source *)\x00")).as_ptr());
    };
    return wlr_source as *mut client_primary_selection_source;
}
unsafe extern "C" fn client_primary_selection_source_send(mut wlr_source:
                                                              *mut wlr_primary_selection_source,
                                                          mut mime_type:
                                                              *const libc::c_char,
                                                          mut fd:
                                                              libc::c_int) {
    let mut source: *mut client_primary_selection_source =
        client_primary_selection_source_from_source(wlr_source);
    zwlr_data_control_source_v1_send_send((*source).resource, mime_type, fd);
    close(fd);
}
unsafe extern "C" fn client_primary_selection_source_destroy(mut wlr_source:
                                                                 *mut wlr_primary_selection_source) {
    let mut client_source: *mut client_primary_selection_source =
        client_primary_selection_source_from_source(wlr_source);
    let mut source: *mut data_control_source =
        source_from_resource((*client_source).resource);
    free(client_source as *mut libc::c_void);
    if source.is_null() { return }
    (*source).active_primary_source = 0 as *mut wlr_primary_selection_source;
    zwlr_data_control_source_v1_send_cancelled((*source).resource);
    data_control_source_destroy(source);
}
static mut client_primary_selection_source_impl:
       wlr_primary_selection_source_impl =
    {
    
        {
            let mut init =
                wlr_primary_selection_source_impl{send:
                                                      Some(client_primary_selection_source_send
                                                               as
                                                               unsafe extern "C" fn(_:
                                                                                        *mut wlr_primary_selection_source,
                                                                                    _:
                                                                                        *const libc::c_char,
                                                                                    _:
                                                                                        libc::c_int)
                                                                   -> ()),
                                                  destroy:
                                                      Some(client_primary_selection_source_destroy
                                                               as
                                                               unsafe extern "C" fn(_:
                                                                                        *mut wlr_primary_selection_source)
                                                                   -> ()),};
            init
        }
};
unsafe extern "C" fn data_offer_destroy(mut offer: *mut data_offer) {
    if offer.is_null() { return }
    let mut device: *mut wlr_data_control_device_v1 = (*offer).device;
    if !device.is_null() {
        if (*offer).is_primary {
            (*device).primary_selection_offer_resource = 0 as *mut wl_resource
        } else { (*device).selection_offer_resource = 0 as *mut wl_resource }
    }
    wl_resource_set_user_data((*offer).resource, 0 as *mut libc::c_void);
    free(offer as *mut libc::c_void);
}
unsafe extern "C" fn data_offer_from_offer_resource(mut resource:
                                                        *mut wl_resource)
 -> *mut data_offer {
    if wl_resource_instance_of(resource,
                               &zwlr_data_control_offer_v1_interface,
                               &offer_impl as
                                   *const zwlr_data_control_offer_v1_interface
                                   as *const libc::c_void) != 0 {
    } else {
        __assert_fail(b"wl_resource_instance_of(resource, &zwlr_data_control_offer_v1_interface, &offer_impl)\x00"
                          as *const u8 as *const libc::c_char,
                      b"../types/wlr_data_control_v1.c\x00" as *const u8 as
                          *const libc::c_char, 236i32 as libc::c_uint,
                      (*::std::mem::transmute::<&[u8; 72],
                                                &[libc::c_char; 72]>(b"struct data_offer *data_offer_from_offer_resource(struct wl_resource *)\x00")).as_ptr());
    };
    return wl_resource_get_user_data(resource) as *mut data_offer;
}
unsafe extern "C" fn offer_handle_receive(mut client: *mut wl_client,
                                          mut resource: *mut wl_resource,
                                          mut mime_type: *const libc::c_char,
                                          mut fd: libc::c_int) {
    let mut offer: *mut data_offer = data_offer_from_offer_resource(resource);
    if offer.is_null() { close(fd); return }
    let mut device: *mut wlr_data_control_device_v1 = (*offer).device;
    if device.is_null() { close(fd); return }
    if (*offer).is_primary {
        if (*(*device).seat).primary_selection_source.is_null() {
            close(fd);
            return
        }
        wlr_primary_selection_source_send((*(*device).seat).primary_selection_source,
                                          mime_type, fd);
    } else {
        if (*(*device).seat).selection_source.is_null() { close(fd); return }
        wlr_data_source_send((*(*device).seat).selection_source, mime_type,
                             fd);
    };
}
unsafe extern "C" fn offer_handle_destroy(mut client: *mut wl_client,
                                          mut resource: *mut wl_resource) {
    wl_resource_destroy(resource);
}
static mut offer_impl: zwlr_data_control_offer_v1_interface =
    {
    
        {
            let mut init =
                zwlr_data_control_offer_v1_interface{receive:
                                                         Some(offer_handle_receive
                                                                  as
                                                                  unsafe extern "C" fn(_:
                                                                                           *mut wl_client,
                                                                                       _:
                                                                                           *mut wl_resource,
                                                                                       _:
                                                                                           *const libc::c_char,
                                                                                       _:
                                                                                           libc::c_int)
                                                                      -> ()),
                                                     destroy:
                                                         Some(offer_handle_destroy
                                                                  as
                                                                  unsafe extern "C" fn(_:
                                                                                           *mut wl_client,
                                                                                       _:
                                                                                           *mut wl_resource)
                                                                      ->
                                                                          ()),};
            init
        }
};
unsafe extern "C" fn offer_handle_resource_destroy(mut resource:
                                                       *mut wl_resource) {
    let mut offer: *mut data_offer = data_offer_from_offer_resource(resource);
    data_offer_destroy(offer);
}
unsafe extern "C" fn create_offer(mut device: *mut wlr_data_control_device_v1,
                                  mut mime_types: *mut wl_array,
                                  mut is_primary: bool) -> *mut wl_resource {
    let mut client: *mut wl_client =
        wl_resource_get_client((*device).resource);
    let mut offer: *mut data_offer =
        calloc(1i32 as libc::c_ulong,
               ::std::mem::size_of::<data_offer>() as libc::c_ulong) as
            *mut data_offer;
    if offer.is_null() {
        wl_client_post_no_memory(client);
        return 0 as *mut wl_resource
    }
    (*offer).device = device;
    (*offer).is_primary = is_primary;
    let mut version: uint32_t =
        wl_resource_get_version((*device).resource) as uint32_t;
    let mut resource: *mut wl_resource =
        wl_resource_create(client, &zwlr_data_control_offer_v1_interface,
                           version as libc::c_int, 0i32 as uint32_t);
    if resource.is_null() {
        free(offer as *mut libc::c_void);
        return 0 as *mut wl_resource
    }
    (*offer).resource = resource;
    wl_resource_set_implementation(resource,
                                   &offer_impl as
                                       *const zwlr_data_control_offer_v1_interface
                                       as *const libc::c_void,
                                   offer as *mut libc::c_void,
                                   Some(offer_handle_resource_destroy as
                                            unsafe extern "C" fn(_:
                                                                     *mut wl_resource)
                                                -> ()));
    zwlr_data_control_device_v1_send_data_offer((*device).resource, resource);
    let mut p: *mut *mut libc::c_char = 0 as *mut *mut libc::c_char;
    p = (*mime_types).data as *mut *mut libc::c_char;
    while (p as *const libc::c_char) <
              ((*mime_types).data as
                   *const libc::c_char).offset((*mime_types).size as isize) {
        zwlr_data_control_offer_v1_send_offer(resource, *p);
        p = p.offset(1)
    }
    return resource;
}
unsafe extern "C" fn control_from_resource(mut resource: *mut wl_resource)
 -> *mut wlr_data_control_device_v1 {
    if wl_resource_instance_of(resource,
                               &zwlr_data_control_device_v1_interface,
                               &control_impl as
                                   *const zwlr_data_control_device_v1_interface
                                   as *const libc::c_void) != 0 {
    } else {
        __assert_fail(b"wl_resource_instance_of(resource, &zwlr_data_control_device_v1_interface, &control_impl)\x00"
                          as *const u8 as *const libc::c_char,
                      b"../types/wlr_data_control_v1.c\x00" as *const u8 as
                          *const libc::c_char, 328i32 as libc::c_uint,
                      (*::std::mem::transmute::<&[u8; 79],
                                                &[libc::c_char; 79]>(b"struct wlr_data_control_device_v1 *control_from_resource(struct wl_resource *)\x00")).as_ptr());
    };
    return wl_resource_get_user_data(resource) as
               *mut wlr_data_control_device_v1;
}
unsafe extern "C" fn control_handle_set_selection(mut client: *mut wl_client,
                                                  mut control_resource:
                                                      *mut wl_resource,
                                                  mut source_resource:
                                                      *mut wl_resource) {
    let mut device: *mut wlr_data_control_device_v1 =
        control_from_resource(control_resource);
    if device.is_null() { return }
    let mut source: *mut data_control_source = 0 as *mut data_control_source;
    if !source_resource.is_null() {
        source = source_from_resource(source_resource)
    }
    if source.is_null() {
        wlr_seat_request_set_selection((*device).seat,
                                       0 as *mut wlr_seat_client,
                                       0 as *mut wlr_data_source,
                                       wl_display_next_serial((*(*device).seat).display));
        return
    }
    if !(*source).active_source.is_null() ||
           !(*source).active_primary_source.is_null() {
        wl_resource_post_error(control_resource,
                               ZWLR_DATA_CONTROL_DEVICE_V1_ERROR_USED_SOURCE
                                   as libc::c_int as uint32_t,
                               b"cannot use a data source in set_selection or set_primary_selection more than once\x00"
                                   as *const u8 as *const libc::c_char);
        return
    }
    let mut client_source: *mut client_data_source =
        calloc(1i32 as libc::c_ulong,
               ::std::mem::size_of::<client_data_source>() as libc::c_ulong)
            as *mut client_data_source;
    if client_source.is_null() { wl_client_post_no_memory(client); return }
    (*client_source).resource = source_resource;
    let mut wlr_source: *mut wlr_data_source = &mut (*client_source).source;
    wlr_data_source_init(wlr_source, &client_source_impl);
    (*source).active_source = wlr_source;
    wl_array_release(&mut (*wlr_source).mime_types);
    (*wlr_source).mime_types = (*source).mime_types;
    wl_array_init(&mut (*source).mime_types);
    (*source).finalized = 1i32 != 0;
    wlr_seat_request_set_selection((*device).seat, 0 as *mut wlr_seat_client,
                                   wlr_source,
                                   wl_display_next_serial((*(*device).seat).display));
}
unsafe extern "C" fn control_handle_set_primary_selection(mut client:
                                                              *mut wl_client,
                                                          mut control_resource:
                                                              *mut wl_resource,
                                                          mut source_resource:
                                                              *mut wl_resource) {
    let mut device: *mut wlr_data_control_device_v1 =
        control_from_resource(control_resource);
    if device.is_null() { return }
    let mut source: *mut data_control_source = 0 as *mut data_control_source;
    if !source_resource.is_null() {
        source = source_from_resource(source_resource)
    }
    if source.is_null() {
        wlr_seat_request_set_primary_selection((*device).seat,
                                               0 as *mut wlr_seat_client,
                                               0 as
                                                   *mut wlr_primary_selection_source,
                                               wl_display_next_serial((*(*device).seat).display));
        return
    }
    if !(*source).active_source.is_null() ||
           !(*source).active_primary_source.is_null() {
        wl_resource_post_error(control_resource,
                               ZWLR_DATA_CONTROL_DEVICE_V1_ERROR_USED_SOURCE
                                   as libc::c_int as uint32_t,
                               b"cannot use a data source in set_selection or set_primary_selection more than once\x00"
                                   as *const u8 as *const libc::c_char);
        return
    }
    let mut client_source: *mut client_primary_selection_source =
        calloc(1i32 as libc::c_ulong,
               ::std::mem::size_of::<client_primary_selection_source>() as
                   libc::c_ulong) as *mut client_primary_selection_source;
    if client_source.is_null() { wl_client_post_no_memory(client); return }
    (*client_source).resource = source_resource;
    let mut wlr_source: *mut wlr_primary_selection_source =
        &mut (*client_source).source;
    wlr_primary_selection_source_init(wlr_source,
                                      &client_primary_selection_source_impl);
    (*source).active_primary_source = wlr_source;
    wl_array_release(&mut (*wlr_source).mime_types);
    (*wlr_source).mime_types = (*source).mime_types;
    wl_array_init(&mut (*source).mime_types);
    (*source).finalized = 1i32 != 0;
    wlr_seat_request_set_primary_selection((*device).seat,
                                           0 as *mut wlr_seat_client,
                                           wlr_source,
                                           wl_display_next_serial((*(*device).seat).display));
}
unsafe extern "C" fn control_handle_destroy(mut client: *mut wl_client,
                                            mut control_resource:
                                                *mut wl_resource) {
    wl_resource_destroy(control_resource);
}
static mut control_impl: zwlr_data_control_device_v1_interface =
    {
    
        {
            let mut init =
                zwlr_data_control_device_v1_interface{set_selection:
                                                          Some(control_handle_set_selection
                                                                   as
                                                                   unsafe extern "C" fn(_:
                                                                                            *mut wl_client,
                                                                                        _:
                                                                                            *mut wl_resource,
                                                                                        _:
                                                                                            *mut wl_resource)
                                                                       -> ()),
                                                      destroy:
                                                          Some(control_handle_destroy
                                                                   as
                                                                   unsafe extern "C" fn(_:
                                                                                            *mut wl_client,
                                                                                        _:
                                                                                            *mut wl_resource)
                                                                       -> ()),
                                                      set_primary_selection:
                                                          Some(control_handle_set_primary_selection
                                                                   as
                                                                   unsafe extern "C" fn(_:
                                                                                            *mut wl_client,
                                                                                        _:
                                                                                            *mut wl_resource,
                                                                                        _:
                                                                                            *mut wl_resource)
                                                                       ->
                                                                           ()),};
            init
        }
};
unsafe extern "C" fn control_send_selection(mut device:
                                                *mut wlr_data_control_device_v1) {
    let mut source: *mut wlr_data_source = (*(*device).seat).selection_source;
    if !(*device).selection_offer_resource.is_null() {
        // Make the offer inert
        let mut offer: *mut data_offer =
            data_offer_from_offer_resource((*device).selection_offer_resource);
        data_offer_destroy(offer);
    }
    (*device).selection_offer_resource = 0 as *mut wl_resource;
    if !source.is_null() {
        (*device).selection_offer_resource =
            create_offer(device, &mut (*source).mime_types, 0i32 != 0);
        if (*device).selection_offer_resource.is_null() {
            wl_resource_post_no_memory((*device).resource);
            return
        }
    }
    zwlr_data_control_device_v1_send_selection((*device).resource,
                                               (*device).selection_offer_resource);
}
unsafe extern "C" fn control_send_primary_selection(mut device:
                                                        *mut wlr_data_control_device_v1) {
    let mut version: uint32_t =
        wl_resource_get_version((*device).resource) as uint32_t;
    if version < 2i32 as libc::c_uint { return }
    let mut source: *mut wlr_primary_selection_source =
        (*(*device).seat).primary_selection_source;
    if !(*device).primary_selection_offer_resource.is_null() {
        // Make the offer inert
        let mut offer: *mut data_offer =
            data_offer_from_offer_resource((*device).primary_selection_offer_resource);
        data_offer_destroy(offer);
    }
    (*device).primary_selection_offer_resource = 0 as *mut wl_resource;
    if !source.is_null() {
        (*device).primary_selection_offer_resource =
            create_offer(device, &mut (*source).mime_types, 1i32 != 0);
        if (*device).primary_selection_offer_resource.is_null() {
            wl_resource_post_no_memory((*device).resource);
            return
        }
    }
    zwlr_data_control_device_v1_send_primary_selection((*device).resource,
                                                       (*device).primary_selection_offer_resource);
}
unsafe extern "C" fn control_handle_resource_destroy(mut resource:
                                                         *mut wl_resource) {
    let mut device: *mut wlr_data_control_device_v1 =
        control_from_resource(resource);
    wlr_data_control_device_v1_destroy(device);
}
unsafe extern "C" fn control_handle_seat_destroy(mut listener:
                                                     *mut wl_listener,
                                                 mut data:
                                                     *mut libc::c_void) {
    let mut device: *mut wlr_data_control_device_v1 =
        (listener as *mut libc::c_char).offset(-56) as
            *mut wlr_data_control_device_v1;
    wlr_data_control_device_v1_destroy(device);
}
unsafe extern "C" fn control_handle_seat_set_selection(mut listener:
                                                           *mut wl_listener,
                                                       mut data:
                                                           *mut libc::c_void) {
    let mut device: *mut wlr_data_control_device_v1 =
        (listener as *mut libc::c_char).offset(-80) as
            *mut wlr_data_control_device_v1;
    control_send_selection(device);
}
unsafe extern "C" fn control_handle_seat_set_primary_selection(mut listener:
                                                                   *mut wl_listener,
                                                               mut data:
                                                                   *mut libc::c_void) {
    let mut device: *mut wlr_data_control_device_v1 =
        (listener as *mut libc::c_char).offset(-104) as
            *mut wlr_data_control_device_v1;
    control_send_primary_selection(device);
}
#[no_mangle]
pub unsafe extern "C" fn wlr_data_control_device_v1_destroy(mut device:
                                                                *mut wlr_data_control_device_v1) {
    if device.is_null() { return }
    zwlr_data_control_device_v1_send_finished((*device).resource);
    // Make the resources inert
    wl_resource_set_user_data((*device).resource, 0 as *mut libc::c_void);
    if !(*device).selection_offer_resource.is_null() {
        let mut offer: *mut data_offer =
            data_offer_from_offer_resource((*device).selection_offer_resource);
        data_offer_destroy(offer);
    }
    if !(*device).primary_selection_offer_resource.is_null() {
        let mut offer_0: *mut data_offer =
            data_offer_from_offer_resource((*device).primary_selection_offer_resource);
        data_offer_destroy(offer_0);
    }
    wl_list_remove(&mut (*device).seat_destroy.link);
    wl_list_remove(&mut (*device).seat_set_selection.link);
    wl_list_remove(&mut (*device).seat_set_primary_selection.link);
    wl_list_remove(&mut (*device).link);
    free(device as *mut libc::c_void);
}
unsafe extern "C" fn manager_from_resource(mut resource: *mut wl_resource)
 -> *mut wlr_data_control_manager_v1 {
    if wl_resource_instance_of(resource,
                               &zwlr_data_control_manager_v1_interface,
                               &manager_impl as
                                   *const zwlr_data_control_manager_v1_interface
                                   as *const libc::c_void) != 0 {
    } else {
        __assert_fail(b"wl_resource_instance_of(resource, &zwlr_data_control_manager_v1_interface, &manager_impl)\x00"
                          as *const u8 as *const libc::c_char,
                      b"../types/wlr_data_control_v1.c\x00" as *const u8 as
                          *const libc::c_char, 561i32 as libc::c_uint,
                      (*::std::mem::transmute::<&[u8; 80],
                                                &[libc::c_char; 80]>(b"struct wlr_data_control_manager_v1 *manager_from_resource(struct wl_resource *)\x00")).as_ptr());
    };
    return wl_resource_get_user_data(resource) as
               *mut wlr_data_control_manager_v1;
}
unsafe extern "C" fn manager_handle_create_data_source(mut client:
                                                           *mut wl_client,
                                                       mut manager_resource:
                                                           *mut wl_resource,
                                                       mut id: uint32_t) {
    let mut source: *mut data_control_source =
        calloc(1i32 as libc::c_ulong,
               ::std::mem::size_of::<data_control_source>() as libc::c_ulong)
            as *mut data_control_source;
    if source.is_null() {
        wl_resource_post_no_memory(manager_resource);
        return
    }
    wl_array_init(&mut (*source).mime_types);
    let mut version: uint32_t =
        wl_resource_get_version(manager_resource) as uint32_t;
    (*source).resource =
        wl_resource_create(client, &zwlr_data_control_source_v1_interface,
                           version as libc::c_int, id);
    if (*source).resource.is_null() {
        wl_resource_post_no_memory(manager_resource);
        wl_array_release(&mut (*source).mime_types);
        free(source as *mut libc::c_void);
        return
    }
    wl_resource_set_implementation((*source).resource,
                                   &source_impl as
                                       *const zwlr_data_control_source_v1_interface
                                       as *const libc::c_void,
                                   source as *mut libc::c_void,
                                   Some(source_handle_resource_destroy as
                                            unsafe extern "C" fn(_:
                                                                     *mut wl_resource)
                                                -> ()));
}
unsafe extern "C" fn manager_handle_get_data_device(mut client:
                                                        *mut wl_client,
                                                    mut manager_resource:
                                                        *mut wl_resource,
                                                    mut id: uint32_t,
                                                    mut seat_resource:
                                                        *mut wl_resource) {
    let mut manager: *mut wlr_data_control_manager_v1 =
        manager_from_resource(manager_resource);
    let mut seat_client: *mut wlr_seat_client =
        wlr_seat_client_from_resource(seat_resource);
    let mut device: *mut wlr_data_control_device_v1 =
        calloc(1i32 as libc::c_ulong,
               ::std::mem::size_of::<wlr_data_control_device_v1>() as
                   libc::c_ulong) as *mut wlr_data_control_device_v1;
    if device.is_null() {
        wl_resource_post_no_memory(manager_resource);
        return
    }
    (*device).manager = manager;
    (*device).seat = (*seat_client).seat;
    let mut version: uint32_t =
        wl_resource_get_version(manager_resource) as uint32_t;
    (*device).resource =
        wl_resource_create(client, &zwlr_data_control_device_v1_interface,
                           version as libc::c_int, id);
    if (*device).resource.is_null() {
        wl_resource_post_no_memory(manager_resource);
        free(device as *mut libc::c_void);
        return
    }
    wl_resource_set_implementation((*device).resource,
                                   &control_impl as
                                       *const zwlr_data_control_device_v1_interface
                                       as *const libc::c_void,
                                   device as *mut libc::c_void,
                                   Some(control_handle_resource_destroy as
                                            unsafe extern "C" fn(_:
                                                                     *mut wl_resource)
                                                -> ()));
    let mut resource: *mut wl_resource = (*device).resource;
    (*device).seat_destroy.notify =
        Some(control_handle_seat_destroy as
                 unsafe extern "C" fn(_: *mut wl_listener,
                                      _: *mut libc::c_void) -> ());
    wl_signal_add(&mut (*(*device).seat).events.destroy,
                  &mut (*device).seat_destroy);
    (*device).seat_set_selection.notify =
        Some(control_handle_seat_set_selection as
                 unsafe extern "C" fn(_: *mut wl_listener,
                                      _: *mut libc::c_void) -> ());
    wl_signal_add(&mut (*(*device).seat).events.set_selection,
                  &mut (*device).seat_set_selection);
    (*device).seat_set_primary_selection.notify =
        Some(control_handle_seat_set_primary_selection as
                 unsafe extern "C" fn(_: *mut wl_listener,
                                      _: *mut libc::c_void) -> ());
    wl_signal_add(&mut (*(*device).seat).events.set_primary_selection,
                  &mut (*device).seat_set_primary_selection);
    wl_list_insert(&mut (*manager).devices, &mut (*device).link);
    wlr_signal_emit_safe(&mut (*manager).events.new_device,
                         device as *mut libc::c_void);
    // At this point maybe the compositor decided to destroy the device. If
	// it's the case then the resource will be inert.
    device = control_from_resource(resource);
    if !device.is_null() {
        control_send_selection(device);
        control_send_primary_selection(device);
    };
}
unsafe extern "C" fn manager_handle_destroy(mut client: *mut wl_client,
                                            mut manager_resource:
                                                *mut wl_resource) {
    wl_resource_destroy(manager_resource);
}
static mut manager_impl: zwlr_data_control_manager_v1_interface =
    {
    
        {
            let mut init =
                zwlr_data_control_manager_v1_interface{create_data_source:
                                                           Some(manager_handle_create_data_source
                                                                    as
                                                                    unsafe extern "C" fn(_:
                                                                                             *mut wl_client,
                                                                                         _:
                                                                                             *mut wl_resource,
                                                                                         _:
                                                                                             uint32_t)
                                                                        ->
                                                                            ()),
                                                       get_data_device:
                                                           Some(manager_handle_get_data_device
                                                                    as
                                                                    unsafe extern "C" fn(_:
                                                                                             *mut wl_client,
                                                                                         _:
                                                                                             *mut wl_resource,
                                                                                         _:
                                                                                             uint32_t,
                                                                                         _:
                                                                                             *mut wl_resource)
                                                                        ->
                                                                            ()),
                                                       destroy:
                                                           Some(manager_handle_destroy
                                                                    as
                                                                    unsafe extern "C" fn(_:
                                                                                             *mut wl_client,
                                                                                         _:
                                                                                             *mut wl_resource)
                                                                        ->
                                                                            ()),};
            init
        }
};
unsafe extern "C" fn manager_bind(mut client: *mut wl_client,
                                  mut data: *mut libc::c_void,
                                  mut version: uint32_t, mut id: uint32_t) {
    let mut manager: *mut wlr_data_control_manager_v1 =
        data as *mut wlr_data_control_manager_v1;
    let mut resource: *mut wl_resource =
        wl_resource_create(client, &zwlr_data_control_manager_v1_interface,
                           version as libc::c_int, id);
    if resource.is_null() { wl_client_post_no_memory(client); return }
    wl_resource_set_implementation(resource,
                                   &manager_impl as
                                       *const zwlr_data_control_manager_v1_interface
                                       as *const libc::c_void,
                                   manager as *mut libc::c_void, None);
}
unsafe extern "C" fn handle_display_destroy(mut listener: *mut wl_listener,
                                            mut data: *mut libc::c_void) {
    let mut manager: *mut wlr_data_control_manager_v1 =
        (listener as *mut libc::c_char).offset(-56) as
            *mut wlr_data_control_manager_v1;
    wlr_signal_emit_safe(&mut (*manager).events.destroy,
                         manager as *mut libc::c_void);
    wl_list_remove(&mut (*manager).display_destroy.link);
    wl_global_destroy((*manager).global);
    free(manager as *mut libc::c_void);
}
/*
 * This an unstable interface of wlroots. No guarantees are made regarding the
 * future consistency of this API.
 */
// wlr_data_control_device_v1::link
// wlr_data_control_device_v1
// wlr_data_control_manager_v1::devices
// current selection offer
// current primary selection offer
#[no_mangle]
pub unsafe extern "C" fn wlr_data_control_manager_v1_create(mut display:
                                                                *mut wl_display)
 -> *mut wlr_data_control_manager_v1 {
    let mut manager: *mut wlr_data_control_manager_v1 =
        calloc(1i32 as libc::c_ulong,
               ::std::mem::size_of::<wlr_data_control_manager_v1>() as
                   libc::c_ulong) as *mut wlr_data_control_manager_v1;
    if manager.is_null() { return 0 as *mut wlr_data_control_manager_v1 }
    wl_list_init(&mut (*manager).devices);
    wl_signal_init(&mut (*manager).events.destroy);
    wl_signal_init(&mut (*manager).events.new_device);
    (*manager).global =
        wl_global_create(display, &zwlr_data_control_manager_v1_interface,
                         2i32, manager as *mut libc::c_void,
                         Some(manager_bind as
                                  unsafe extern "C" fn(_: *mut wl_client,
                                                       _: *mut libc::c_void,
                                                       _: uint32_t,
                                                       _: uint32_t) -> ()));
    if (*manager).global.is_null() {
        free(manager as *mut libc::c_void);
        return 0 as *mut wlr_data_control_manager_v1
    }
    (*manager).display_destroy.notify =
        Some(handle_display_destroy as
                 unsafe extern "C" fn(_: *mut wl_listener,
                                      _: *mut libc::c_void) -> ());
    wl_display_add_destroy_listener(display, &mut (*manager).display_destroy);
    return manager;
}
