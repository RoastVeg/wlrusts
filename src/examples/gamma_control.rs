use libc;
extern "C" {
    pub type _IO_wide_data;
    pub type _IO_codecvt;
    pub type _IO_marker;
    pub type wl_proxy;
    pub type wl_display;
    /* Generated by wayland-scanner 1.17.0 */
    /* *
 * @page page_wlr_gamma_control_unstable_v1 The wlr_gamma_control_unstable_v1 protocol
 * manage gamma tables of outputs
 *
 * @section page_desc_wlr_gamma_control_unstable_v1 Description
 *
 * This protocol allows a privileged client to set the gamma tables for
 * outputs.
 *
 * Warning! The protocol described in this file is experimental and
 * backward incompatible changes may be made. Backward compatible changes
 * may be added together with the corresponding interface version bump.
 * Backward incompatible changes are done by bumping the version number in
 * the protocol and interface names and resetting the interface version.
 * Once the protocol is to be declared stable, the 'z' prefix and the
 * version number in the protocol and interface names are removed and the
 * interface version number is reset.
 *
 * @section page_ifaces_wlr_gamma_control_unstable_v1 Interfaces
 * - @subpage page_iface_zwlr_gamma_control_manager_v1 - manager to create per-output gamma controls
 * - @subpage page_iface_zwlr_gamma_control_v1 - adjust gamma tables for an output
 * @section page_copyright_wlr_gamma_control_unstable_v1 Copyright
 * <pre>
 *
 * Copyright © 2015 Giulio camuffo
 * Copyright © 2018 Simon Ser
 *
 * Permission to use, copy, modify, distribute, and sell this
 * software and its documentation for any purpose is hereby granted
 * without fee, provided that the above copyright notice appear in
 * all copies and that both that copyright notice and this permission
 * notice appear in supporting documentation, and that the name of
 * the copyright holders not be used in advertising or publicity
 * pertaining to distribution of the software without specific,
 * written prior permission.  The copyright holders make no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied
 * warranty.
 *
 * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
 * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
 * FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
 * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
 * ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
 * THIS SOFTWARE.
 * </pre>
 */
    pub type wl_output;
    pub type wl_registry;
    pub type zwlr_gamma_control_manager_v1;
    pub type zwlr_gamma_control_v1;
    #[no_mangle]
    fn __errno_location() -> *mut libc::c_int;
    #[no_mangle]
    static mut stderr: *mut FILE;
    #[no_mangle]
    fn fprintf(_: *mut FILE, _: *const libc::c_char, _: ...) -> libc::c_int;
    #[no_mangle]
    fn strtod(_: *const libc::c_char, _: *mut *mut libc::c_char)
     -> libc::c_double;
    #[no_mangle]
    fn calloc(_: libc::c_ulong, _: libc::c_ulong) -> *mut libc::c_void;
    #[no_mangle]
    fn exit(_: libc::c_int) -> !;
    #[no_mangle]
    fn mkstemp(__template: *mut libc::c_char) -> libc::c_int;
    #[no_mangle]
    fn strcmp(_: *const libc::c_char, _: *const libc::c_char) -> libc::c_int;
    #[no_mangle]
    fn mmap(__addr: *mut libc::c_void, __len: size_t, __prot: libc::c_int,
            __flags: libc::c_int, __fd: libc::c_int, __offset: __off64_t)
     -> *mut libc::c_void;
    #[no_mangle]
    static mut optarg: *mut libc::c_char;
    #[no_mangle]
    fn close(__fd: libc::c_int) -> libc::c_int;
    #[no_mangle]
    fn getopt(___argc: libc::c_int, ___argv: *const *mut libc::c_char,
              __shortopts: *const libc::c_char) -> libc::c_int;
    #[no_mangle]
    fn unlink(__name: *const libc::c_char) -> libc::c_int;
    #[no_mangle]
    fn ftruncate(__fd: libc::c_int, __length: __off64_t) -> libc::c_int;
    #[no_mangle]
    fn pow(_: libc::c_double, _: libc::c_double) -> libc::c_double;
    #[no_mangle]
    fn wl_list_init(list: *mut wl_list);
    #[no_mangle]
    fn wl_list_insert(list: *mut wl_list, elm: *mut wl_list);
    #[no_mangle]
    fn wl_proxy_marshal(p: *mut wl_proxy, opcode: uint32_t, _: ...);
    #[no_mangle]
    fn wl_proxy_marshal_constructor(proxy: *mut wl_proxy, opcode: uint32_t,
                                    interface: *const wl_interface, _: ...)
     -> *mut wl_proxy;
    #[no_mangle]
    fn wl_proxy_marshal_constructor_versioned(proxy: *mut wl_proxy,
                                              opcode: uint32_t,
                                              interface: *const wl_interface,
                                              version: uint32_t, _: ...)
     -> *mut wl_proxy;
    #[no_mangle]
    fn wl_proxy_add_listener(proxy: *mut wl_proxy,
                             implementation:
                                 *mut Option<unsafe extern "C" fn() -> ()>,
                             data: *mut libc::c_void) -> libc::c_int;
    #[no_mangle]
    fn wl_display_connect(name: *const libc::c_char) -> *mut wl_display;
    #[no_mangle]
    fn wl_display_dispatch(display: *mut wl_display) -> libc::c_int;
    #[no_mangle]
    fn wl_display_roundtrip(display: *mut wl_display) -> libc::c_int;
    #[no_mangle]
    static wl_registry_interface: wl_interface;
    #[no_mangle]
    static wl_output_interface: wl_interface;
    /* *
 * @page page_iface_zwlr_gamma_control_manager_v1 zwlr_gamma_control_manager_v1
 * @section page_iface_zwlr_gamma_control_manager_v1_desc Description
 *
 * This interface is a manager that allows creating per-output gamma
 * controls.
 * @section page_iface_zwlr_gamma_control_manager_v1_api API
 * See @ref iface_zwlr_gamma_control_manager_v1.
 */
/* *
 * @defgroup iface_zwlr_gamma_control_manager_v1 The zwlr_gamma_control_manager_v1 interface
 *
 * This interface is a manager that allows creating per-output gamma
 * controls.
 */
    #[no_mangle]
    static zwlr_gamma_control_manager_v1_interface: wl_interface;
    /* *
 * @page page_iface_zwlr_gamma_control_v1 zwlr_gamma_control_v1
 * @section page_iface_zwlr_gamma_control_v1_desc Description
 *
 * This interface allows a client to adjust gamma tables for a particular
 * output.
 *
 * The client will receive the gamma size, and will then be able to set gamma
 * tables. At any time the compositor can send a failed event indicating that
 * this object is no longer valid.
 *
 * There must always be at most one gamma control object per output, which
 * has exclusive access to this particular output. When the gamma control
 * object is destroyed, the gamma table is restored to its original value.
 * @section page_iface_zwlr_gamma_control_v1_api API
 * See @ref iface_zwlr_gamma_control_v1.
 */
/* *
 * @defgroup iface_zwlr_gamma_control_v1 The zwlr_gamma_control_v1 interface
 *
 * This interface allows a client to adjust gamma tables for a particular
 * output.
 *
 * The client will receive the gamma size, and will then be able to set gamma
 * tables. At any time the compositor can send a failed event indicating that
 * this object is no longer valid.
 *
 * There must always be at most one gamma control object per output, which
 * has exclusive access to this particular output. When the gamma control
 * object is destroyed, the gamma table is restored to its original value.
 */
    #[no_mangle]
    static zwlr_gamma_control_v1_interface: wl_interface;
}
pub type size_t = libc::c_ulong;
pub type __uint16_t = libc::c_ushort;
pub type __int32_t = libc::c_int;
pub type __uint32_t = libc::c_uint;
pub type __off_t = libc::c_long;
pub type __off64_t = libc::c_long;
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct _IO_FILE {
    pub _flags: libc::c_int,
    pub _IO_read_ptr: *mut libc::c_char,
    pub _IO_read_end: *mut libc::c_char,
    pub _IO_read_base: *mut libc::c_char,
    pub _IO_write_base: *mut libc::c_char,
    pub _IO_write_ptr: *mut libc::c_char,
    pub _IO_write_end: *mut libc::c_char,
    pub _IO_buf_base: *mut libc::c_char,
    pub _IO_buf_end: *mut libc::c_char,
    pub _IO_save_base: *mut libc::c_char,
    pub _IO_backup_base: *mut libc::c_char,
    pub _IO_save_end: *mut libc::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: libc::c_int,
    pub _flags2: libc::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: libc::c_ushort,
    pub _vtable_offset: libc::c_schar,
    pub _shortbuf: [libc::c_char; 1],
    pub _lock: *mut libc::c_void,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut libc::c_void,
    pub __pad5: size_t,
    pub _mode: libc::c_int,
    pub _unused2: [libc::c_char; 20],
}
pub type _IO_lock_t = ();
pub type FILE = _IO_FILE;
pub type off_t = __off64_t;
pub type int32_t = __int32_t;
pub type uint16_t = __uint16_t;
pub type uint32_t = __uint32_t;
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wl_message {
    pub name: *const libc::c_char,
    pub signature: *const libc::c_char,
    pub types: *mut *const wl_interface,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wl_interface {
    pub name: *const libc::c_char,
    pub version: libc::c_int,
    pub method_count: libc::c_int,
    pub methods: *const wl_message,
    pub event_count: libc::c_int,
    pub events: *const wl_message,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wl_list {
    pub prev: *mut wl_list,
    pub next: *mut wl_list,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wl_registry_listener {
    pub global: Option<unsafe extern "C" fn(_: *mut libc::c_void,
                                            _: *mut wl_registry, _: uint32_t,
                                            _: *const libc::c_char,
                                            _: uint32_t) -> ()>,
    pub global_remove: Option<unsafe extern "C" fn(_: *mut libc::c_void,
                                                   _: *mut wl_registry,
                                                   _: uint32_t) -> ()>,
}
/* ZWLR_GAMMA_CONTROL_V1_ERROR_ENUM */
/* *
 * @ingroup iface_zwlr_gamma_control_v1
 * @struct zwlr_gamma_control_v1_listener
 */
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct zwlr_gamma_control_v1_listener {
    pub gamma_size: Option<unsafe extern "C" fn(_: *mut libc::c_void,
                                                _: *mut zwlr_gamma_control_v1,
                                                _: uint32_t) -> ()>,
    pub failed: Option<unsafe extern "C" fn(_: *mut libc::c_void,
                                            _: *mut zwlr_gamma_control_v1)
                           -> ()>,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct output {
    pub wl_output: *mut wl_output,
    pub gamma_control: *mut zwlr_gamma_control_v1,
    pub ramp_size: uint32_t,
    pub table_fd: libc::c_int,
    pub table: *mut uint16_t,
    pub link: wl_list,
}
#[inline]
unsafe extern "C" fn wl_display_get_registry(mut wl_display: *mut wl_display)
 -> *mut wl_registry {
    let mut registry: *mut wl_proxy = 0 as *mut wl_proxy;
    registry =
        wl_proxy_marshal_constructor(wl_display as *mut wl_proxy,
                                     1i32 as uint32_t,
                                     &wl_registry_interface as
                                         *const wl_interface,
                                     0 as *mut libc::c_void);
    return registry as *mut wl_registry;
}
#[inline]
unsafe extern "C" fn wl_registry_add_listener(mut wl_registry:
                                                  *mut wl_registry,
                                              mut listener:
                                                  *const wl_registry_listener,
                                              mut data: *mut libc::c_void)
 -> libc::c_int {
    return wl_proxy_add_listener(wl_registry as *mut wl_proxy,
                                 listener as
                                     *mut Option<unsafe extern "C" fn()
                                                     -> ()>, data);
}
#[inline]
unsafe extern "C" fn wl_registry_bind(mut wl_registry: *mut wl_registry,
                                      mut name: uint32_t,
                                      mut interface: *const wl_interface,
                                      mut version: uint32_t)
 -> *mut libc::c_void {
    let mut id: *mut wl_proxy = 0 as *mut wl_proxy;
    id =
        wl_proxy_marshal_constructor_versioned(wl_registry as *mut wl_proxy,
                                               0i32 as uint32_t, interface,
                                               version, name,
                                               (*interface).name, version,
                                               0 as *mut libc::c_void);
    return id as *mut libc::c_void;
}
/* *
 * @ingroup iface_zwlr_gamma_control_manager_v1
 *
 * Create a gamma control that can be used to adjust gamma tables for the
 * provided output.
 */
#[inline]
unsafe extern "C" fn zwlr_gamma_control_manager_v1_get_gamma_control(mut zwlr_gamma_control_manager_v1:
                                                                         *mut zwlr_gamma_control_manager_v1,
                                                                     mut output:
                                                                         *mut wl_output)
 -> *mut zwlr_gamma_control_v1 {
    let mut id: *mut wl_proxy = 0 as *mut wl_proxy;
    id =
        wl_proxy_marshal_constructor(zwlr_gamma_control_manager_v1 as
                                         *mut wl_proxy, 0i32 as uint32_t,
                                     &zwlr_gamma_control_v1_interface as
                                         *const wl_interface,
                                     0 as *mut libc::c_void, output);
    return id as *mut zwlr_gamma_control_v1;
}
/* *
 * @ingroup iface_zwlr_gamma_control_v1
 */
#[inline]
unsafe extern "C" fn zwlr_gamma_control_v1_add_listener(mut zwlr_gamma_control_v1:
                                                            *mut zwlr_gamma_control_v1,
                                                        mut listener:
                                                            *const zwlr_gamma_control_v1_listener,
                                                        mut data:
                                                            *mut libc::c_void)
 -> libc::c_int {
    return wl_proxy_add_listener(zwlr_gamma_control_v1 as *mut wl_proxy,
                                 listener as
                                     *mut Option<unsafe extern "C" fn()
                                                     -> ()>, data);
}
/* *
 * @ingroup iface_zwlr_gamma_control_v1
 *
 * Set the gamma table. The file descriptor can be memory-mapped to provide
 * the raw gamma table, which contains successive gamma ramps for the red,
 * green and blue channels. Each gamma ramp is an array of 16-byte unsigned
 * integers which has the same length as the gamma size.
 *
 * The file descriptor data must have the same length as three times the
 * gamma size.
 */
#[inline]
unsafe extern "C" fn zwlr_gamma_control_v1_set_gamma(mut zwlr_gamma_control_v1:
                                                         *mut zwlr_gamma_control_v1,
                                                     mut fd: int32_t) {
    wl_proxy_marshal(zwlr_gamma_control_v1 as *mut wl_proxy, 0i32 as uint32_t,
                     fd);
}
static mut outputs: wl_list =
    wl_list{prev: 0 as *const wl_list as *mut wl_list,
            next: 0 as *const wl_list as *mut wl_list,};
static mut gamma_control_manager: *mut zwlr_gamma_control_manager_v1 =
    0 as *const zwlr_gamma_control_manager_v1 as
        *mut zwlr_gamma_control_manager_v1;
unsafe extern "C" fn create_anonymous_file(mut size: off_t) -> libc::c_int {
    let mut template: [libc::c_char; 27] =
        *::std::mem::transmute::<&[u8; 27],
                                 &mut [libc::c_char; 27]>(b"/tmp/wlroots-shared-XXXXXX\x00");
    let mut fd: libc::c_int = mkstemp(template.as_mut_ptr());
    if fd < 0i32 { return -1i32 }
    let mut ret: libc::c_int = 0;
    loop  {
        *__errno_location() = 0i32;
        ret = ftruncate(fd, size);
        if !(*__errno_location() == 4i32) { break ; }
    }
    if ret < 0i32 { close(fd); return -1i32 }
    unlink(template.as_mut_ptr());
    return fd;
}
unsafe extern "C" fn create_gamma_table(mut ramp_size: uint32_t,
                                        mut table: *mut *mut uint16_t)
 -> libc::c_int {
    let mut table_size: size_t =
        (ramp_size.wrapping_mul(3i32 as libc::c_uint) as
             libc::c_ulong).wrapping_mul(::std::mem::size_of::<uint16_t>() as
                                             libc::c_ulong);
    let mut fd: libc::c_int = create_anonymous_file(table_size as off_t);
    if fd < 0i32 {
        fprintf(stderr,
                b"failed to create anonymous file\n\x00" as *const u8 as
                    *const libc::c_char);
        return -1i32
    }
    let mut data: *mut libc::c_void =
        mmap(0 as *mut libc::c_void, table_size, 0x1i32 | 0x2i32, 0x1i32, fd,
             0i32 as __off64_t);
    if data == -1i32 as *mut libc::c_void {
        fprintf(stderr,
                b"failed to mmap()\n\x00" as *const u8 as
                    *const libc::c_char);
        close(fd);
        return -1i32
    }
    *table = data as *mut uint16_t;
    return fd;
}
unsafe extern "C" fn gamma_control_handle_gamma_size(mut data:
                                                         *mut libc::c_void,
                                                     mut gamma_control:
                                                         *mut zwlr_gamma_control_v1,
                                                     mut ramp_size:
                                                         uint32_t) {
    let mut output: *mut output = data as *mut output;
    (*output).ramp_size = ramp_size;
    (*output).table_fd = create_gamma_table(ramp_size, &mut (*output).table);
    if (*output).table_fd < 0i32 { exit(1i32); };
}
unsafe extern "C" fn gamma_control_handle_failed(mut data: *mut libc::c_void,
                                                 mut gamma_control:
                                                     *mut zwlr_gamma_control_v1) {
    fprintf(stderr,
            b"failed to set gamma table\n\x00" as *const u8 as
                *const libc::c_char);
    exit(1i32);
}
static mut gamma_control_listener: zwlr_gamma_control_v1_listener =
    unsafe {
        {
            let mut init =
                zwlr_gamma_control_v1_listener{gamma_size:
                                                   Some(gamma_control_handle_gamma_size
                                                            as
                                                            unsafe extern "C" fn(_:
                                                                                     *mut libc::c_void,
                                                                                 _:
                                                                                     *mut zwlr_gamma_control_v1,
                                                                                 _:
                                                                                     uint32_t)
                                                                -> ()),
                                               failed:
                                                   Some(gamma_control_handle_failed
                                                            as
                                                            unsafe extern "C" fn(_:
                                                                                     *mut libc::c_void,
                                                                                 _:
                                                                                     *mut zwlr_gamma_control_v1)
                                                                -> ()),};
            init
        }
    };
unsafe extern "C" fn registry_handle_global(mut data: *mut libc::c_void,
                                            mut registry: *mut wl_registry,
                                            mut name: uint32_t,
                                            mut interface:
                                                *const libc::c_char,
                                            mut version: uint32_t) {
    if strcmp(interface, wl_output_interface.name) == 0i32 {
        let mut output: *mut output =
            calloc(1i32 as libc::c_ulong,
                   ::std::mem::size_of::<output>() as libc::c_ulong) as
                *mut output;
        (*output).wl_output =
            wl_registry_bind(registry, name, &wl_output_interface,
                             1i32 as uint32_t) as *mut wl_output;
        wl_list_insert(&mut outputs, &mut (*output).link);
    } else if strcmp(interface, zwlr_gamma_control_manager_v1_interface.name)
                  == 0i32 {
        gamma_control_manager =
            wl_registry_bind(registry, name,
                             &zwlr_gamma_control_manager_v1_interface,
                             1i32 as uint32_t) as
                *mut zwlr_gamma_control_manager_v1
    };
}
unsafe extern "C" fn registry_handle_global_remove(mut data:
                                                       *mut libc::c_void,
                                                   mut registry:
                                                       *mut wl_registry,
                                                   mut name: uint32_t) {
    // Who cares?
}
static mut registry_listener: wl_registry_listener =
    unsafe {
        {
            let mut init =
                wl_registry_listener{global:
                                         Some(registry_handle_global as
                                                  unsafe extern "C" fn(_:
                                                                           *mut libc::c_void,
                                                                       _:
                                                                           *mut wl_registry,
                                                                       _:
                                                                           uint32_t,
                                                                       _:
                                                                           *const libc::c_char,
                                                                       _:
                                                                           uint32_t)
                                                      -> ()),
                                     global_remove:
                                         Some(registry_handle_global_remove as
                                                  unsafe extern "C" fn(_:
                                                                           *mut libc::c_void,
                                                                       _:
                                                                           *mut wl_registry,
                                                                       _:
                                                                           uint32_t)
                                                      -> ()),};
            init
        }
    };
unsafe extern "C" fn fill_gamma_table(mut table: *mut uint16_t,
                                      mut ramp_size: uint32_t,
                                      mut contrast: libc::c_double,
                                      mut brightness: libc::c_double,
                                      mut gamma: libc::c_double) {
    let mut r: *mut uint16_t = table;
    let mut g: *mut uint16_t = table.offset(ramp_size as isize);
    let mut b: *mut uint16_t =
        table.offset((2i32 as libc::c_uint).wrapping_mul(ramp_size) as isize);
    let mut i: uint32_t = 0i32 as uint32_t;
    while i < ramp_size {
        let mut val: libc::c_double =
            i as libc::c_double /
                ramp_size.wrapping_sub(1i32 as libc::c_uint) as
                    libc::c_double;
        val =
            contrast * pow(val, 1.0f64 / gamma) +
                (brightness - 1i32 as libc::c_double);
        if val > 1.0f64 { val = 1.0f64 } else if val < 0.0f64 { val = 0.0f64 }
        let ref mut fresh0 = *b.offset(i as isize);
        *fresh0 = (65535i32 as libc::c_double * val) as uint16_t;
        let ref mut fresh1 = *g.offset(i as isize);
        *fresh1 = *fresh0;
        *r.offset(i as isize) = *fresh1;
        i = i.wrapping_add(1)
    };
}
static mut usage: [libc::c_char; 188] =
    [117, 115, 97, 103, 101, 58, 32, 103, 97, 109, 109, 97, 45, 99, 111, 110,
     116, 114, 111, 108, 32, 91, 111, 112, 116, 105, 111, 110, 115, 93, 10,
     32, 32, 45, 104, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 115, 104, 111,
     119, 32, 116, 104, 105, 115, 32, 104, 101, 108, 112, 32, 109, 101, 115,
     115, 97, 103, 101, 10, 32, 32, 45, 99, 32, 60, 118, 97, 108, 117, 101,
     62, 32, 32, 115, 101, 116, 32, 99, 111, 110, 116, 114, 97, 115, 116, 32,
     40, 100, 101, 102, 97, 117, 108, 116, 58, 32, 49, 41, 10, 32, 32, 45, 98,
     32, 60, 118, 97, 108, 117, 101, 62, 32, 32, 115, 101, 116, 32, 98, 114,
     105, 103, 104, 116, 110, 101, 115, 115, 32, 40, 100, 101, 102, 97, 117,
     108, 116, 58, 32, 49, 41, 10, 32, 32, 45, 103, 32, 60, 118, 97, 108, 117,
     101, 62, 32, 32, 115, 101, 116, 32, 103, 97, 109, 109, 97, 32, 40, 100,
     101, 102, 97, 117, 108, 116, 58, 32, 49, 41, 10, 0];
unsafe fn main_0(mut argc: libc::c_int, mut argv: *mut *mut libc::c_char)
 -> libc::c_int {
    wl_list_init(&mut outputs);
    let mut contrast: libc::c_double = 1i32 as libc::c_double;
    let mut brightness: libc::c_double = 1i32 as libc::c_double;
    let mut gamma: libc::c_double = 1i32 as libc::c_double;
    let mut opt: libc::c_int = 0;
    loop  {
        opt =
            getopt(argc, argv as *const *mut libc::c_char,
                   b"hc:b:g:\x00" as *const u8 as *const libc::c_char);
        if !(opt != -1i32) { break ; }
        match opt {
            99 => { contrast = strtod(optarg, 0 as *mut *mut libc::c_char) }
            98 => { brightness = strtod(optarg, 0 as *mut *mut libc::c_char) }
            103 => { gamma = strtod(optarg, 0 as *mut *mut libc::c_char) }
            104 | _ => {
                fprintf(stderr, usage.as_ptr());
                return if opt == 'h' as i32 { 0i32 } else { 1i32 }
            }
        }
    }
    let mut display: *mut wl_display =
        wl_display_connect(0 as *const libc::c_char);
    if display.is_null() {
        fprintf(stderr,
                b"failed to create display\n\x00" as *const u8 as
                    *const libc::c_char);
        return -1i32
    }
    let mut registry: *mut wl_registry = wl_display_get_registry(display);
    wl_registry_add_listener(registry, &registry_listener,
                             0 as *mut libc::c_void);
    wl_display_dispatch(display);
    wl_display_roundtrip(display);
    if gamma_control_manager.is_null() {
        fprintf(stderr,
                b"compositor doesn\'t support wlr-gamma-control-unstable-v1\n\x00"
                    as *const u8 as *const libc::c_char);
        return 1i32
    }
    let mut output: *mut output = 0 as *mut output;
    output = (outputs.next as *mut libc::c_char).offset(-32) as *mut output;
    while &mut (*output).link as *mut wl_list != &mut outputs as *mut wl_list
          {
        (*output).gamma_control =
            zwlr_gamma_control_manager_v1_get_gamma_control(gamma_control_manager,
                                                            (*output).wl_output);
        zwlr_gamma_control_v1_add_listener((*output).gamma_control,
                                           &gamma_control_listener,
                                           output as *mut libc::c_void);
        output =
            ((*output).link.next as *mut libc::c_char).offset(-32) as
                *mut output
    }
    wl_display_roundtrip(display);
    output = (outputs.next as *mut libc::c_char).offset(-32) as *mut output;
    while &mut (*output).link as *mut wl_list != &mut outputs as *mut wl_list
          {
        fill_gamma_table((*output).table, (*output).ramp_size, contrast,
                         brightness, gamma);
        zwlr_gamma_control_v1_set_gamma((*output).gamma_control,
                                        (*output).table_fd);
        output =
            ((*output).link.next as *mut libc::c_char).offset(-32) as
                *mut output
    }
    // This space is intentionnally left blank
    while wl_display_dispatch(display) != -1i32 { }
    return 0i32;
}
#[main]
pub fn main() {
    let mut args: Vec<*mut libc::c_char> = Vec::new();
    for arg in ::std::env::args() {
        args.push(::std::ffi::CString::new(arg).expect("Failed to convert argument into CString.").into_raw());
    };
    args.push(::std::ptr::null_mut());
    unsafe {
        ::std::process::exit(main_0((args.len() - 1) as libc::c_int,
                                    args.as_mut_ptr() as
                                        *mut *mut libc::c_char) as i32)
    }
}
