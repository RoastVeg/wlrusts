use libc;
extern "C" {
    pub type _IO_wide_data;
    pub type _IO_codecvt;
    pub type _IO_marker;
    pub type wl_proxy;
    pub type wl_display;
    pub type wl_compositor;
    pub type wl_registry;
    /* Generated by wayland-scanner 1.17.0 */
    /* *
 * @page page_text_input_unstable_v3 The text_input_unstable_v3 protocol
 * Protocol for composing text
 *
 * @section page_desc_text_input_unstable_v3 Description
 *
 * This protocol allows compositors to act as input methods and to send text
 * to applications. A text input object is used to manage state of what are
 * typically text entry fields in the application.
 *
 * This document adheres to the RFC 2119 when using words like "must",
 * "should", "may", etc.
 *
 * Warning! The protocol described in this file is experimental and
 * backward incompatible changes may be made. Backward compatible changes
 * may be added together with the corresponding interface version bump.
 * Backward incompatible changes are done by bumping the version number in
 * the protocol and interface names and resetting the interface version.
 * Once the protocol is to be declared stable, the 'z' prefix and the
 * version number in the protocol and interface names are removed and the
 * interface version number is reset.
 *
 * @section page_ifaces_text_input_unstable_v3 Interfaces
 * - @subpage page_iface_zwp_text_input_v3 - text input
 * - @subpage page_iface_zwp_text_input_manager_v3 - text input manager
 * @section page_copyright_text_input_unstable_v3 Copyright
 * <pre>
 *
 * Copyright © 2012, 2013 Intel Corporation
 * Copyright © 2015, 2016 Jan Arne Petersen
 * Copyright © 2017, 2018 Red Hat, Inc.
 * Copyright © 2018       Purism SPC
 *
 * Permission to use, copy, modify, distribute, and sell this
 * software and its documentation for any purpose is hereby granted
 * without fee, provided that the above copyright notice appear in
 * all copies and that both that copyright notice and this permission
 * notice appear in supporting documentation, and that the name of
 * the copyright holders not be used in advertising or publicity
 * pertaining to distribution of the software without specific,
 * written prior permission.  The copyright holders make no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied
 * warranty.
 *
 * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
 * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
 * FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
 * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
 * ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
 * THIS SOFTWARE.
 * </pre>
 */
    pub type wl_seat;
    pub type wl_surface;
    pub type xdg_wm_base;
    pub type zwp_text_input_v3;
    pub type zwp_text_input_manager_v3;
    pub type wl_egl_window;
    pub type xdg_surface;
    pub type xdg_toplevel;
    pub type wlr_egl_surface;
    #[no_mangle]
    fn glClear(mask: GLbitfield);
    #[no_mangle]
    fn glClearColor(red: GLfloat, green: GLfloat, blue: GLfloat,
                    alpha: GLfloat);
    #[no_mangle]
    fn glViewport(x: GLint, y: GLint, width_0: GLsizei, height_0: GLsizei);
    #[no_mangle]
    static mut stderr: *mut FILE;
    #[no_mangle]
    fn fprintf(_: *mut FILE, _: *const libc::c_char, _: ...) -> libc::c_int;
    #[no_mangle]
    fn printf(_: *const libc::c_char, _: ...) -> libc::c_int;
    #[no_mangle]
    fn atoi(__nptr: *const libc::c_char) -> libc::c_int;
    #[no_mangle]
    fn calloc(_: libc::c_ulong, _: libc::c_ulong) -> *mut libc::c_void;
    #[no_mangle]
    fn free(__ptr: *mut libc::c_void);
    #[no_mangle]
    fn exit(_: libc::c_int) -> !;
    #[no_mangle]
    fn strcpy(_: *mut libc::c_char, _: *const libc::c_char)
     -> *mut libc::c_char;
    #[no_mangle]
    fn strcat(_: *mut libc::c_char, _: *const libc::c_char)
     -> *mut libc::c_char;
    #[no_mangle]
    fn strcmp(_: *const libc::c_char, _: *const libc::c_char) -> libc::c_int;
    #[no_mangle]
    fn strdup(__s: *const libc::c_char) -> *mut libc::c_char;
    #[no_mangle]
    fn strlen(_: *const libc::c_char) -> libc::c_ulong;
    #[no_mangle]
    fn sleep(__seconds: libc::c_uint) -> libc::c_uint;
    #[no_mangle]
    fn wl_proxy_marshal(p: *mut wl_proxy, opcode: uint32_t, _: ...);
    #[no_mangle]
    fn wl_proxy_marshal_constructor(proxy: *mut wl_proxy, opcode: uint32_t,
                                    interface: *const wl_interface, _: ...)
     -> *mut wl_proxy;
    #[no_mangle]
    fn wl_proxy_marshal_constructor_versioned(proxy: *mut wl_proxy,
                                              opcode: uint32_t,
                                              interface: *const wl_interface,
                                              version: uint32_t, _: ...)
     -> *mut wl_proxy;
    #[no_mangle]
    fn wl_proxy_add_listener(proxy: *mut wl_proxy,
                             implementation:
                                 *mut Option<unsafe extern "C" fn() -> ()>,
                             data: *mut libc::c_void) -> libc::c_int;
    #[no_mangle]
    fn wl_display_connect(name: *const libc::c_char) -> *mut wl_display;
    #[no_mangle]
    fn wl_display_dispatch(display_0: *mut wl_display) -> libc::c_int;
    #[no_mangle]
    fn wl_display_roundtrip(display_0: *mut wl_display) -> libc::c_int;
    #[no_mangle]
    static wl_registry_interface: wl_interface;
    #[no_mangle]
    static wl_compositor_interface: wl_interface;
    #[no_mangle]
    static wl_surface_interface: wl_interface;
    #[no_mangle]
    static wl_seat_interface: wl_interface;
    #[no_mangle]
    fn wl_egl_window_create(surface: *mut wl_surface, width_0: libc::c_int,
                            height_0: libc::c_int) -> *mut wl_egl_window;
    #[no_mangle]
    fn wl_egl_window_resize(egl_window_0: *mut wl_egl_window,
                            width_0: libc::c_int, height_0: libc::c_int,
                            dx: libc::c_int, dy: libc::c_int);
    #[no_mangle]
    fn eglSwapBuffers(dpy: EGLDisplay, surface: EGLSurface) -> EGLBoolean;
    #[no_mangle]
    fn eglMakeCurrent(dpy: EGLDisplay, draw_0: EGLSurface, read: EGLSurface,
                      ctx: EGLContext) -> EGLBoolean;
    #[no_mangle]
    fn wlr_egl_create_surface(egl_0: *mut wlr_egl, window: *mut libc::c_void)
     -> EGLSurface;
    #[no_mangle]
    fn wlr_egl_init(egl_0: *mut wlr_egl, platform: EGLenum,
                    remote_display: *mut libc::c_void,
                    config_attribs: *mut EGLint, visual_id: EGLint) -> bool;
    /* *
 * @page page_iface_zwp_text_input_v3 zwp_text_input_v3
 * @section page_iface_zwp_text_input_v3_desc Description
 *
 * The zwp_text_input_v3 interface represents text input and input methods
 * associated with a seat. It provides enter/leave events to follow the
 * text input focus for a seat.
 *
 * Requests are used to enable/disable the text-input object and set
 * state information like surrounding and selected text or the content type.
 * The information about the entered text is sent to the text-input object
 * via the preedit_string and commit_string events.
 *
 * Text is valid UTF-8 encoded, indices and lengths are in bytes. Indices
 * must not point to middle bytes inside a code point: they must either
 * point to the first byte of a code point or to the end of the buffer.
 * Lengths must be measured between two valid indices.
 *
 * Focus moving throughout surfaces will result in the emission of
 * zwp_text_input_v3.enter and zwp_text_input_v3.leave events. The focused
 * surface must commit zwp_text_input_v3.enable and
 * zwp_text_input_v3.disable requests as the keyboard focus moves across
 * editable and non-editable elements of the UI. Those two requests are not
 * expected to be paired with each other, the compositor must be able to
 * handle consecutive series of the same request.
 *
 * State is sent by the state requests (set_surrounding_text,
 * set_content_type and set_cursor_rectangle) and a commit request. After an
 * enter event or disable request all state information is invalidated and
 * needs to be resent by the client.
 * @section page_iface_zwp_text_input_v3_api API
 * See @ref iface_zwp_text_input_v3.
 */
/* *
 * @defgroup iface_zwp_text_input_v3 The zwp_text_input_v3 interface
 *
 * The zwp_text_input_v3 interface represents text input and input methods
 * associated with a seat. It provides enter/leave events to follow the
 * text input focus for a seat.
 *
 * Requests are used to enable/disable the text-input object and set
 * state information like surrounding and selected text or the content type.
 * The information about the entered text is sent to the text-input object
 * via the preedit_string and commit_string events.
 *
 * Text is valid UTF-8 encoded, indices and lengths are in bytes. Indices
 * must not point to middle bytes inside a code point: they must either
 * point to the first byte of a code point or to the end of the buffer.
 * Lengths must be measured between two valid indices.
 *
 * Focus moving throughout surfaces will result in the emission of
 * zwp_text_input_v3.enter and zwp_text_input_v3.leave events. The focused
 * surface must commit zwp_text_input_v3.enable and
 * zwp_text_input_v3.disable requests as the keyboard focus moves across
 * editable and non-editable elements of the UI. Those two requests are not
 * expected to be paired with each other, the compositor must be able to
 * handle consecutive series of the same request.
 *
 * State is sent by the state requests (set_surrounding_text,
 * set_content_type and set_cursor_rectangle) and a commit request. After an
 * enter event or disable request all state information is invalidated and
 * needs to be resent by the client.
 */
    #[no_mangle]
    static zwp_text_input_v3_interface: wl_interface;
    /* *
 * @page page_iface_zwp_text_input_manager_v3 zwp_text_input_manager_v3
 * @section page_iface_zwp_text_input_manager_v3_desc Description
 *
 * A factory for text-input objects. This object is a global singleton.
 * @section page_iface_zwp_text_input_manager_v3_api API
 * See @ref iface_zwp_text_input_manager_v3.
 */
/* *
 * @defgroup iface_zwp_text_input_manager_v3 The zwp_text_input_manager_v3 interface
 *
 * A factory for text-input objects. This object is a global singleton.
 */
    #[no_mangle]
    static zwp_text_input_manager_v3_interface: wl_interface;
    /* *
 * @page page_iface_xdg_wm_base xdg_wm_base
 * @section page_iface_xdg_wm_base_desc Description
 *
 * The xdg_wm_base interface is exposed as a global object enabling clients
 * to turn their wl_surfaces into windows in a desktop environment. It
 * defines the basic functionality needed for clients and the compositor to
 * create windows that can be dragged, resized, maximized, etc, as well as
 * creating transient windows such as popup menus.
 * @section page_iface_xdg_wm_base_api API
 * See @ref iface_xdg_wm_base.
 */
/* *
 * @defgroup iface_xdg_wm_base The xdg_wm_base interface
 *
 * The xdg_wm_base interface is exposed as a global object enabling clients
 * to turn their wl_surfaces into windows in a desktop environment. It
 * defines the basic functionality needed for clients and the compositor to
 * create windows that can be dragged, resized, maximized, etc, as well as
 * creating transient windows such as popup menus.
 */
    #[no_mangle]
    static xdg_wm_base_interface: wl_interface;
    /* *
 * @page page_iface_xdg_surface xdg_surface
 * @section page_iface_xdg_surface_desc Description
 *
 * An interface that may be implemented by a wl_surface, for
 * implementations that provide a desktop-style user interface.
 *
 * It provides a base set of functionality required to construct user
 * interface elements requiring management by the compositor, such as
 * toplevel windows, menus, etc. The types of functionality are split into
 * xdg_surface roles.
 *
 * Creating an xdg_surface does not set the role for a wl_surface. In order
 * to map an xdg_surface, the client must create a role-specific object
 * using, e.g., get_toplevel, get_popup. The wl_surface for any given
 * xdg_surface can have at most one role, and may not be assigned any role
 * not based on xdg_surface.
 *
 * A role must be assigned before any other requests are made to the
 * xdg_surface object.
 *
 * The client must call wl_surface.commit on the corresponding wl_surface
 * for the xdg_surface state to take effect.
 *
 * Creating an xdg_surface from a wl_surface which has a buffer attached or
 * committed is a client error, and any attempts by a client to attach or
 * manipulate a buffer prior to the first xdg_surface.configure call must
 * also be treated as errors.
 *
 * Mapping an xdg_surface-based role surface is defined as making it
 * possible for the surface to be shown by the compositor. Note that
 * a mapped surface is not guaranteed to be visible once it is mapped.
 *
 * For an xdg_surface to be mapped by the compositor, the following
 * conditions must be met:
 * (1) the client has assigned an xdg_surface-based role to the surface
 * (2) the client has set and committed the xdg_surface state and the
 * role-dependent state to the surface
 * (3) the client has committed a buffer to the surface
 *
 * A newly-unmapped surface is considered to have met condition (1) out
 * of the 3 required conditions for mapping a surface if its role surface
 * has not been destroyed.
 * @section page_iface_xdg_surface_api API
 * See @ref iface_xdg_surface.
 */
/* *
 * @defgroup iface_xdg_surface The xdg_surface interface
 *
 * An interface that may be implemented by a wl_surface, for
 * implementations that provide a desktop-style user interface.
 *
 * It provides a base set of functionality required to construct user
 * interface elements requiring management by the compositor, such as
 * toplevel windows, menus, etc. The types of functionality are split into
 * xdg_surface roles.
 *
 * Creating an xdg_surface does not set the role for a wl_surface. In order
 * to map an xdg_surface, the client must create a role-specific object
 * using, e.g., get_toplevel, get_popup. The wl_surface for any given
 * xdg_surface can have at most one role, and may not be assigned any role
 * not based on xdg_surface.
 *
 * A role must be assigned before any other requests are made to the
 * xdg_surface object.
 *
 * The client must call wl_surface.commit on the corresponding wl_surface
 * for the xdg_surface state to take effect.
 *
 * Creating an xdg_surface from a wl_surface which has a buffer attached or
 * committed is a client error, and any attempts by a client to attach or
 * manipulate a buffer prior to the first xdg_surface.configure call must
 * also be treated as errors.
 *
 * Mapping an xdg_surface-based role surface is defined as making it
 * possible for the surface to be shown by the compositor. Note that
 * a mapped surface is not guaranteed to be visible once it is mapped.
 *
 * For an xdg_surface to be mapped by the compositor, the following
 * conditions must be met:
 * (1) the client has assigned an xdg_surface-based role to the surface
 * (2) the client has set and committed the xdg_surface state and the
 * role-dependent state to the surface
 * (3) the client has committed a buffer to the surface
 *
 * A newly-unmapped surface is considered to have met condition (1) out
 * of the 3 required conditions for mapping a surface if its role surface
 * has not been destroyed.
 */
    #[no_mangle]
    static xdg_surface_interface: wl_interface;
    /* *
 * @page page_iface_xdg_toplevel xdg_toplevel
 * @section page_iface_xdg_toplevel_desc Description
 *
 * This interface defines an xdg_surface role which allows a surface to,
 * among other things, set window-like properties such as maximize,
 * fullscreen, and minimize, set application-specific metadata like title and
 * id, and well as trigger user interactive operations such as interactive
 * resize and move.
 *
 * Unmapping an xdg_toplevel means that the surface cannot be shown
 * by the compositor until it is explicitly mapped again.
 * All active operations (e.g., move, resize) are canceled and all
 * attributes (e.g. title, state, stacking, ...) are discarded for
 * an xdg_toplevel surface when it is unmapped.
 *
 * Attaching a null buffer to a toplevel unmaps the surface.
 * @section page_iface_xdg_toplevel_api API
 * See @ref iface_xdg_toplevel.
 */
/* *
 * @defgroup iface_xdg_toplevel The xdg_toplevel interface
 *
 * This interface defines an xdg_surface role which allows a surface to,
 * among other things, set window-like properties such as maximize,
 * fullscreen, and minimize, set application-specific metadata like title and
 * id, and well as trigger user interactive operations such as interactive
 * resize and move.
 *
 * Unmapping an xdg_toplevel means that the surface cannot be shown
 * by the compositor until it is explicitly mapped again.
 * All active operations (e.g., move, resize) are canceled and all
 * attributes (e.g. title, state, stacking, ...) are discarded for
 * an xdg_toplevel surface when it is unmapped.
 *
 * Attaching a null buffer to a toplevel unmaps the surface.
 */
    #[no_mangle]
    static xdg_toplevel_interface: wl_interface;
}
pub type __int32_t = libc::c_int;
pub type __uint32_t = libc::c_uint;
pub type __uint64_t = libc::c_ulong;
pub type __off_t = libc::c_long;
pub type __off64_t = libc::c_long;
pub type int32_t = __int32_t;
pub type uint32_t = __uint32_t;
pub type uint64_t = __uint64_t;
pub type khronos_int32_t = int32_t;
pub type khronos_float_t = libc::c_float;
pub type GLfloat = khronos_float_t;
pub type GLbitfield = libc::c_uint;
pub type GLint = libc::c_int;
pub type GLsizei = libc::c_int;
pub type size_t = libc::c_ulong;
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct _IO_FILE {
    pub _flags: libc::c_int,
    pub _IO_read_ptr: *mut libc::c_char,
    pub _IO_read_end: *mut libc::c_char,
    pub _IO_read_base: *mut libc::c_char,
    pub _IO_write_base: *mut libc::c_char,
    pub _IO_write_ptr: *mut libc::c_char,
    pub _IO_write_end: *mut libc::c_char,
    pub _IO_buf_base: *mut libc::c_char,
    pub _IO_buf_end: *mut libc::c_char,
    pub _IO_save_base: *mut libc::c_char,
    pub _IO_backup_base: *mut libc::c_char,
    pub _IO_save_end: *mut libc::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: libc::c_int,
    pub _flags2: libc::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: libc::c_ushort,
    pub _vtable_offset: libc::c_schar,
    pub _shortbuf: [libc::c_char; 1],
    pub _lock: *mut libc::c_void,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut libc::c_void,
    pub __pad5: size_t,
    pub _mode: libc::c_int,
    pub _unused2: [libc::c_char; 20],
}
pub type _IO_lock_t = ();
pub type FILE = _IO_FILE;
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wl_message {
    pub name: *const libc::c_char,
    pub signature: *const libc::c_char,
    pub types: *mut *const wl_interface,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wl_interface {
    pub name: *const libc::c_char,
    pub version: libc::c_int,
    pub method_count: libc::c_int,
    pub methods: *const wl_message,
    pub event_count: libc::c_int,
    pub events: *const wl_message,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wl_list {
    pub prev: *mut wl_list,
    pub next: *mut wl_list,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wl_array {
    pub size: size_t,
    pub alloc: size_t,
    pub data: *mut libc::c_void,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wl_listener {
    pub link: wl_list,
    pub notify: wl_notify_func_t,
}
pub type wl_notify_func_t
    =
    Option<unsafe extern "C" fn(_: *mut wl_listener, _: *mut libc::c_void)
               -> ()>;
pub type EGLint = khronos_int32_t;
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wl_registry_listener {
    pub global: Option<unsafe extern "C" fn(_: *mut libc::c_void,
                                            _: *mut wl_registry, _: uint32_t,
                                            _: *const libc::c_char,
                                            _: uint32_t) -> ()>,
    pub global_remove: Option<unsafe extern "C" fn(_: *mut libc::c_void,
                                                   _: *mut wl_registry,
                                                   _: uint32_t) -> ()>,
}
pub type wl_shm_format = libc::c_uint;
pub const WL_SHM_FORMAT_YVU444: wl_shm_format = 875714137;
pub const WL_SHM_FORMAT_YUV444: wl_shm_format = 875713881;
pub const WL_SHM_FORMAT_YVU422: wl_shm_format = 909203033;
pub const WL_SHM_FORMAT_YUV422: wl_shm_format = 909202777;
pub const WL_SHM_FORMAT_YVU420: wl_shm_format = 842094169;
pub const WL_SHM_FORMAT_YUV420: wl_shm_format = 842093913;
pub const WL_SHM_FORMAT_YVU411: wl_shm_format = 825316953;
pub const WL_SHM_FORMAT_YUV411: wl_shm_format = 825316697;
pub const WL_SHM_FORMAT_YVU410: wl_shm_format = 961893977;
pub const WL_SHM_FORMAT_YUV410: wl_shm_format = 961959257;
pub const WL_SHM_FORMAT_NV61: wl_shm_format = 825644622;
pub const WL_SHM_FORMAT_NV16: wl_shm_format = 909203022;
pub const WL_SHM_FORMAT_NV21: wl_shm_format = 825382478;
pub const WL_SHM_FORMAT_NV12: wl_shm_format = 842094158;
pub const WL_SHM_FORMAT_AYUV: wl_shm_format = 1448433985;
pub const WL_SHM_FORMAT_VYUY: wl_shm_format = 1498765654;
pub const WL_SHM_FORMAT_UYVY: wl_shm_format = 1498831189;
pub const WL_SHM_FORMAT_YVYU: wl_shm_format = 1431918169;
pub const WL_SHM_FORMAT_YUYV: wl_shm_format = 1448695129;
pub const WL_SHM_FORMAT_BGRA1010102: wl_shm_format = 808665410;
pub const WL_SHM_FORMAT_RGBA1010102: wl_shm_format = 808665426;
pub const WL_SHM_FORMAT_ABGR2101010: wl_shm_format = 808665665;
pub const WL_SHM_FORMAT_ARGB2101010: wl_shm_format = 808669761;
pub const WL_SHM_FORMAT_BGRX1010102: wl_shm_format = 808671298;
pub const WL_SHM_FORMAT_RGBX1010102: wl_shm_format = 808671314;
pub const WL_SHM_FORMAT_XBGR2101010: wl_shm_format = 808665688;
pub const WL_SHM_FORMAT_XRGB2101010: wl_shm_format = 808669784;
pub const WL_SHM_FORMAT_BGRA8888: wl_shm_format = 875708738;
pub const WL_SHM_FORMAT_RGBA8888: wl_shm_format = 875708754;
pub const WL_SHM_FORMAT_ABGR8888: wl_shm_format = 875708993;
pub const WL_SHM_FORMAT_BGRX8888: wl_shm_format = 875714626;
pub const WL_SHM_FORMAT_RGBX8888: wl_shm_format = 875714642;
pub const WL_SHM_FORMAT_XBGR8888: wl_shm_format = 875709016;
pub const WL_SHM_FORMAT_BGR888: wl_shm_format = 875710274;
pub const WL_SHM_FORMAT_RGB888: wl_shm_format = 875710290;
pub const WL_SHM_FORMAT_BGR565: wl_shm_format = 909199170;
pub const WL_SHM_FORMAT_RGB565: wl_shm_format = 909199186;
pub const WL_SHM_FORMAT_BGRA5551: wl_shm_format = 892420418;
pub const WL_SHM_FORMAT_RGBA5551: wl_shm_format = 892420434;
pub const WL_SHM_FORMAT_ABGR1555: wl_shm_format = 892420673;
pub const WL_SHM_FORMAT_ARGB1555: wl_shm_format = 892424769;
pub const WL_SHM_FORMAT_BGRX5551: wl_shm_format = 892426306;
pub const WL_SHM_FORMAT_RGBX5551: wl_shm_format = 892426322;
pub const WL_SHM_FORMAT_XBGR1555: wl_shm_format = 892420696;
pub const WL_SHM_FORMAT_XRGB1555: wl_shm_format = 892424792;
pub const WL_SHM_FORMAT_BGRA4444: wl_shm_format = 842088770;
pub const WL_SHM_FORMAT_RGBA4444: wl_shm_format = 842088786;
pub const WL_SHM_FORMAT_ABGR4444: wl_shm_format = 842089025;
pub const WL_SHM_FORMAT_ARGB4444: wl_shm_format = 842093121;
pub const WL_SHM_FORMAT_BGRX4444: wl_shm_format = 842094658;
pub const WL_SHM_FORMAT_RGBX4444: wl_shm_format = 842094674;
pub const WL_SHM_FORMAT_XBGR4444: wl_shm_format = 842089048;
pub const WL_SHM_FORMAT_XRGB4444: wl_shm_format = 842093144;
pub const WL_SHM_FORMAT_BGR233: wl_shm_format = 944916290;
pub const WL_SHM_FORMAT_RGB332: wl_shm_format = 943867730;
pub const WL_SHM_FORMAT_C8: wl_shm_format = 538982467;
pub const WL_SHM_FORMAT_XRGB8888: wl_shm_format = 1;
pub const WL_SHM_FORMAT_ARGB8888: wl_shm_format = 0;
pub type EGLBoolean = libc::c_uint;
pub type EGLDisplay = *mut libc::c_void;
pub type EGLConfig = *mut libc::c_void;
pub type EGLSurface = *mut libc::c_void;
pub type EGLContext = *mut libc::c_void;
pub type EGLenum = libc::c_uint;
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wlr_drm_format {
    pub format: uint32_t,
    pub len: size_t,
    pub cap: size_t,
    pub modifiers: [uint64_t; 0],
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wlr_drm_format_set {
    pub len: size_t,
    pub cap: size_t,
    pub formats: *mut *mut wlr_drm_format,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wlr_egl {
    pub platform: EGLenum,
    pub display: EGLDisplay,
    pub config: EGLConfig,
    pub context: EGLContext,
    pub exts_str: *const libc::c_char,
    pub exts: C2RustUnnamed,
    pub wl_display: *mut wl_display,
    pub dmabuf_formats: wlr_drm_format_set,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct C2RustUnnamed {
    pub bind_wayland_display_wl: bool,
    pub buffer_age_ext: bool,
    pub image_base_khr: bool,
    pub image_dma_buf_export_mesa: bool,
    pub image_dmabuf_import_ext: bool,
    pub image_dmabuf_import_modifiers_ext: bool,
    pub swap_buffers_with_damage_ext: bool,
    pub swap_buffers_with_damage_khr: bool,
}
/* *
 * @ingroup iface_zwp_text_input_v3
 * text change reason
 *
 * Reason for the change of surrounding text or cursor posision.
 */
pub type zwp_text_input_v3_change_cause = libc::c_uint;
/* *
	 * something else than the input method caused the change
	 */
pub const ZWP_TEXT_INPUT_V3_CHANGE_CAUSE_OTHER: zwp_text_input_v3_change_cause
          =
    1;
/* *
	 * input method caused the change
	 */
pub const ZWP_TEXT_INPUT_V3_CHANGE_CAUSE_INPUT_METHOD:
          zwp_text_input_v3_change_cause =
    0;
/* ZWP_TEXT_INPUT_V3_CONTENT_PURPOSE_ENUM */
/* *
 * @ingroup iface_zwp_text_input_v3
 * @struct zwp_text_input_v3_listener
 */
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct zwp_text_input_v3_listener {
    pub enter: Option<unsafe extern "C" fn(_: *mut libc::c_void,
                                           _: *mut zwp_text_input_v3,
                                           _: *mut wl_surface) -> ()>,
    pub leave: Option<unsafe extern "C" fn(_: *mut libc::c_void,
                                           _: *mut zwp_text_input_v3,
                                           _: *mut wl_surface) -> ()>,
    pub preedit_string: Option<unsafe extern "C" fn(_: *mut libc::c_void,
                                                    _: *mut zwp_text_input_v3,
                                                    _: *const libc::c_char,
                                                    _: int32_t, _: int32_t)
                                   -> ()>,
    pub commit_string: Option<unsafe extern "C" fn(_: *mut libc::c_void,
                                                   _: *mut zwp_text_input_v3,
                                                   _: *const libc::c_char)
                                  -> ()>,
    pub delete_surrounding_text: Option<unsafe extern "C" fn(_:
                                                                 *mut libc::c_void,
                                                             _:
                                                                 *mut zwp_text_input_v3,
                                                             _: uint32_t,
                                                             _: uint32_t)
                                            -> ()>,
    pub done: Option<unsafe extern "C" fn(_: *mut libc::c_void,
                                          _: *mut zwp_text_input_v3,
                                          _: uint32_t) -> ()>,
}
/* XDG_SURFACE_ERROR_ENUM */
/* *
 * @ingroup iface_xdg_surface
 * @struct xdg_surface_listener
 */
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct xdg_surface_listener {
    pub configure: Option<unsafe extern "C" fn(_: *mut libc::c_void,
                                               _: *mut xdg_surface,
                                               _: uint32_t) -> ()>,
}
/* *
 * @ingroup iface_xdg_toplevel
 */
/* *
 * @ingroup iface_xdg_toplevel
 */
/* *
 * @ingroup iface_xdg_toplevel
 */
/* *
 * @ingroup iface_xdg_toplevel
 */
/* XDG_TOPLEVEL_STATE_ENUM */
/* *
 * @ingroup iface_xdg_toplevel
 * @struct xdg_toplevel_listener
 */
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct xdg_toplevel_listener {
    pub configure: Option<unsafe extern "C" fn(_: *mut libc::c_void,
                                               _: *mut xdg_toplevel,
                                               _: int32_t, _: int32_t,
                                               _: *mut wl_array) -> ()>,
    pub close: Option<unsafe extern "C" fn(_: *mut libc::c_void,
                                           _: *mut xdg_toplevel) -> ()>,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct text_input_state {
    pub commit: *mut libc::c_char,
    pub preedit: C2RustUnnamed_1,
    pub delete_surrounding: C2RustUnnamed_0,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct C2RustUnnamed_0 {
    pub after_length: uint32_t,
    pub before_length: uint32_t,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct C2RustUnnamed_1 {
    pub text: *mut libc::c_char,
    pub cursor_begin: int32_t,
    pub cursor_end: int32_t,
}
#[inline]
unsafe extern "C" fn wl_display_get_registry(mut wl_display: *mut wl_display)
 -> *mut wl_registry {
    let mut registry: *mut wl_proxy = 0 as *mut wl_proxy;
    registry =
        wl_proxy_marshal_constructor(wl_display as *mut wl_proxy,
                                     1i32 as uint32_t,
                                     &wl_registry_interface as
                                         *const wl_interface,
                                     0 as *mut libc::c_void);
    return registry as *mut wl_registry;
}
#[inline]
unsafe extern "C" fn wl_registry_add_listener(mut wl_registry:
                                                  *mut wl_registry,
                                              mut listener:
                                                  *const wl_registry_listener,
                                              mut data: *mut libc::c_void)
 -> libc::c_int {
    return wl_proxy_add_listener(wl_registry as *mut wl_proxy,
                                 listener as
                                     *mut Option<unsafe extern "C" fn()
                                                     -> ()>, data);
}
#[inline]
unsafe extern "C" fn wl_registry_bind(mut wl_registry: *mut wl_registry,
                                      mut name: uint32_t,
                                      mut interface: *const wl_interface,
                                      mut version: uint32_t)
 -> *mut libc::c_void {
    let mut id: *mut wl_proxy = 0 as *mut wl_proxy;
    id =
        wl_proxy_marshal_constructor_versioned(wl_registry as *mut wl_proxy,
                                               0i32 as uint32_t, interface,
                                               version, name,
                                               (*interface).name, version,
                                               0 as *mut libc::c_void);
    return id as *mut libc::c_void;
}
#[inline]
unsafe extern "C" fn wl_compositor_create_surface(mut wl_compositor:
                                                      *mut wl_compositor)
 -> *mut wl_surface {
    let mut id: *mut wl_proxy = 0 as *mut wl_proxy;
    id =
        wl_proxy_marshal_constructor(wl_compositor as *mut wl_proxy,
                                     0i32 as uint32_t,
                                     &wl_surface_interface as
                                         *const wl_interface,
                                     0 as *mut libc::c_void);
    return id as *mut wl_surface;
}
#[inline]
unsafe extern "C" fn wl_surface_commit(mut wl_surface: *mut wl_surface) {
    wl_proxy_marshal(wl_surface as *mut wl_proxy, 6i32 as uint32_t);
}
/* *
 * @ingroup iface_zwp_text_input_v3
 */
#[inline]
unsafe extern "C" fn zwp_text_input_v3_add_listener(mut zwp_text_input_v3:
                                                        *mut zwp_text_input_v3,
                                                    mut listener:
                                                        *const zwp_text_input_v3_listener,
                                                    mut data:
                                                        *mut libc::c_void)
 -> libc::c_int {
    return wl_proxy_add_listener(zwp_text_input_v3 as *mut wl_proxy,
                                 listener as
                                     *mut Option<unsafe extern "C" fn()
                                                     -> ()>, data);
}
/* *
 * @ingroup iface_zwp_text_input_v3
 *
 * Requests text input on the surface previously obtained from the enter
 * event.
 *
 * This request must be issued every time the active text input changes
 * to a new one, including within the current surface. Use
 * zwp_text_input_v3.disable when there is no longer any input focus on
 * the current surface.
 *
 * This request resets all state associated with previous enable, disable,
 * set_surrounding_text, set_text_change_cause, set_content_type, and
 * set_cursor_rectangle requests, as well as the state associated with
 * preedit_string, commit_string, and delete_surrounding_text events.
 *
 * The set_surrounding_text, set_content_type and set_cursor_rectangle
 * requests must follow if the text input supports the necessary
 * functionality.
 *
 * State set with this request is double-buffered. It will get applied on
 * the next zwp_text_input_v3.commit request, and stay valid until the
 * next committed enable or disable request.
 *
 * The changes must be applied by the compositor after issuing a
 * zwp_text_input_v3.commit request.
 */
#[inline]
unsafe extern "C" fn zwp_text_input_v3_enable(mut zwp_text_input_v3:
                                                  *mut zwp_text_input_v3) {
    wl_proxy_marshal(zwp_text_input_v3 as *mut wl_proxy, 1i32 as uint32_t);
}
/* *
 * @ingroup iface_zwp_text_input_v3
 *
 * Explicitly disable text input on the current surface (typically when
 * there is no focus on any text entry inside the surface).
 *
 * State set with this request is double-buffered. It will get applied on
 * the next zwp_text_input_v3.commit request.
 */
#[inline]
unsafe extern "C" fn zwp_text_input_v3_disable(mut zwp_text_input_v3:
                                                   *mut zwp_text_input_v3) {
    wl_proxy_marshal(zwp_text_input_v3 as *mut wl_proxy, 2i32 as uint32_t);
}
/* *
 * @ingroup iface_zwp_text_input_v3
 *
 * Sets the surrounding plain text around the input, excluding the preedit
 * text.
 *
 * The client should notify the compositor of any changes in any of the
 * values carried with this request, including changes caused by handling
 * incoming text-input events as well as changes caused by other
 * mechanisms like keyboard typing.
 *
 * If the client is unaware of the text around the cursor, it should not
 * issue this request, to signify lack of support to the compositor.
 *
 * Text is UTF-8 encoded, and should include the cursor position, the
 * complete selection and additional characters before and after them.
 * There is a maximum length of wayland messages, so text can not be
 * longer than 4000 bytes.
 *
 * Cursor is the byte offset of the cursor within text buffer.
 *
 * Anchor is the byte offset of the selection anchor within text buffer.
 * If there is no selected text, anchor is the same as cursor.
 *
 * If any preedit text is present, it is replaced with a cursor for the
 * purpose of this event.
 *
 * Values set with this request are double-buffered. They will get applied
 * on the next zwp_text_input_v3.commit request, and stay valid until the
 * next committed enable or disable request.
 *
 * The initial state for affected fields is empty, meaning that the text
 * input does not support sending surrounding text. If the empty values
 * get applied, subsequent attempts to change them may have no effect.
 */
#[inline]
unsafe extern "C" fn zwp_text_input_v3_set_surrounding_text(mut zwp_text_input_v3:
                                                                *mut zwp_text_input_v3,
                                                            mut text:
                                                                *const libc::c_char,
                                                            mut cursor:
                                                                int32_t,
                                                            mut anchor:
                                                                int32_t) {
    wl_proxy_marshal(zwp_text_input_v3 as *mut wl_proxy, 3i32 as uint32_t,
                     text, cursor, anchor);
}
/* *
 * @ingroup iface_zwp_text_input_v3
 *
 * Tells the compositor why the text surrounding the cursor changed.
 *
 * Whenever the client detects an external change in text, cursor, or
 * anchor posision, it must issue this request to the compositor. This
 * request is intended to give the input method a chance to update the
 * preedit text in an appropriate way, e.g. by removing it when the user
 * starts typing with a keyboard.
 *
 * cause describes the source of the change.
 *
 * The value set with this request is double-buffered. It must be applied
 * and reset to initial at the next zwp_text_input_v3.commit request.
 *
 * The initial value of cause is input_method.
 */
#[inline]
unsafe extern "C" fn zwp_text_input_v3_set_text_change_cause(mut zwp_text_input_v3:
                                                                 *mut zwp_text_input_v3,
                                                             mut cause:
                                                                 uint32_t) {
    wl_proxy_marshal(zwp_text_input_v3 as *mut wl_proxy, 4i32 as uint32_t,
                     cause);
}
/* *
 * @ingroup iface_zwp_text_input_v3
 *
 * Atomically applies state changes recently sent to the compositor.
 *
 * The commit request establishes and updates the state of the client, and
 * must be issued after any changes to apply them.
 *
 * Text input state (enabled status, content purpose, content hint,
 * surrounding text and change cause, cursor rectangle) is conceptually
 * double-buffered within the context of a text input, i.e. between a
 * committed enable request and the following committed enable or disable
 * request.
 *
 * Protocol requests modify the pending state, as opposed to the current
 * state in use by the input method. A commit request atomically applies
 * all pending state, replacing the current state. After commit, the new
 * pending state is as documented for each related request.
 *
 * Requests are applied in the order of arrival.
 *
 * Neither current nor pending state are modified unless noted otherwise.
 *
 * The compositor must count the number of commit requests coming from
 * each zwp_text_input_v3 object and use the count as the serial in done
 * events.
 */
#[inline]
unsafe extern "C" fn zwp_text_input_v3_commit(mut zwp_text_input_v3:
                                                  *mut zwp_text_input_v3) {
    wl_proxy_marshal(zwp_text_input_v3 as *mut wl_proxy, 7i32 as uint32_t);
}
/* *
 * @ingroup iface_zwp_text_input_manager_v3
 *
 * Creates a new text-input object for a given seat.
 */
#[inline]
unsafe extern "C" fn zwp_text_input_manager_v3_get_text_input(mut zwp_text_input_manager_v3:
                                                                  *mut zwp_text_input_manager_v3,
                                                              mut seat_0:
                                                                  *mut wl_seat)
 -> *mut zwp_text_input_v3 {
    let mut id: *mut wl_proxy = 0 as *mut wl_proxy;
    id =
        wl_proxy_marshal_constructor(zwp_text_input_manager_v3 as
                                         *mut wl_proxy, 1i32 as uint32_t,
                                     &zwp_text_input_v3_interface as
                                         *const wl_interface,
                                     0 as *mut libc::c_void, seat_0);
    return id as *mut zwp_text_input_v3;
}
/* *
 * @ingroup iface_xdg_wm_base
 *
 * This creates an xdg_surface for the given surface. While xdg_surface
 * itself is not a role, the corresponding surface may only be assigned
 * a role extending xdg_surface, such as xdg_toplevel or xdg_popup.
 *
 * This creates an xdg_surface for the given surface. An xdg_surface is
 * used as basis to define a role to a given surface, such as xdg_toplevel
 * or xdg_popup. It also manages functionality shared between xdg_surface
 * based surface roles.
 *
 * See the documentation of xdg_surface for more details about what an
 * xdg_surface is and how it is used.
 */
#[inline]
unsafe extern "C" fn xdg_wm_base_get_xdg_surface(mut xdg_wm_base:
                                                     *mut xdg_wm_base,
                                                 mut surface: *mut wl_surface)
 -> *mut xdg_surface {
    let mut id: *mut wl_proxy = 0 as *mut wl_proxy;
    id =
        wl_proxy_marshal_constructor(xdg_wm_base as *mut wl_proxy,
                                     2i32 as uint32_t,
                                     &xdg_surface_interface as
                                         *const wl_interface,
                                     0 as *mut libc::c_void, surface);
    return id as *mut xdg_surface;
}
/* *
 * @ingroup iface_xdg_surface
 */
#[inline]
unsafe extern "C" fn xdg_surface_add_listener(mut xdg_surface:
                                                  *mut xdg_surface,
                                              mut listener:
                                                  *const xdg_surface_listener,
                                              mut data: *mut libc::c_void)
 -> libc::c_int {
    return wl_proxy_add_listener(xdg_surface as *mut wl_proxy,
                                 listener as
                                     *mut Option<unsafe extern "C" fn()
                                                     -> ()>, data);
}
/* *
 * @ingroup iface_xdg_surface
 *
 * This creates an xdg_toplevel object for the given xdg_surface and gives
 * the associated wl_surface the xdg_toplevel role.
 *
 * See the documentation of xdg_toplevel for more details about what an
 * xdg_toplevel is and how it is used.
 */
#[inline]
unsafe extern "C" fn xdg_surface_get_toplevel(mut xdg_surface:
                                                  *mut xdg_surface)
 -> *mut xdg_toplevel {
    let mut id: *mut wl_proxy = 0 as *mut wl_proxy;
    id =
        wl_proxy_marshal_constructor(xdg_surface as *mut wl_proxy,
                                     1i32 as uint32_t,
                                     &xdg_toplevel_interface as
                                         *const wl_interface,
                                     0 as *mut libc::c_void);
    return id as *mut xdg_toplevel;
}
/* *
 * @ingroup iface_xdg_surface
 *
 * When a configure event is received, if a client commits the
 * surface in response to the configure event, then the client
 * must make an ack_configure request sometime before the commit
 * request, passing along the serial of the configure event.
 *
 * For instance, for toplevel surfaces the compositor might use this
 * information to move a surface to the top left only when the client has
 * drawn itself for the maximized or fullscreen state.
 *
 * If the client receives multiple configure events before it
 * can respond to one, it only has to ack the last configure event.
 *
 * A client is not required to commit immediately after sending
 * an ack_configure request - it may even ack_configure several times
 * before its next surface commit.
 *
 * A client may send multiple ack_configure requests before committing, but
 * only the last request sent before a commit indicates which configure
 * event the client really is responding to.
 */
#[inline]
unsafe extern "C" fn xdg_surface_ack_configure(mut xdg_surface:
                                                   *mut xdg_surface,
                                               mut serial_0: uint32_t) {
    wl_proxy_marshal(xdg_surface as *mut wl_proxy, 4i32 as uint32_t,
                     serial_0);
}
/* *
 * @ingroup iface_xdg_toplevel
 */
#[inline]
unsafe extern "C" fn xdg_toplevel_add_listener(mut xdg_toplevel:
                                                   *mut xdg_toplevel,
                                               mut listener:
                                                   *const xdg_toplevel_listener,
                                               mut data: *mut libc::c_void)
 -> libc::c_int {
    return wl_proxy_add_listener(xdg_toplevel as *mut wl_proxy,
                                 listener as
                                     *mut Option<unsafe extern "C" fn()
                                                     -> ()>, data);
}
#[no_mangle]
pub static mut usage: [libc::c_char; 832] =
    [85, 115, 97, 103, 101, 58, 32, 116, 101, 120, 116, 45, 105, 110, 112,
     117, 116, 32, 91, 115, 101, 99, 111, 110, 100, 115, 32, 91, 119, 105,
     100, 116, 104, 32, 104, 101, 105, 103, 104, 116, 93, 93, 10, 10, 67, 114,
     101, 97, 116, 101, 115, 32, 97, 32, 120, 100, 103, 45, 116, 111, 112,
     108, 101, 118, 101, 108, 32, 117, 115, 105, 110, 103, 32, 116, 104, 101,
     32, 116, 101, 120, 116, 45, 105, 110, 112, 117, 116, 32, 112, 114, 111,
     116, 111, 99, 111, 108, 46, 10, 73, 116, 32, 119, 105, 108, 108, 32, 98,
     101, 32, 115, 111, 108, 105, 100, 32, 98, 108, 97, 99, 107, 32, 119, 104,
     101, 110, 32, 105, 116, 32, 104, 97, 115, 32, 110, 111, 32, 116, 101,
     120, 116, 32, 105, 110, 112, 117, 116, 32, 102, 111, 99, 117, 115, 44,
     32, 121, 101, 108, 108, 111, 119, 32, 119, 104, 101, 110, 32, 105, 116,
     10, 104, 97, 115, 32, 102, 111, 99, 117, 115, 44, 32, 97, 110, 100, 32,
     114, 101, 100, 32, 119, 104, 101, 110, 32, 105, 116, 32, 119, 97, 115,
     32, 110, 111, 116, 105, 102, 105, 101, 100, 32, 116, 104, 97, 116, 32,
     116, 104, 101, 32, 102, 111, 99, 117, 115, 32, 109, 111, 118, 101, 100,
     32, 97, 119, 97, 121, 10, 98, 117, 116, 32, 115, 116, 105, 108, 108, 32,
     100, 105, 100, 110, 39, 116, 32, 103, 105, 118, 101, 32, 117, 112, 32,
     116, 104, 101, 32, 116, 101, 120, 116, 32, 105, 110, 112, 117, 116, 32,
     97, 98, 105, 108, 105, 116, 121, 46, 10, 10, 84, 104, 101, 32, 34, 115,
     101, 99, 111, 110, 100, 115, 34, 32, 97, 114, 103, 117, 109, 101, 110,
     116, 32, 105, 115, 32, 111, 112, 116, 105, 111, 110, 97, 108, 32, 97,
     110, 100, 32, 100, 101, 102, 105, 110, 101, 115, 32, 116, 104, 101, 32,
     100, 101, 108, 97, 121, 32, 98, 101, 116, 119, 101, 101, 110, 32, 103,
     101, 116, 116, 105, 110, 103, 10, 110, 111, 116, 105, 102, 105, 101, 100,
     32, 111, 102, 32, 108, 111, 115, 116, 32, 102, 111, 99, 117, 115, 32, 97,
     110, 100, 32, 114, 101, 108, 101, 97, 115, 105, 110, 103, 32, 116, 101,
     120, 116, 32, 105, 110, 112, 117, 116, 46, 10, 10, 84, 104, 101, 32, 34,
     119, 105, 100, 116, 104, 34, 32, 97, 110, 100, 32, 34, 104, 101, 105,
     103, 104, 116, 34, 32, 97, 114, 103, 117, 109, 101, 110, 116, 115, 32,
     100, 101, 102, 105, 110, 101, 32, 116, 104, 101, 32, 119, 105, 110, 100,
     111, 119, 32, 115, 104, 97, 112, 101, 46, 10, 10, 84, 104, 101, 32, 99,
     111, 110, 115, 111, 108, 101, 32, 119, 105, 108, 108, 32, 112, 114, 105,
     110, 116, 32, 116, 104, 101, 32, 105, 110, 116, 101, 114, 110, 97, 108,
     32, 115, 116, 97, 116, 101, 32, 111, 102, 32, 116, 104, 101, 32, 116,
     101, 120, 116, 32, 102, 105, 101, 108, 100, 58, 10, 45, 32, 116, 104,
     101, 32, 116, 101, 120, 116, 32, 105, 110, 32, 116, 104, 101, 32, 49,
     115, 116, 32, 108, 105, 110, 101, 10, 45, 32, 34, 46, 34, 32, 117, 110,
     100, 101, 114, 32, 101, 97, 99, 104, 32, 112, 114, 101, 101, 100, 105,
     116, 32, 99, 104, 97, 114, 97, 99, 116, 101, 114, 10, 45, 32, 34, 95, 34,
     32, 117, 110, 100, 101, 114, 32, 101, 97, 99, 104, 32, 115, 101, 108,
     101, 99, 116, 101, 100, 32, 112, 114, 101, 101, 100, 105, 116, 32, 99,
     104, 97, 114, 97, 99, 116, 101, 114, 10, 45, 32, 34, 124, 34, 32, 97,
     116, 32, 116, 104, 101, 32, 99, 117, 114, 115, 111, 114, 32, 112, 111,
     115, 105, 116, 105, 111, 110, 32, 105, 102, 32, 116, 104, 101, 114, 101,
     32, 97, 114, 101, 32, 110, 111, 32, 115, 101, 108, 101, 99, 116, 101,
     100, 32, 99, 104, 97, 114, 97, 99, 116, 101, 114, 115, 32, 105, 110, 32,
     116, 104, 101, 10, 112, 114, 101, 101, 100, 105, 116, 46, 10, 10, 84,
     104, 101, 32, 99, 117, 114, 115, 111, 114, 32, 112, 111, 115, 105, 116,
     105, 111, 110, 115, 32, 109, 97, 121, 32, 98, 101, 32, 105, 110, 97, 99,
     99, 117, 114, 97, 116, 101, 44, 32, 101, 115, 112, 101, 99, 105, 97, 108,
     108, 121, 32, 105, 110, 32, 112, 114, 101, 115, 101, 110, 99, 101, 32,
     111, 102, 32, 122, 101, 114, 111, 45, 119, 105, 100, 116, 104, 10, 99,
     104, 97, 114, 97, 99, 116, 101, 114, 115, 32, 111, 114, 32, 110, 111,
     110, 45, 109, 111, 110, 111, 115, 112, 97, 99, 101, 100, 32, 102, 111,
     110, 116, 115, 46, 10, 0];
static mut pending: text_input_state =
    {
        let mut init =
            text_input_state{commit:
                                 0 as *const libc::c_char as
                                     *mut libc::c_char,
                             preedit:
                                 C2RustUnnamed_1{text:
                                                     0 as *const libc::c_char
                                                         as *mut libc::c_char,
                                                 cursor_begin: 0,
                                                 cursor_end: 0,},
                             delete_surrounding:
                                 C2RustUnnamed_0{after_length: 0,
                                                 before_length: 0,},};
        init
    };
static mut current: text_input_state =
    {
        let mut init =
            text_input_state{commit:
                                 0 as *const libc::c_char as
                                     *mut libc::c_char,
                             preedit:
                                 C2RustUnnamed_1{text:
                                                     0 as *const libc::c_char
                                                         as *mut libc::c_char,
                                                 cursor_begin: 0,
                                                 cursor_end: 0,},
                             delete_surrounding:
                                 C2RustUnnamed_0{after_length: 0,
                                                 before_length: 0,},};
        init
    };
static mut entered: bool = 0i32 != 0;
static mut serial: uint32_t = 0;
static mut buffer: *mut libc::c_char =
    0 as *const libc::c_char as *mut libc::c_char;
// text buffer
// cursor is not present, there's no way to move it outside of preedit
static mut sleeptime: libc::c_int = 0i32;
static mut width: libc::c_int = 100i32;
static mut height: libc::c_int = 200i32;
static mut enabled: libc::c_int = 0i32;
static mut display: *mut wl_display =
    0 as *const wl_display as *mut wl_display;
static mut compositor: *mut wl_compositor =
    0 as *const wl_compositor as *mut wl_compositor;
static mut seat: *mut wl_seat = 0 as *const wl_seat as *mut wl_seat;
static mut wm_base: *mut xdg_wm_base =
    0 as *const xdg_wm_base as *mut xdg_wm_base;
static mut text_input_manager: *mut zwp_text_input_manager_v3 =
    0 as *const zwp_text_input_manager_v3 as *mut zwp_text_input_manager_v3;
static mut text_input: *mut zwp_text_input_v3 =
    0 as *const zwp_text_input_v3 as *mut zwp_text_input_v3;
#[no_mangle]
pub static mut egl: wlr_egl =
    wlr_egl{platform: 0,
            display: 0 as *const libc::c_void as *mut libc::c_void,
            config: 0 as *const libc::c_void as *mut libc::c_void,
            context: 0 as *const libc::c_void as *mut libc::c_void,
            exts_str: 0 as *const libc::c_char,
            exts:
                C2RustUnnamed{bind_wayland_display_wl: false,
                              buffer_age_ext: false,
                              image_base_khr: false,
                              image_dma_buf_export_mesa: false,
                              image_dmabuf_import_ext: false,
                              image_dmabuf_import_modifiers_ext: false,
                              swap_buffers_with_damage_ext: false,
                              swap_buffers_with_damage_khr: false,},
            wl_display: 0 as *const wl_display as *mut wl_display,
            dmabuf_formats:
                wlr_drm_format_set{len: 0,
                                   cap: 0,
                                   formats:
                                       0 as *const *mut wlr_drm_format as
                                           *mut *mut wlr_drm_format,},};
#[no_mangle]
pub static mut egl_window: *mut wl_egl_window =
    0 as *const wl_egl_window as *mut wl_egl_window;
#[no_mangle]
pub static mut egl_surface: *mut wlr_egl_surface =
    0 as *const wlr_egl_surface as *mut wlr_egl_surface;
unsafe extern "C" fn draw() {
    eglMakeCurrent(egl.display, egl_surface as EGLSurface,
                   egl_surface as EGLSurface, egl.context);
    let mut color: [libc::c_float; 4] =
        [1.0f64 as libc::c_float, 1.0f64 as libc::c_float,
         0.0f64 as libc::c_float, 1.0f64 as libc::c_float];
    color[0] = (enabled as libc::c_double * 1.0f64) as libc::c_float;
    color[1] =
        (entered as libc::c_int as libc::c_double * 1.0f64) as libc::c_float;
    glViewport(0i32, 0i32, width, height);
    glClearColor(color[0], color[1], color[2], 1.0f64 as GLfloat);
    glClear(0x4000i32 as GLbitfield);
    eglSwapBuffers(egl.display, egl_surface as EGLSurface);
}
unsafe extern "C" fn utf8_strlen(mut str: *mut libc::c_char) -> size_t {
    let mut cp_count: size_t = 0i32 as size_t;
    while *str as libc::c_int != '\u{0}' as i32 {
        if *str as libc::c_int & 0xc0i32 != 0x80i32 {
            cp_count = cp_count.wrapping_add(1)
        }
        str = str.offset(1)
    }
    return cp_count;
}
unsafe extern "C" fn utf8_offset(mut utf8_str: *mut libc::c_char,
                                 mut byte_offset: size_t) -> size_t {
    let mut cp_count: size_t = 0i32 as size_t;
    let mut c: *mut libc::c_char = utf8_str;
    while c < utf8_str.offset(byte_offset as isize) {
        if *c as libc::c_int & 0xc0i32 != 0x80i32 {
            cp_count = cp_count.wrapping_add(1)
        }
        c = c.offset(1)
    }
    return cp_count;
}
// TODO: would be nicer to have this text display inside the window
unsafe extern "C" fn show_status() {
    let mut current_block: u64;
    printf(b"State %d:\x00" as *const u8 as *const libc::c_char, serial);
    if enabled == 0 {
        printf(b" disabled\x00" as *const u8 as *const libc::c_char);
    }
    let mut preedit_text: *mut libc::c_char = current.preedit.text;
    if preedit_text.is_null() {
        preedit_text = strdup(b"\x00" as *const u8 as *const libc::c_char)
    }
    printf(b"\n\x00" as *const u8 as *const libc::c_char);
    printf(b"%s\x00" as *const u8 as *const libc::c_char, buffer);
    printf(b"%s\n\x00" as *const u8 as *const libc::c_char, preedit_text);
    // Positioning of the cursor requires UTF8 offsets to match monospaced
	// glyphs
    let mut i: libc::c_uint = 0i32 as libc::c_uint;
    while (i as libc::c_ulong) < utf8_strlen(buffer) {
        printf(b" \x00" as *const u8 as *const libc::c_char);
        i = i.wrapping_add(1)
    }
    let mut cursor_mark: *mut libc::c_char =
        calloc(utf8_strlen(preedit_text).wrapping_add(2i32 as libc::c_ulong),
               ::std::mem::size_of::<libc::c_char>() as libc::c_ulong) as
            *mut libc::c_char;
    let mut i_0: libc::c_uint = 0i32 as libc::c_uint;
    while (i_0 as libc::c_ulong) < utf8_strlen(preedit_text) {
        *cursor_mark.offset(i_0 as isize) = '.' as i32 as libc::c_char;
        i_0 = i_0.wrapping_add(1)
    }
    if !(current.preedit.cursor_begin == -1i32 &&
             current.preedit.cursor_end == -1i32) {
        if current.preedit.cursor_begin == -1i32 ||
               current.preedit.cursor_end == -1i32 {
            printf(b"Only one cursor side is defined: %d to %d\n\x00" as
                       *const u8 as *const libc::c_char,
                   current.preedit.cursor_begin, current.preedit.cursor_end);
        } else if current.preedit.cursor_begin as libc::c_uint as
                      libc::c_ulong > strlen(preedit_text) {
            printf(b"Cursor out of bounds\n\x00" as *const u8 as
                       *const libc::c_char);
        } else {
            if current.preedit.cursor_begin == current.preedit.cursor_end {
                *cursor_mark.offset(utf8_offset(preedit_text,
                                                current.preedit.cursor_begin
                                                    as size_t) as isize) =
                    '|' as i32 as libc::c_char;
                current_block = 10271104688625216027;
            } else if current.preedit.cursor_begin >
                          current.preedit.cursor_end {
                printf(b"End cursor is before start cursor\n\x00" as *const u8
                           as *const libc::c_char);
                current_block = 11815176118680486756;
            } else {
                // negative offsets already checked before
                let mut i_1: libc::c_uint =
                    utf8_offset(preedit_text,
                                current.preedit.cursor_begin as size_t) as
                        libc::c_uint;
                while (i_1 as libc::c_ulong) <
                          utf8_offset(preedit_text,
                                      current.preedit.cursor_end as size_t) {
                    *cursor_mark.offset(i_1 as isize) =
                        '_' as i32 as libc::c_char;
                    i_1 = i_1.wrapping_add(1)
                }
                current_block = 10271104688625216027;
            }
            match current_block {
                11815176118680486756 => { }
                _ => {
                    printf(b"%s\n\x00" as *const u8 as *const libc::c_char,
                           cursor_mark);
                }
            }
        }
    }
    free(cursor_mark as *mut libc::c_void);
}
unsafe extern "C" fn commit(mut text_input_0: *mut zwp_text_input_v3) {
    zwp_text_input_v3_commit(text_input_0);
    serial = serial.wrapping_add(1);
}
unsafe extern "C" fn send_status_update(mut text_input_0:
                                            *mut zwp_text_input_v3) {
    zwp_text_input_v3_set_surrounding_text(text_input_0, buffer,
                                           strlen(buffer) as int32_t,
                                           strlen(buffer) as int32_t);
    zwp_text_input_v3_set_text_change_cause(text_input_0,
                                            ZWP_TEXT_INPUT_V3_CHANGE_CAUSE_INPUT_METHOD
                                                as libc::c_int as uint32_t);
    commit(text_input_0);
}
unsafe extern "C" fn text_input_handle_enter(mut data: *mut libc::c_void,
                                             mut zwp_text_input_v3:
                                                 *mut zwp_text_input_v3,
                                             mut surface: *mut wl_surface) {
    entered = 1i32 != 0;
    zwp_text_input_v3_enable(zwp_text_input_v3);
    commit(zwp_text_input_v3);
    enabled = 1i32;
    draw();
    show_status();
}
unsafe extern "C" fn text_input_handle_leave(mut data: *mut libc::c_void,
                                             mut zwp_text_input_v3:
                                                 *mut zwp_text_input_v3,
                                             mut surface: *mut wl_surface) {
    entered = 0i32 != 0;
    draw();
    wl_display_roundtrip(display);
    sleep(sleeptime as libc::c_uint);
    zwp_text_input_v3_disable(zwp_text_input_v3);
    commit(zwp_text_input_v3);
    enabled = 0i32;
    draw();
    show_status();
}
unsafe extern "C" fn text_input_commit_string(mut data: *mut libc::c_void,
                                              mut zwp_text_input_v3:
                                                  *mut zwp_text_input_v3,
                                              mut text: *const libc::c_char) {
    free(pending.commit as *mut libc::c_void);
    pending.commit = strdup(text);
}
unsafe extern "C" fn text_input_delete_surrounding_text(mut data:
                                                            *mut libc::c_void,
                                                        mut zwp_text_input_v3:
                                                            *mut zwp_text_input_v3,
                                                        mut before_length:
                                                            uint32_t,
                                                        mut after_length:
                                                            uint32_t) {
    pending.delete_surrounding.before_length = before_length;
    pending.delete_surrounding.after_length = after_length;
}
unsafe extern "C" fn text_input_preedit_string(mut data: *mut libc::c_void,
                                               mut zwp_text_input_v3:
                                                   *mut zwp_text_input_v3,
                                               mut text: *const libc::c_char,
                                               mut cursor_begin: int32_t,
                                               mut cursor_end: int32_t) {
    free(pending.preedit.text as *mut libc::c_void);
    pending.preedit.text = strdup(text);
    pending.preedit.cursor_begin = cursor_begin;
    pending.preedit.cursor_end = cursor_end;
}
unsafe extern "C" fn text_input_handle_done(mut data: *mut libc::c_void,
                                            mut zwp_text_input_v3:
                                                *mut zwp_text_input_v3,
                                            mut incoming_serial: uint32_t) {
    if serial != incoming_serial {
        fprintf(stderr,
                b"Received serial %d while expecting %d\n\x00" as *const u8 as
                    *const libc::c_char, incoming_serial, serial);
        return
    }
    free(current.preedit.text as *mut libc::c_void);
    free(current.commit as *mut libc::c_void);
    current = pending;
    let mut empty: text_input_state =
        {
            let mut init =
                text_input_state{commit: 0 as *mut libc::c_char,
                                 preedit:
                                     C2RustUnnamed_1{text:
                                                         0 as
                                                             *const libc::c_char
                                                             as
                                                             *mut libc::c_char,
                                                     cursor_begin: 0,
                                                     cursor_end: 0,},
                                 delete_surrounding:
                                     C2RustUnnamed_0{after_length: 0,
                                                     before_length: 0,},};
            init
        };
    pending = empty;
    if current.delete_surrounding.after_length.wrapping_add(current.delete_surrounding.before_length)
           > 0i32 as libc::c_uint {
        // cursor is always after committed text, after_length != 0 will never happen
        let mut delete_before: libc::c_uint =
            current.delete_surrounding.before_length; // realloc may fail anyway
        if delete_before as libc::c_ulong > strlen(buffer) {
            delete_before = strlen(buffer) as libc::c_uint
        }
        *buffer.offset(strlen(buffer).wrapping_sub(delete_before as
                                                       libc::c_ulong) as
                           isize) = '\u{0}' as i32 as libc::c_char
    }
    let mut commit_string: *mut libc::c_char = current.commit;
    if commit_string.is_null() {
        commit_string = strdup(b"\x00" as *const u8 as *const libc::c_char)
    }
    let mut old_buffer: *mut libc::c_char = buffer;
    buffer =
        calloc(strlen(buffer).wrapping_add(strlen(commit_string)).wrapping_add(1i32
                                                                                   as
                                                                                   libc::c_ulong),
               ::std::mem::size_of::<libc::c_char>() as libc::c_ulong) as
            *mut libc::c_char;
    strcpy(buffer, old_buffer);
    free(old_buffer as *mut libc::c_void);
    strcat(buffer, commit_string);
    send_status_update(zwp_text_input_v3);
    show_status();
}
static mut text_input_listener: zwp_text_input_v3_listener =
    unsafe {
        {
            let mut init =
                zwp_text_input_v3_listener{enter:
                                               Some(text_input_handle_enter as
                                                        unsafe extern "C" fn(_:
                                                                                 *mut libc::c_void,
                                                                             _:
                                                                                 *mut zwp_text_input_v3,
                                                                             _:
                                                                                 *mut wl_surface)
                                                            -> ()),
                                           leave:
                                               Some(text_input_handle_leave as
                                                        unsafe extern "C" fn(_:
                                                                                 *mut libc::c_void,
                                                                             _:
                                                                                 *mut zwp_text_input_v3,
                                                                             _:
                                                                                 *mut wl_surface)
                                                            -> ()),
                                           preedit_string:
                                               Some(text_input_preedit_string
                                                        as
                                                        unsafe extern "C" fn(_:
                                                                                 *mut libc::c_void,
                                                                             _:
                                                                                 *mut zwp_text_input_v3,
                                                                             _:
                                                                                 *const libc::c_char,
                                                                             _:
                                                                                 int32_t,
                                                                             _:
                                                                                 int32_t)
                                                            -> ()),
                                           commit_string:
                                               Some(text_input_commit_string
                                                        as
                                                        unsafe extern "C" fn(_:
                                                                                 *mut libc::c_void,
                                                                             _:
                                                                                 *mut zwp_text_input_v3,
                                                                             _:
                                                                                 *const libc::c_char)
                                                            -> ()),
                                           delete_surrounding_text:
                                               Some(text_input_delete_surrounding_text
                                                        as
                                                        unsafe extern "C" fn(_:
                                                                                 *mut libc::c_void,
                                                                             _:
                                                                                 *mut zwp_text_input_v3,
                                                                             _:
                                                                                 uint32_t,
                                                                             _:
                                                                                 uint32_t)
                                                            -> ()),
                                           done:
                                               Some(text_input_handle_done as
                                                        unsafe extern "C" fn(_:
                                                                                 *mut libc::c_void,
                                                                             _:
                                                                                 *mut zwp_text_input_v3,
                                                                             _:
                                                                                 uint32_t)
                                                            -> ()),};
            init
        }
    };
unsafe extern "C" fn xdg_surface_handle_configure(mut data: *mut libc::c_void,
                                                  mut xdg_surface:
                                                      *mut xdg_surface,
                                                  mut serial_0: uint32_t) {
    xdg_surface_ack_configure(xdg_surface, serial_0);
    wl_egl_window_resize(egl_window, width, height, 0i32, 0i32);
    draw();
}
static mut xdg_surface_listener: xdg_surface_listener =
    unsafe {
        {
            let mut init =
                xdg_surface_listener{configure:
                                         Some(xdg_surface_handle_configure as
                                                  unsafe extern "C" fn(_:
                                                                           *mut libc::c_void,
                                                                       _:
                                                                           *mut xdg_surface,
                                                                       _:
                                                                           uint32_t)
                                                      -> ()),};
            init
        }
    };
unsafe extern "C" fn xdg_toplevel_handle_configure(mut data:
                                                       *mut libc::c_void,
                                                   mut xdg_toplevel:
                                                       *mut xdg_toplevel,
                                                   mut w: int32_t,
                                                   mut h: int32_t,
                                                   mut states:
                                                       *mut wl_array) {
    width = w;
    height = h;
}
unsafe extern "C" fn xdg_toplevel_handle_close(mut data: *mut libc::c_void,
                                               mut xdg_toplevel:
                                                   *mut xdg_toplevel) {
    exit(0i32);
}
static mut xdg_toplevel_listener: xdg_toplevel_listener =
    unsafe {
        {
            let mut init =
                xdg_toplevel_listener{configure:
                                          Some(xdg_toplevel_handle_configure
                                                   as
                                                   unsafe extern "C" fn(_:
                                                                            *mut libc::c_void,
                                                                        _:
                                                                            *mut xdg_toplevel,
                                                                        _:
                                                                            int32_t,
                                                                        _:
                                                                            int32_t,
                                                                        _:
                                                                            *mut wl_array)
                                                       -> ()),
                                      close:
                                          Some(xdg_toplevel_handle_close as
                                                   unsafe extern "C" fn(_:
                                                                            *mut libc::c_void,
                                                                        _:
                                                                            *mut xdg_toplevel)
                                                       -> ()),};
            init
        }
    };
unsafe extern "C" fn handle_global(mut data: *mut libc::c_void,
                                   mut registry: *mut wl_registry,
                                   mut name: uint32_t,
                                   mut interface: *const libc::c_char,
                                   mut version: uint32_t) {
    if strcmp(interface,
              b"wl_compositor\x00" as *const u8 as *const libc::c_char) ==
           0i32 {
        compositor =
            wl_registry_bind(registry, name, &wl_compositor_interface,
                             1i32 as uint32_t) as *mut wl_compositor
    } else if strcmp(interface, xdg_wm_base_interface.name) == 0i32 {
        wm_base =
            wl_registry_bind(registry, name, &xdg_wm_base_interface,
                             1i32 as uint32_t) as *mut xdg_wm_base
    } else if strcmp(interface, zwp_text_input_manager_v3_interface.name) ==
                  0i32 {
        text_input_manager =
            wl_registry_bind(registry, name,
                             &zwp_text_input_manager_v3_interface,
                             1i32 as uint32_t) as
                *mut zwp_text_input_manager_v3
    } else if strcmp(interface, wl_seat_interface.name) == 0i32 {
        seat =
            wl_registry_bind(registry, name, &wl_seat_interface, version) as
                *mut wl_seat
    };
}
unsafe extern "C" fn handle_global_remove(mut data: *mut libc::c_void,
                                          mut registry: *mut wl_registry,
                                          mut name: uint32_t) {
    // who cares
}
static mut registry_listener: wl_registry_listener =
    unsafe {
        {
            let mut init =
                wl_registry_listener{global:
                                         Some(handle_global as
                                                  unsafe extern "C" fn(_:
                                                                           *mut libc::c_void,
                                                                       _:
                                                                           *mut wl_registry,
                                                                       _:
                                                                           uint32_t,
                                                                       _:
                                                                           *const libc::c_char,
                                                                       _:
                                                                           uint32_t)
                                                      -> ()),
                                     global_remove:
                                         Some(handle_global_remove as
                                                  unsafe extern "C" fn(_:
                                                                           *mut libc::c_void,
                                                                       _:
                                                                           *mut wl_registry,
                                                                       _:
                                                                           uint32_t)
                                                      -> ()),};
            init
        }
    };
unsafe fn main_0(mut argc: libc::c_int, mut argv: *mut *mut libc::c_char)
 -> libc::c_int {
    if argc > 1i32 {
        if strcmp(*argv.offset(1),
                  b"--help\x00" as *const u8 as *const libc::c_char) == 0i32
               ||
               strcmp(*argv.offset(1),
                      b"-h\x00" as *const u8 as *const libc::c_char) == 0i32 {
            printf(usage.as_ptr());
            return 0i32
        }
        sleeptime = atoi(*argv.offset(1));
        if argc > 3i32 {
            width = atoi(*argv.offset(2));
            height = atoi(*argv.offset(3))
        }
    }
    buffer =
        calloc(1i32 as libc::c_ulong,
               ::std::mem::size_of::<libc::c_char>() as libc::c_ulong) as
            *mut libc::c_char;
    display = wl_display_connect(0 as *const libc::c_char);
    if display.is_null() {
        fprintf(stderr,
                b"Failed to create display\n\x00" as *const u8 as
                    *const libc::c_char);
        return 1i32
    }
    let mut registry: *mut wl_registry = wl_display_get_registry(display);
    wl_registry_add_listener(registry, &registry_listener,
                             0 as *mut libc::c_void);
    wl_display_dispatch(display);
    wl_display_roundtrip(display);
    if compositor.is_null() {
        fprintf(stderr,
                b"wl-compositor not available\n\x00" as *const u8 as
                    *const libc::c_char);
        return 1i32
    }
    if wm_base.is_null() {
        fprintf(stderr,
                b"xdg-shell not available\n\x00" as *const u8 as
                    *const libc::c_char);
        return 1i32
    }
    if text_input_manager.is_null() {
        fprintf(stderr,
                b"text-input not available\n\x00" as *const u8 as
                    *const libc::c_char);
        return 1i32
    }
    text_input =
        zwp_text_input_manager_v3_get_text_input(text_input_manager, seat);
    zwp_text_input_v3_add_listener(text_input, &text_input_listener,
                                   0 as *mut libc::c_void);
    wlr_egl_init(&mut egl, 0x31d8i32 as EGLenum, display as *mut libc::c_void,
                 0 as *mut EGLint, WL_SHM_FORMAT_ARGB8888 as libc::c_int);
    let mut surface: *mut wl_surface =
        wl_compositor_create_surface(compositor);
    let mut xdg_surface: *mut xdg_surface =
        xdg_wm_base_get_xdg_surface(wm_base, surface);
    let mut xdg_toplevel: *mut xdg_toplevel =
        xdg_surface_get_toplevel(xdg_surface);
    xdg_surface_add_listener(xdg_surface, &xdg_surface_listener,
                             0 as *mut libc::c_void);
    xdg_toplevel_add_listener(xdg_toplevel, &xdg_toplevel_listener,
                              0 as *mut libc::c_void);
    wl_surface_commit(surface);
    egl_window = wl_egl_window_create(surface, width, height);
    egl_surface =
        wlr_egl_create_surface(&mut egl, egl_window as *mut libc::c_void) as
            *mut wlr_egl_surface;
    wl_display_roundtrip(display);
    draw();
    // This space intentionally left blank
    while wl_display_dispatch(display) != -1i32 { }
    return 0i32;
}
#[main]
pub fn main() {
    let mut args: Vec<*mut libc::c_char> = Vec::new();
    for arg in ::std::env::args() {
        args.push(::std::ffi::CString::new(arg).expect("Failed to convert argument into CString.").into_raw());
    };
    args.push(::std::ptr::null_mut());
    unsafe {
        ::std::process::exit(main_0((args.len() - 1) as libc::c_int,
                                    args.as_mut_ptr() as
                                        *mut *mut libc::c_char) as i32)
    }
}
