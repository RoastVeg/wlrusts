use libc;
extern "C" {
    pub type _IO_wide_data;
    pub type _IO_codecvt;
    pub type _IO_marker;
    pub type wl_proxy;
    pub type wl_display;
    pub type wl_registry;
    pub type wl_seat;
    /* Generated by wayland-scanner 1.17.0 */
    /* *
 * @page page_idle The idle protocol
 * @section page_ifaces_idle Interfaces
 * - @subpage page_iface_org_kde_kwin_idle - User idle time manager
 * - @subpage page_iface_org_kde_kwin_idle_timeout - 
 * @section page_copyright_idle Copyright
 * <pre>
 *
 * Copyright (C) 2015 Martin Gräßlin
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 2.1 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 * </pre>
 */
    pub type org_kde_kwin_idle;
    pub type org_kde_kwin_idle_timeout;
    #[no_mangle]
    static mut optarg: *mut libc::c_char;
    #[no_mangle]
    fn getopt(___argc: libc::c_int, ___argv: *const *mut libc::c_char,
              __shortopts: *const libc::c_char) -> libc::c_int;
    #[no_mangle]
    fn pthread_create(__newthread: *mut pthread_t,
                      __attr: *const pthread_attr_t,
                      __start_routine:
                          Option<unsafe extern "C" fn(_: *mut libc::c_void)
                                     -> *mut libc::c_void>,
                      __arg: *mut libc::c_void) -> libc::c_int;
    #[no_mangle]
    fn pthread_join(__th: pthread_t, __thread_return: *mut *mut libc::c_void)
     -> libc::c_int;
    #[no_mangle]
    fn pthread_cancel(__th: pthread_t) -> libc::c_int;
    #[no_mangle]
    static mut stdout: *mut FILE;
    #[no_mangle]
    static mut stderr: *mut FILE;
    #[no_mangle]
    fn fprintf(_: *mut FILE, _: *const libc::c_char, _: ...) -> libc::c_int;
    #[no_mangle]
    fn printf(_: *const libc::c_char, _: ...) -> libc::c_int;
    #[no_mangle]
    fn strtoul(_: *const libc::c_char, _: *mut *mut libc::c_char,
               _: libc::c_int) -> libc::c_ulong;
    #[no_mangle]
    fn free(__ptr: *mut libc::c_void);
    #[no_mangle]
    fn strcmp(_: *const libc::c_char, _: *const libc::c_char) -> libc::c_int;
    #[no_mangle]
    fn sleep(__seconds: libc::c_uint) -> libc::c_uint;
    #[no_mangle]
    fn wl_proxy_marshal(p: *mut wl_proxy, opcode: uint32_t, _: ...);
    #[no_mangle]
    fn wl_proxy_marshal_constructor(proxy: *mut wl_proxy, opcode: uint32_t,
                                    interface: *const wl_interface, _: ...)
     -> *mut wl_proxy;
    #[no_mangle]
    fn wl_proxy_marshal_constructor_versioned(proxy: *mut wl_proxy,
                                              opcode: uint32_t,
                                              interface: *const wl_interface,
                                              version: uint32_t, _: ...)
     -> *mut wl_proxy;
    #[no_mangle]
    fn wl_proxy_destroy(proxy: *mut wl_proxy);
    #[no_mangle]
    fn wl_proxy_add_listener(proxy: *mut wl_proxy,
                             implementation:
                                 *mut Option<unsafe extern "C" fn() -> ()>,
                             data: *mut libc::c_void) -> libc::c_int;
    #[no_mangle]
    fn wl_display_connect(name: *const libc::c_char) -> *mut wl_display;
    #[no_mangle]
    fn wl_display_disconnect(display: *mut wl_display);
    #[no_mangle]
    fn wl_display_dispatch(display: *mut wl_display) -> libc::c_int;
    #[no_mangle]
    fn wl_display_roundtrip(display: *mut wl_display) -> libc::c_int;
    #[no_mangle]
    static wl_registry_interface: wl_interface;
    #[no_mangle]
    static wl_seat_interface: wl_interface;
    /* *
 * @page page_iface_org_kde_kwin_idle org_kde_kwin_idle
 * @section page_iface_org_kde_kwin_idle_desc Description
 *
 * This interface allows to monitor user idle time on a given seat. The interface
 * allows to register timers which trigger after no user activity was registered
 * on the seat for a given interval. It notifies when user activity resumes.
 *
 * This is useful for applications wanting to perform actions when the user is not
 * interacting with the system, e.g. chat applications setting the user as away, power
 * management features to dim screen, etc..
 * @section page_iface_org_kde_kwin_idle_api API
 * See @ref iface_org_kde_kwin_idle.
 */
/* *
 * @defgroup iface_org_kde_kwin_idle The org_kde_kwin_idle interface
 *
 * This interface allows to monitor user idle time on a given seat. The interface
 * allows to register timers which trigger after no user activity was registered
 * on the seat for a given interval. It notifies when user activity resumes.
 *
 * This is useful for applications wanting to perform actions when the user is not
 * interacting with the system, e.g. chat applications setting the user as away, power
 * management features to dim screen, etc..
 */
    #[no_mangle]
    static org_kde_kwin_idle_interface: wl_interface;
    /* *
 * @page page_iface_org_kde_kwin_idle_timeout org_kde_kwin_idle_timeout
 * @section page_iface_org_kde_kwin_idle_timeout_api API
 * See @ref iface_org_kde_kwin_idle_timeout.
 */
/* *
 * @defgroup iface_org_kde_kwin_idle_timeout The org_kde_kwin_idle_timeout interface
 */
    #[no_mangle]
    static org_kde_kwin_idle_timeout_interface: wl_interface;
}
pub type __uint32_t = libc::c_uint;
pub type __off_t = libc::c_long;
pub type __off64_t = libc::c_long;
pub type size_t = libc::c_ulong;
pub type pthread_t = libc::c_ulong;
#[derive ( Copy, Clone )]
#[repr ( C )]
pub union pthread_attr_t {
    pub __size: [libc::c_char; 56],
    pub __align: libc::c_long,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct _IO_FILE {
    pub _flags: libc::c_int,
    pub _IO_read_ptr: *mut libc::c_char,
    pub _IO_read_end: *mut libc::c_char,
    pub _IO_read_base: *mut libc::c_char,
    pub _IO_write_base: *mut libc::c_char,
    pub _IO_write_ptr: *mut libc::c_char,
    pub _IO_write_end: *mut libc::c_char,
    pub _IO_buf_base: *mut libc::c_char,
    pub _IO_buf_end: *mut libc::c_char,
    pub _IO_save_base: *mut libc::c_char,
    pub _IO_backup_base: *mut libc::c_char,
    pub _IO_save_end: *mut libc::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: libc::c_int,
    pub _flags2: libc::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: libc::c_ushort,
    pub _vtable_offset: libc::c_schar,
    pub _shortbuf: [libc::c_char; 1],
    pub _lock: *mut libc::c_void,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut libc::c_void,
    pub __pad5: size_t,
    pub _mode: libc::c_int,
    pub _unused2: [libc::c_char; 20],
}
pub type _IO_lock_t = ();
pub type FILE = _IO_FILE;
pub type uint32_t = __uint32_t;
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wl_message {
    pub name: *const libc::c_char,
    pub signature: *const libc::c_char,
    pub types: *mut *const wl_interface,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wl_interface {
    pub name: *const libc::c_char,
    pub version: libc::c_int,
    pub method_count: libc::c_int,
    pub methods: *const wl_message,
    pub event_count: libc::c_int,
    pub events: *const wl_message,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wl_registry_listener {
    pub global: Option<unsafe extern "C" fn(_: *mut libc::c_void,
                                            _: *mut wl_registry, _: uint32_t,
                                            _: *const libc::c_char,
                                            _: uint32_t) -> ()>,
    pub global_remove: Option<unsafe extern "C" fn(_: *mut libc::c_void,
                                                   _: *mut wl_registry,
                                                   _: uint32_t) -> ()>,
}
/* *
 * @ingroup iface_org_kde_kwin_idle_timeout
 * @struct org_kde_kwin_idle_timeout_listener
 */
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct org_kde_kwin_idle_timeout_listener {
    pub idle: Option<unsafe extern "C" fn(_: *mut libc::c_void,
                                          _: *mut org_kde_kwin_idle_timeout)
                         -> ()>,
    pub resumed: Option<unsafe extern "C" fn(_: *mut libc::c_void,
                                             _:
                                                 *mut org_kde_kwin_idle_timeout)
                            -> ()>,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct thread_args {
    pub display: *mut wl_display,
    pub timer: *mut org_kde_kwin_idle_timeout,
}
#[inline]
unsafe extern "C" fn wl_display_get_registry(mut wl_display: *mut wl_display)
 -> *mut wl_registry {
    let mut registry: *mut wl_proxy = 0 as *mut wl_proxy;
    registry =
        wl_proxy_marshal_constructor(wl_display as *mut wl_proxy,
                                     1i32 as uint32_t,
                                     &wl_registry_interface as
                                         *const wl_interface,
                                     0 as *mut libc::c_void);
    return registry as *mut wl_registry;
}
#[inline]
unsafe extern "C" fn wl_registry_add_listener(mut wl_registry:
                                                  *mut wl_registry,
                                              mut listener:
                                                  *const wl_registry_listener,
                                              mut data: *mut libc::c_void)
 -> libc::c_int {
    return wl_proxy_add_listener(wl_registry as *mut wl_proxy,
                                 listener as
                                     *mut Option<unsafe extern "C" fn()
                                                     -> ()>, data);
}
#[inline]
unsafe extern "C" fn wl_registry_bind(mut wl_registry: *mut wl_registry,
                                      mut name: uint32_t,
                                      mut interface: *const wl_interface,
                                      mut version: uint32_t)
 -> *mut libc::c_void {
    let mut id: *mut wl_proxy = 0 as *mut wl_proxy;
    id =
        wl_proxy_marshal_constructor_versioned(wl_registry as *mut wl_proxy,
                                               0i32 as uint32_t, interface,
                                               version, name,
                                               (*interface).name, version,
                                               0 as *mut libc::c_void);
    return id as *mut libc::c_void;
}
/* *
 * @ingroup iface_org_kde_kwin_idle
 */
#[inline]
unsafe extern "C" fn org_kde_kwin_idle_get_idle_timeout(mut org_kde_kwin_idle:
                                                            *mut org_kde_kwin_idle,
                                                        mut seat_0:
                                                            *mut wl_seat,
                                                        mut timeout_0:
                                                            uint32_t)
 -> *mut org_kde_kwin_idle_timeout {
    let mut id: *mut wl_proxy = 0 as *mut wl_proxy;
    id =
        wl_proxy_marshal_constructor(org_kde_kwin_idle as *mut wl_proxy,
                                     0i32 as uint32_t,
                                     &org_kde_kwin_idle_timeout_interface as
                                         *const wl_interface,
                                     0 as *mut libc::c_void, seat_0,
                                     timeout_0);
    return id as *mut org_kde_kwin_idle_timeout;
}
/* *
 * @ingroup iface_org_kde_kwin_idle_timeout
 */
#[inline]
unsafe extern "C" fn org_kde_kwin_idle_timeout_add_listener(mut org_kde_kwin_idle_timeout:
                                                                *mut org_kde_kwin_idle_timeout,
                                                            mut listener:
                                                                *const org_kde_kwin_idle_timeout_listener,
                                                            mut data:
                                                                *mut libc::c_void)
 -> libc::c_int {
    return wl_proxy_add_listener(org_kde_kwin_idle_timeout as *mut wl_proxy,
                                 listener as
                                     *mut Option<unsafe extern "C" fn()
                                                     -> ()>, data);
}
/* *
 * @ingroup iface_org_kde_kwin_idle_timeout
 */
#[inline]
unsafe extern "C" fn org_kde_kwin_idle_timeout_release(mut org_kde_kwin_idle_timeout:
                                                           *mut org_kde_kwin_idle_timeout) {
    wl_proxy_marshal(org_kde_kwin_idle_timeout as *mut wl_proxy,
                     0i32 as uint32_t);
    wl_proxy_destroy(org_kde_kwin_idle_timeout as *mut wl_proxy);
}
/* *
 * @ingroup iface_org_kde_kwin_idle_timeout
 */
#[inline]
unsafe extern "C" fn org_kde_kwin_idle_timeout_simulate_user_activity(mut org_kde_kwin_idle_timeout:
                                                                          *mut org_kde_kwin_idle_timeout) {
    wl_proxy_marshal(org_kde_kwin_idle_timeout as *mut wl_proxy,
                     1i32 as uint32_t);
}
static mut idle_manager: *mut org_kde_kwin_idle =
    0 as *const org_kde_kwin_idle as *mut org_kde_kwin_idle;
static mut seat: *mut wl_seat = 0 as *const wl_seat as *mut wl_seat;
static mut timeout: uint32_t = 0i32 as uint32_t;
static mut simulate_activity_timeout: uint32_t = 0i32 as uint32_t;
static mut close_timeout: uint32_t = 0i32 as uint32_t;
static mut run: libc::c_int = 1i32;
unsafe extern "C" fn handle_global(mut data: *mut libc::c_void,
                                   mut registry: *mut wl_registry,
                                   mut name: uint32_t,
                                   mut interface: *const libc::c_char,
                                   mut version: uint32_t) {
    fprintf(stdout,
            b"interfaces found: %s\n\x00" as *const u8 as *const libc::c_char,
            interface);
    if strcmp(interface,
              b"org_kde_kwin_idle\x00" as *const u8 as *const libc::c_char) ==
           0i32 {
        idle_manager =
            wl_registry_bind(registry, name, &org_kde_kwin_idle_interface,
                             1i32 as uint32_t) as *mut org_kde_kwin_idle
    } else if strcmp(interface,
                     b"wl_seat\x00" as *const u8 as *const libc::c_char) ==
                  0i32 {
        seat =
            wl_registry_bind(registry, name, &wl_seat_interface,
                             1i32 as uint32_t) as *mut wl_seat
    };
}
unsafe extern "C" fn handle_global_remove(mut data: *mut libc::c_void,
                                          mut registry: *mut wl_registry,
                                          mut name: uint32_t) {
    //TODO
}
static mut registry_listener: wl_registry_listener =
    unsafe {
        {
            let mut init =
                wl_registry_listener{global:
                                         Some(handle_global as
                                                  unsafe extern "C" fn(_:
                                                                           *mut libc::c_void,
                                                                       _:
                                                                           *mut wl_registry,
                                                                       _:
                                                                           uint32_t,
                                                                       _:
                                                                           *const libc::c_char,
                                                                       _:
                                                                           uint32_t)
                                                      -> ()),
                                     global_remove:
                                         Some(handle_global_remove as
                                                  unsafe extern "C" fn(_:
                                                                           *mut libc::c_void,
                                                                       _:
                                                                           *mut wl_registry,
                                                                       _:
                                                                           uint32_t)
                                                      -> ()),};
            init
        }
    };
unsafe extern "C" fn handle_idle(mut data: *mut libc::c_void,
                                 mut timer: *mut org_kde_kwin_idle_timeout) {
    fprintf(stdout, b"idle state\n\x00" as *const u8 as *const libc::c_char);
}
unsafe extern "C" fn handle_resume(mut data: *mut libc::c_void,
                                   mut timer:
                                       *mut org_kde_kwin_idle_timeout) {
    fprintf(stdout,
            b"active state\n\x00" as *const u8 as *const libc::c_char);
}
static mut idle_timer_listener: org_kde_kwin_idle_timeout_listener =
    unsafe {
        {
            let mut init =
                org_kde_kwin_idle_timeout_listener{idle:
                                                       Some(handle_idle as
                                                                unsafe extern "C" fn(_:
                                                                                         *mut libc::c_void,
                                                                                     _:
                                                                                         *mut org_kde_kwin_idle_timeout)
                                                                    -> ()),
                                                   resumed:
                                                       Some(handle_resume as
                                                                unsafe extern "C" fn(_:
                                                                                         *mut libc::c_void,
                                                                                     _:
                                                                                         *mut org_kde_kwin_idle_timeout)
                                                                    -> ()),};
            init
        }
    };
unsafe extern "C" fn parse_args(mut argc: libc::c_int,
                                mut argv: *mut *mut libc::c_char)
 -> libc::c_int {
    let mut c: libc::c_int = 0;
    loop  {
        c =
            getopt(argc, argv as *const *mut libc::c_char,
                   b"c:hs:t:\x00" as *const u8 as *const libc::c_char);
        if !(c != -1i32) { break ; }
        match c {
            99 => {
                close_timeout =
                    strtoul(optarg, 0 as *mut *mut libc::c_char, 10i32) as
                        uint32_t
            }
            115 => {
                simulate_activity_timeout =
                    strtoul(optarg, 0 as *mut *mut libc::c_char, 10i32) as
                        uint32_t
            }
            116 => {
                timeout =
                    strtoul(optarg, 0 as *mut *mut libc::c_char, 10i32) as
                        uint32_t
            }
            104 | 63 => {
                printf(b"Usage: %s [OPTIONS]\n\x00" as *const u8 as
                           *const libc::c_char, *argv.offset(0));
                printf(b"  -t seconds\t\t\tidle timeout in seconds\n\x00" as
                           *const u8 as *const libc::c_char);
                printf(b"  -s seconds optional\t\tsimulate user activity after x seconds\n\x00"
                           as *const u8 as *const libc::c_char);
                printf(b"  -c seconds optional\t\tclose program after x seconds\n\x00"
                           as *const u8 as *const libc::c_char);
                printf(b"  -h\t\t\t\tthis help menu\n\x00" as *const u8 as
                           *const libc::c_char);
                return 1i32
            }
            _ => { return 1i32 }
        }
    }
    return 0i32;
}
unsafe extern "C" fn simulate_activity(mut data: *mut libc::c_void)
 -> *mut libc::c_void {
    sleep(simulate_activity_timeout);
    fprintf(stdout,
            b"simulate user activity\n\x00" as *const u8 as
                *const libc::c_char);
    let mut arg: *mut thread_args = data as *mut thread_args;
    org_kde_kwin_idle_timeout_simulate_user_activity((*arg).timer);
    wl_display_roundtrip((*arg).display);
    return 0 as *mut libc::c_void;
}
unsafe extern "C" fn close_program(mut data: *mut libc::c_void)
 -> *mut libc::c_void {
    sleep(close_timeout);
    let mut arg: *mut thread_args = data as *mut thread_args;
    org_kde_kwin_idle_timeout_release((*arg).timer);
    wl_display_roundtrip((*arg).display);
    fprintf(stdout,
            b"close program\n\x00" as *const u8 as *const libc::c_char);
    run = 0i32;
    return 0 as *mut libc::c_void;
}
unsafe extern "C" fn main_loop(mut data: *mut libc::c_void)
 -> *mut libc::c_void {
    let mut display: *mut wl_display = data as *mut wl_display;
    while wl_display_dispatch(display) != -1i32 { }
    return 0 as *mut libc::c_void;
}
unsafe fn main_0(mut argc: libc::c_int, mut argv: *mut *mut libc::c_char)
 -> libc::c_int {
    if parse_args(argc, argv) != 0i32 { return -1i32 }
    if timeout == 0i32 as libc::c_uint {
        printf(b"idle timeout 0 is invalid\n\x00" as *const u8 as
                   *const libc::c_char);
        return -1i32
    }
    let mut display: *mut wl_display =
        wl_display_connect(0 as *const libc::c_char);
    if display.is_null() {
        fprintf(stderr,
                b"failed to create display\n\x00" as *const u8 as
                    *const libc::c_char);
        return -1i32
    }
    let mut registry: *mut wl_registry = wl_display_get_registry(display);
    wl_registry_add_listener(registry, &registry_listener,
                             0 as *mut libc::c_void);
    wl_display_dispatch(display);
    wl_display_roundtrip(display);
    free(registry as *mut libc::c_void);
    if idle_manager.is_null() {
        fprintf(stderr,
                b"display doesn\'t support idle protocol\n\x00" as *const u8
                    as *const libc::c_char);
        return -1i32
    }
    if seat.is_null() {
        fprintf(stderr,
                b"seat error\n\x00" as *const u8 as *const libc::c_char);
        return -1i32
    }
    let mut timer: *mut org_kde_kwin_idle_timeout =
        org_kde_kwin_idle_get_idle_timeout(idle_manager, seat,
                                           timeout.wrapping_mul(1000i32 as
                                                                    libc::c_uint));
    if timer.is_null() {
        fprintf(stderr,
                b"Could not create idle_timeout\n\x00" as *const u8 as
                    *const libc::c_char);
        return -1i32
    }
    let mut t1: pthread_t = 0;
    let mut t2: pthread_t = 0;
    let mut t3: pthread_t = 0;
    let mut arg: thread_args =
        { let mut init = thread_args{display: display, timer: timer,}; init };
    let mut create_t1: bool =
        simulate_activity_timeout != 0i32 as libc::c_uint &&
            simulate_activity_timeout < close_timeout;
    if create_t1 {
        if pthread_create(&mut t1, 0 as *const pthread_attr_t,
                          Some(simulate_activity as
                                   unsafe extern "C" fn(_: *mut libc::c_void)
                                       -> *mut libc::c_void),
                          &mut arg as *mut thread_args as *mut libc::c_void)
               != 0i32 {
            return -1i32
        }
    }
    let mut create_t2: bool = close_timeout != 0i32 as libc::c_uint;
    if create_t2 {
        if pthread_create(&mut t2, 0 as *const pthread_attr_t,
                          Some(close_program as
                                   unsafe extern "C" fn(_: *mut libc::c_void)
                                       -> *mut libc::c_void),
                          &mut arg as *mut thread_args as *mut libc::c_void)
               != 0i32 {
            if create_t1 { pthread_cancel(t1); }
            return -1i32
        }
    }
    org_kde_kwin_idle_timeout_add_listener(timer, &idle_timer_listener,
                                           timer as *mut libc::c_void);
    fprintf(stdout, b"waiting\n\x00" as *const u8 as *const libc::c_char);
    if pthread_create(&mut t3, 0 as *const pthread_attr_t,
                      Some(main_loop as
                               unsafe extern "C" fn(_: *mut libc::c_void)
                                   -> *mut libc::c_void),
                      display as *mut libc::c_void) != 0i32 {
        if create_t1 { pthread_cancel(t1); }
        if create_t2 { pthread_cancel(t2); }
        return -1i32
    }
    if create_t1 { pthread_join(t1, 0 as *mut *mut libc::c_void); }
    if create_t2 { pthread_join(t2, 0 as *mut *mut libc::c_void); }
    pthread_cancel(t3);
    wl_display_disconnect(display);
    return 0i32;
}
#[main]
pub fn main() {
    let mut args: Vec<*mut libc::c_char> = Vec::new();
    for arg in ::std::env::args() {
        args.push(::std::ffi::CString::new(arg).expect("Failed to convert argument into CString.").into_raw());
    };
    args.push(::std::ptr::null_mut());
    unsafe {
        ::std::process::exit(main_0((args.len() - 1) as libc::c_int,
                                    args.as_mut_ptr() as
                                        *mut *mut libc::c_char) as i32)
    }
}
