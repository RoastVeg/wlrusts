use libc;
extern "C" {
    pub type wl_event_source;
    pub type wl_display;
    /* Generated by wayland-scanner 1.17.0 */
    pub type wl_client;
    pub type wl_global;
    pub type wlr_texture;
    pub type wlr_surface;
    pub type wlr_backend;
    pub type wlr_output_impl;
    #[no_mangle]
    fn __assert_fail(__assertion: *const libc::c_char,
                     __file: *const libc::c_char, __line: libc::c_uint,
                     __function: *const libc::c_char) -> !;
    #[no_mangle]
    fn snprintf(_: *mut libc::c_char, _: libc::c_ulong,
                _: *const libc::c_char, _: ...) -> libc::c_int;
    #[no_mangle]
    fn calloc(_: libc::c_ulong, _: libc::c_ulong) -> *mut libc::c_void;
    #[no_mangle]
    fn free(__ptr: *mut libc::c_void);
    #[no_mangle]
    fn wl_list_init(list: *mut wl_list);
    #[no_mangle]
    fn wl_list_insert(list: *mut wl_list, elm: *mut wl_list);
    #[no_mangle]
    fn wl_list_remove(elm: *mut wl_list);
    #[no_mangle]
    fn wl_list_empty(list: *const wl_list) -> libc::c_int;
    #[no_mangle]
    fn wl_display_next_serial(display: *mut wl_display) -> uint32_t;
    #[no_mangle]
    fn wl_display_add_destroy_listener(display: *mut wl_display,
                                       listener: *mut wl_listener);
    #[no_mangle]
    fn wl_global_create(display: *mut wl_display,
                        interface: *const wl_interface, version: libc::c_int,
                        data: *mut libc::c_void, bind: wl_global_bind_func_t)
     -> *mut wl_global;
    #[no_mangle]
    fn wl_global_destroy(global: *mut wl_global);
    #[no_mangle]
    fn wl_client_post_no_memory(client: *mut wl_client);
    #[no_mangle]
    fn wl_resource_post_event(resource: *mut wl_resource, opcode: uint32_t,
                              _: ...);
    #[no_mangle]
    fn wl_resource_post_error(resource: *mut wl_resource, code: uint32_t,
                              msg: *const libc::c_char, _: ...);
    #[no_mangle]
    fn wl_resource_post_no_memory(resource: *mut wl_resource);
    #[no_mangle]
    fn wl_resource_create(client: *mut wl_client,
                          interface: *const wl_interface,
                          version: libc::c_int, id: uint32_t)
     -> *mut wl_resource;
    #[no_mangle]
    fn wl_resource_set_implementation(resource: *mut wl_resource,
                                      implementation: *const libc::c_void,
                                      data: *mut libc::c_void,
                                      destroy: wl_resource_destroy_func_t);
    #[no_mangle]
    fn wl_resource_destroy(resource: *mut wl_resource);
    #[no_mangle]
    fn wl_resource_get_link(resource: *mut wl_resource) -> *mut wl_list;
    #[no_mangle]
    fn wl_resource_from_link(resource: *mut wl_list) -> *mut wl_resource;
    #[no_mangle]
    fn wl_resource_get_client(resource: *mut wl_resource) -> *mut wl_client;
    #[no_mangle]
    fn wl_resource_set_user_data(resource: *mut wl_resource,
                                 data: *mut libc::c_void);
    #[no_mangle]
    fn wl_resource_get_user_data(resource: *mut wl_resource)
     -> *mut libc::c_void;
    #[no_mangle]
    fn wl_resource_get_version(resource: *mut wl_resource) -> libc::c_int;
    #[no_mangle]
    fn wl_resource_instance_of(resource: *mut wl_resource,
                               interface: *const wl_interface,
                               implementation: *const libc::c_void)
     -> libc::c_int;
    #[no_mangle]
    fn _wlr_log(verbosity: wlr_log_importance, format: *const libc::c_char,
                _: ...);
    #[no_mangle]
    fn __errno_location() -> *mut libc::c_int;
    #[no_mangle]
    fn strerror(_: libc::c_int) -> *mut libc::c_char;
    #[no_mangle]
    fn wlr_signal_emit_safe(signal: *mut wl_signal, data: *mut libc::c_void);
    /* *
 * @page page_iface_zwlr_output_manager_v1 zwlr_output_manager_v1
 * @section page_iface_zwlr_output_manager_v1_desc Description
 *
 * This interface is a manager that allows reading and writing the current
 * output device configuration.
 *
 * Output devices that display pixels (e.g. a physical monitor or a virtual
 * output in a window) are represented as heads. Heads cannot be created nor
 * destroyed by the client, but they can be enabled or disabled and their
 * properties can be changed. Each head may have one or more available modes.
 *
 * Whenever a head appears (e.g. a monitor is plugged in), it will be
 * advertised via the head event. Immediately after the output manager is
 * bound, all current heads are advertised.
 *
 * Whenever a head's properties change, the relevant wlr_output_head events
 * will be sent. Not all head properties will be sent: only properties that
 * have changed need to.
 *
 * Whenever a head disappears (e.g. a monitor is unplugged), a
 * wlr_output_head.finished event will be sent.
 *
 * After one or more heads appear, change or disappear, the done event will
 * be sent. It carries a serial which can be used in a create_configuration
 * request to update heads properties.
 *
 * The information obtained from this protocol should only be used for output
 * configuration purposes. This protocol is not designed to be a generic
 * output property advertisement protocol for regular clients. Instead,
 * protocols such as xdg-output should be used.
 * @section page_iface_zwlr_output_manager_v1_api API
 * See @ref iface_zwlr_output_manager_v1.
 */
/* *
 * @defgroup iface_zwlr_output_manager_v1 The zwlr_output_manager_v1 interface
 *
 * This interface is a manager that allows reading and writing the current
 * output device configuration.
 *
 * Output devices that display pixels (e.g. a physical monitor or a virtual
 * output in a window) are represented as heads. Heads cannot be created nor
 * destroyed by the client, but they can be enabled or disabled and their
 * properties can be changed. Each head may have one or more available modes.
 *
 * Whenever a head appears (e.g. a monitor is plugged in), it will be
 * advertised via the head event. Immediately after the output manager is
 * bound, all current heads are advertised.
 *
 * Whenever a head's properties change, the relevant wlr_output_head events
 * will be sent. Not all head properties will be sent: only properties that
 * have changed need to.
 *
 * Whenever a head disappears (e.g. a monitor is unplugged), a
 * wlr_output_head.finished event will be sent.
 *
 * After one or more heads appear, change or disappear, the done event will
 * be sent. It carries a serial which can be used in a create_configuration
 * request to update heads properties.
 *
 * The information obtained from this protocol should only be used for output
 * configuration purposes. This protocol is not designed to be a generic
 * output property advertisement protocol for regular clients. Instead,
 * protocols such as xdg-output should be used.
 */
    #[no_mangle]
    static zwlr_output_manager_v1_interface: wl_interface;
    /* *
 * @page page_iface_zwlr_output_head_v1 zwlr_output_head_v1
 * @section page_iface_zwlr_output_head_v1_desc Description
 *
 * A head is an output device. The difference between a wl_output object and
 * a head is that heads are advertised even if they are turned off. A head
 * object only advertises properties and cannot be used directly to change
 * them.
 *
 * A head has some read-only properties: modes, name, description and
 * physical_size. These cannot be changed by clients.
 *
 * Other properties can be updated via a wlr_output_configuration object.
 *
 * Properties sent via this interface are applied atomically via the
 * wlr_output_manager.done event. No guarantees are made regarding the order
 * in which properties are sent.
 * @section page_iface_zwlr_output_head_v1_api API
 * See @ref iface_zwlr_output_head_v1.
 */
/* *
 * @defgroup iface_zwlr_output_head_v1 The zwlr_output_head_v1 interface
 *
 * A head is an output device. The difference between a wl_output object and
 * a head is that heads are advertised even if they are turned off. A head
 * object only advertises properties and cannot be used directly to change
 * them.
 *
 * A head has some read-only properties: modes, name, description and
 * physical_size. These cannot be changed by clients.
 *
 * Other properties can be updated via a wlr_output_configuration object.
 *
 * Properties sent via this interface are applied atomically via the
 * wlr_output_manager.done event. No guarantees are made regarding the order
 * in which properties are sent.
 */
    #[no_mangle]
    static zwlr_output_head_v1_interface: wl_interface;
    /* *
 * @page page_iface_zwlr_output_mode_v1 zwlr_output_mode_v1
 * @section page_iface_zwlr_output_mode_v1_desc Description
 *
 * This object describes an output mode.
 *
 * Some heads don't support output modes, in which case modes won't be
 * advertised.
 *
 * Properties sent via this interface are applied atomically via the
 * wlr_output_manager.done event. No guarantees are made regarding the order
 * in which properties are sent.
 * @section page_iface_zwlr_output_mode_v1_api API
 * See @ref iface_zwlr_output_mode_v1.
 */
/* *
 * @defgroup iface_zwlr_output_mode_v1 The zwlr_output_mode_v1 interface
 *
 * This object describes an output mode.
 *
 * Some heads don't support output modes, in which case modes won't be
 * advertised.
 *
 * Properties sent via this interface are applied atomically via the
 * wlr_output_manager.done event. No guarantees are made regarding the order
 * in which properties are sent.
 */
    #[no_mangle]
    static zwlr_output_mode_v1_interface: wl_interface;
    /* *
 * @page page_iface_zwlr_output_configuration_v1 zwlr_output_configuration_v1
 * @section page_iface_zwlr_output_configuration_v1_desc Description
 *
 * This object is used by the client to describe a full output configuration.
 *
 * First, the client needs to setup the output configuration. Each head can
 * be either enabled (and configured) or disabled. It is a protocol error to
 * send two enable_head or disable_head requests with the same head. It is a
 * protocol error to omit a head in a configuration.
 *
 * Then, the client can apply or test the configuration. The compositor will
 * then reply with a succeeded, failed or cancelled event. Finally the client
 * should destroy the configuration object.
 * @section page_iface_zwlr_output_configuration_v1_api API
 * See @ref iface_zwlr_output_configuration_v1.
 */
/* *
 * @defgroup iface_zwlr_output_configuration_v1 The zwlr_output_configuration_v1 interface
 *
 * This object is used by the client to describe a full output configuration.
 *
 * First, the client needs to setup the output configuration. Each head can
 * be either enabled (and configured) or disabled. It is a protocol error to
 * send two enable_head or disable_head requests with the same head. It is a
 * protocol error to omit a head in a configuration.
 *
 * Then, the client can apply or test the configuration. The compositor will
 * then reply with a succeeded, failed or cancelled event. Finally the client
 * should destroy the configuration object.
 */
    #[no_mangle]
    static zwlr_output_configuration_v1_interface: wl_interface;
    /* *
 * @page page_iface_zwlr_output_configuration_head_v1 zwlr_output_configuration_head_v1
 * @section page_iface_zwlr_output_configuration_head_v1_desc Description
 *
 * This object is used by the client to update a single head's configuration.
 *
 * It is a protocol error to set the same property twice.
 * @section page_iface_zwlr_output_configuration_head_v1_api API
 * See @ref iface_zwlr_output_configuration_head_v1.
 */
/* *
 * @defgroup iface_zwlr_output_configuration_head_v1 The zwlr_output_configuration_head_v1 interface
 *
 * This object is used by the client to update a single head's configuration.
 *
 * It is a protocol error to set the same property twice.
 */
    #[no_mangle]
    static zwlr_output_configuration_head_v1_interface: wl_interface;
}
pub type size_t = libc::c_ulong;
pub type __int32_t = libc::c_int;
pub type __uint32_t = libc::c_uint;
pub type __int64_t = libc::c_long;
pub type int32_t = __int32_t;
pub type int64_t = __int64_t;
pub type uint32_t = __uint32_t;
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wl_object {
    pub interface: *const wl_interface,
    pub implementation: *const libc::c_void,
    pub id: uint32_t,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wl_interface {
    pub name: *const libc::c_char,
    pub version: libc::c_int,
    pub method_count: libc::c_int,
    pub methods: *const wl_message,
    pub event_count: libc::c_int,
    pub events: *const wl_message,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wl_message {
    pub name: *const libc::c_char,
    pub signature: *const libc::c_char,
    pub types: *mut *const wl_interface,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wl_list {
    pub prev: *mut wl_list,
    pub next: *mut wl_list,
}
pub type wl_fixed_t = int32_t;
#[derive ( Copy, Clone )]
#[repr ( C )]
pub union C2RustUnnamed {
    pub d: libc::c_double,
    pub i: int64_t,
}
#[derive ( Copy, Clone )]
#[repr ( C )]
pub union C2RustUnnamed_0 {
    pub d: libc::c_double,
    pub i: int64_t,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wl_listener {
    pub link: wl_list,
    pub notify: wl_notify_func_t,
}
pub type wl_notify_func_t
    =
    Option<unsafe extern "C" fn(_: *mut wl_listener, _: *mut libc::c_void)
               -> ()>;
pub type wl_global_bind_func_t
    =
    Option<unsafe extern "C" fn(_: *mut wl_client, _: *mut libc::c_void,
                                _: uint32_t, _: uint32_t) -> ()>;
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wl_resource {
    pub object: wl_object,
    pub destroy: wl_resource_destroy_func_t,
    pub link: wl_list,
    pub destroy_signal: wl_signal,
    pub client: *mut wl_client,
    pub data: *mut libc::c_void,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wl_signal {
    pub listener_list: wl_list,
}
pub type wl_resource_destroy_func_t
    =
    Option<unsafe extern "C" fn(_: *mut wl_resource) -> ()>;
/*
 * 32 bit regions
 */
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct pixman_region32_data {
    pub size: libc::c_long,
    pub numRects: libc::c_long,
}
pub type pixman_region32_data_t = pixman_region32_data;
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct pixman_box32 {
    pub x1: int32_t,
    pub y1: int32_t,
    pub x2: int32_t,
    pub y2: int32_t,
}
pub type pixman_box32_t = pixman_box32;
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct pixman_region32 {
    pub extents: pixman_box32_t,
    pub data: *mut pixman_region32_data_t,
}
pub type pixman_region32_t = pixman_region32;
pub type wl_output_subpixel = libc::c_uint;
pub const WL_OUTPUT_SUBPIXEL_VERTICAL_BGR: wl_output_subpixel = 5;
pub const WL_OUTPUT_SUBPIXEL_VERTICAL_RGB: wl_output_subpixel = 4;
pub const WL_OUTPUT_SUBPIXEL_HORIZONTAL_BGR: wl_output_subpixel = 3;
pub const WL_OUTPUT_SUBPIXEL_HORIZONTAL_RGB: wl_output_subpixel = 2;
pub const WL_OUTPUT_SUBPIXEL_NONE: wl_output_subpixel = 1;
pub const WL_OUTPUT_SUBPIXEL_UNKNOWN: wl_output_subpixel = 0;
pub type wl_output_transform = libc::c_uint;
pub const WL_OUTPUT_TRANSFORM_FLIPPED_270: wl_output_transform = 7;
pub const WL_OUTPUT_TRANSFORM_FLIPPED_180: wl_output_transform = 6;
pub const WL_OUTPUT_TRANSFORM_FLIPPED_90: wl_output_transform = 5;
pub const WL_OUTPUT_TRANSFORM_FLIPPED: wl_output_transform = 4;
pub const WL_OUTPUT_TRANSFORM_270: wl_output_transform = 3;
pub const WL_OUTPUT_TRANSFORM_180: wl_output_transform = 2;
pub const WL_OUTPUT_TRANSFORM_90: wl_output_transform = 1;
pub const WL_OUTPUT_TRANSFORM_NORMAL: wl_output_transform = 0;
/*
 * This an unstable interface of wlroots. No guarantees are made regarding the
 * future consistency of this API.
 */
/* *
 * A client buffer.
 */
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wlr_buffer {
    pub resource: *mut wl_resource,
    pub texture: *mut wlr_texture,
    pub released: bool,
    pub n_refs: size_t,
    pub resource_destroy: wl_listener,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wlr_output_mode {
    pub width: int32_t,
    pub height: int32_t,
    pub refresh: int32_t,
    pub preferred: bool,
    pub link: wl_list,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wlr_output_cursor {
    pub output: *mut wlr_output,
    pub x: libc::c_double,
    pub y: libc::c_double,
    pub enabled: bool,
    pub visible: bool,
    pub width: uint32_t,
    pub height: uint32_t,
    pub hotspot_x: int32_t,
    pub hotspot_y: int32_t,
    pub link: wl_list,
    pub texture: *mut wlr_texture,
    pub surface: *mut wlr_surface,
    pub surface_commit: wl_listener,
    pub surface_destroy: wl_listener,
    pub events: C2RustUnnamed_1,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct C2RustUnnamed_1 {
    pub destroy: wl_signal,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wlr_output {
    pub impl_0: *const wlr_output_impl,
    pub backend: *mut wlr_backend,
    pub display: *mut wl_display,
    pub global: *mut wl_global,
    pub resources: wl_list,
    pub name: [libc::c_char; 24],
    pub make: [libc::c_char; 56],
    pub model: [libc::c_char; 16],
    pub serial: [libc::c_char; 16],
    pub phys_width: int32_t,
    pub phys_height: int32_t,
    pub modes: wl_list,
    pub current_mode: *mut wlr_output_mode,
    pub width: int32_t,
    pub height: int32_t,
    pub refresh: int32_t,
    pub enabled: bool,
    pub scale: libc::c_float,
    pub subpixel: wl_output_subpixel,
    pub transform: wl_output_transform,
    pub needs_frame: bool,
    pub damage: pixman_region32_t,
    pub frame_pending: bool,
    pub transform_matrix: [libc::c_float; 9],
    pub pending: wlr_output_state,
    pub commit_seq: uint32_t,
    pub events: C2RustUnnamed_2,
    pub idle_frame: *mut wl_event_source,
    pub idle_done: *mut wl_event_source,
    pub attach_render_locks: libc::c_int,
    pub cursors: wl_list,
    pub hardware_cursor: *mut wlr_output_cursor,
    pub software_cursor_locks: libc::c_int,
    pub display_destroy: wl_listener,
    pub data: *mut libc::c_void,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct C2RustUnnamed_2 {
    pub frame: wl_signal,
    pub needs_frame: wl_signal,
    pub precommit: wl_signal,
    pub commit: wl_signal,
    pub present: wl_signal,
    pub enable: wl_signal,
    pub mode: wl_signal,
    pub scale: wl_signal,
    pub transform: wl_signal,
    pub destroy: wl_signal,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wlr_output_state {
    pub committed: uint32_t,
    pub damage: pixman_region32_t,
    pub buffer_type: wlr_output_state_buffer_type,
    pub buffer: *mut wlr_buffer,
}
pub type wlr_output_state_buffer_type = libc::c_uint;
pub const WLR_OUTPUT_STATE_BUFFER_SCANOUT: wlr_output_state_buffer_type = 1;
pub const WLR_OUTPUT_STATE_BUFFER_RENDER: wlr_output_state_buffer_type = 0;
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wlr_output_manager_v1 {
    pub display: *mut wl_display,
    pub global: *mut wl_global,
    pub resources: wl_list,
    pub heads: wl_list,
    pub serial: uint32_t,
    pub events: C2RustUnnamed_3,
    pub display_destroy: wl_listener,
    pub data: *mut libc::c_void,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct C2RustUnnamed_3 {
    pub apply: wl_signal,
    pub test: wl_signal,
    pub destroy: wl_signal,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wlr_output_head_v1_state {
    pub output: *mut wlr_output,
    pub enabled: bool,
    pub mode: *mut wlr_output_mode,
    pub custom_mode: C2RustUnnamed_4,
    pub x: int32_t,
    pub y: int32_t,
    pub transform: wl_output_transform,
    pub scale: libc::c_double,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct C2RustUnnamed_4 {
    pub width: libc::c_int,
    pub height: libc::c_int,
    pub refresh: libc::c_int,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wlr_output_head_v1 {
    pub state: wlr_output_head_v1_state,
    pub manager: *mut wlr_output_manager_v1,
    pub link: wl_list,
    pub resources: wl_list,
    pub mode_resources: wl_list,
    pub output_destroy: wl_listener,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wlr_output_configuration_v1 {
    pub heads: wl_list,
    pub manager: *mut wlr_output_manager_v1,
    pub serial: uint32_t,
    pub finalized: bool,
    pub finished: bool,
    pub resource: *mut wl_resource,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wlr_output_configuration_head_v1 {
    pub state: wlr_output_head_v1_state,
    pub config: *mut wlr_output_configuration_v1,
    pub link: wl_list,
    pub resource: *mut wl_resource,
    pub output_destroy: wl_listener,
}
pub const HEAD_STATE_SCALE: C2RustUnnamed_5 = 16;
pub const HEAD_STATE_TRANSFORM: C2RustUnnamed_5 = 8;
pub const HEAD_STATE_POSITION: C2RustUnnamed_5 = 4;
pub const HEAD_STATE_MODE: C2RustUnnamed_5 = 2;
pub const HEAD_STATE_ENABLED: C2RustUnnamed_5 = 1;
/* *
 * @ingroup iface_zwlr_output_manager_v1
 * @struct zwlr_output_manager_v1_interface
 */
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct zwlr_output_manager_v1_interface {
    pub create_configuration: Option<unsafe extern "C" fn(_: *mut wl_client,
                                                          _: *mut wl_resource,
                                                          _: uint32_t,
                                                          _: uint32_t) -> ()>,
    pub stop: Option<unsafe extern "C" fn(_: *mut wl_client,
                                          _: *mut wl_resource) -> ()>,
}
/* ZWLR_OUTPUT_CONFIGURATION_V1_ERROR_ENUM */
/* *
 * @ingroup iface_zwlr_output_configuration_v1
 * @struct zwlr_output_configuration_v1_interface
 */
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct zwlr_output_configuration_v1_interface {
    pub enable_head: Option<unsafe extern "C" fn(_: *mut wl_client,
                                                 _: *mut wl_resource,
                                                 _: uint32_t,
                                                 _: *mut wl_resource) -> ()>,
    pub disable_head: Option<unsafe extern "C" fn(_: *mut wl_client,
                                                  _: *mut wl_resource,
                                                  _: *mut wl_resource) -> ()>,
    pub apply: Option<unsafe extern "C" fn(_: *mut wl_client,
                                           _: *mut wl_resource) -> ()>,
    pub test: Option<unsafe extern "C" fn(_: *mut wl_client,
                                          _: *mut wl_resource) -> ()>,
    pub destroy: Option<unsafe extern "C" fn(_: *mut wl_client,
                                             _: *mut wl_resource) -> ()>,
}
pub type wlr_log_importance = libc::c_uint;
pub const WLR_LOG_IMPORTANCE_LAST: wlr_log_importance = 4;
pub const WLR_DEBUG: wlr_log_importance = 3;
pub const WLR_INFO: wlr_log_importance = 2;
pub const WLR_ERROR: wlr_log_importance = 1;
pub const WLR_SILENT: wlr_log_importance = 0;
/* *
	 * request sent after configuration has been applied or tested
	 */
pub const ZWLR_OUTPUT_CONFIGURATION_V1_ERROR_ALREADY_USED:
          zwlr_output_configuration_v1_error =
    3;
/* *
	 * head has been configured twice
	 */
pub const ZWLR_OUTPUT_CONFIGURATION_V1_ERROR_ALREADY_CONFIGURED_HEAD:
          zwlr_output_configuration_v1_error =
    1;
/* ZWLR_OUTPUT_CONFIGURATION_HEAD_V1_ERROR_ENUM */
/* *
 * @ingroup iface_zwlr_output_configuration_head_v1
 * @struct zwlr_output_configuration_head_v1_interface
 */
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct zwlr_output_configuration_head_v1_interface {
    pub set_mode: Option<unsafe extern "C" fn(_: *mut wl_client,
                                              _: *mut wl_resource,
                                              _: *mut wl_resource) -> ()>,
    pub set_custom_mode: Option<unsafe extern "C" fn(_: *mut wl_client,
                                                     _: *mut wl_resource,
                                                     _: int32_t, _: int32_t,
                                                     _: int32_t) -> ()>,
    pub set_position: Option<unsafe extern "C" fn(_: *mut wl_client,
                                                  _: *mut wl_resource,
                                                  _: int32_t, _: int32_t)
                                 -> ()>,
    pub set_transform: Option<unsafe extern "C" fn(_: *mut wl_client,
                                                   _: *mut wl_resource,
                                                   _: int32_t) -> ()>,
    pub set_scale: Option<unsafe extern "C" fn(_: *mut wl_client,
                                               _: *mut wl_resource,
                                               _: wl_fixed_t) -> ()>,
}
/* *
	 * scale negative or zero
	 */
pub const ZWLR_OUTPUT_CONFIGURATION_HEAD_V1_ERROR_INVALID_SCALE:
          zwlr_output_configuration_head_v1_error =
    5;
/* *
	 * transform value outside enum
	 */
pub const ZWLR_OUTPUT_CONFIGURATION_HEAD_V1_ERROR_INVALID_TRANSFORM:
          zwlr_output_configuration_head_v1_error =
    4;
/* *
	 * mode is invalid
	 */
pub const ZWLR_OUTPUT_CONFIGURATION_HEAD_V1_ERROR_INVALID_CUSTOM_MODE:
          zwlr_output_configuration_head_v1_error =
    3;
/* *
	 * mode doesn't belong to head
	 */
pub const ZWLR_OUTPUT_CONFIGURATION_HEAD_V1_ERROR_INVALID_MODE:
          zwlr_output_configuration_head_v1_error =
    2;
pub type zwlr_output_configuration_v1_error = libc::c_uint;
/* *
	 * head has not been configured
	 */
pub const ZWLR_OUTPUT_CONFIGURATION_V1_ERROR_UNCONFIGURED_HEAD:
          zwlr_output_configuration_v1_error =
    2;
pub type zwlr_output_configuration_head_v1_error = libc::c_uint;
/* *
	 * property has already been set
	 */
pub const ZWLR_OUTPUT_CONFIGURATION_HEAD_V1_ERROR_ALREADY_SET:
          zwlr_output_configuration_head_v1_error =
    1;
pub type C2RustUnnamed_5 = libc::c_uint;
#[inline]
unsafe extern "C" fn wl_fixed_to_double(mut f: wl_fixed_t) -> libc::c_double {
    let mut u: C2RustUnnamed = C2RustUnnamed{d: 0.,};
    u.i =
        ((1023i64 + 44i64 << 52i32) + (1i64 << 51i32) + f as libc::c_longlong)
            as int64_t;
    return u.d - (3i64 << 43i32) as libc::c_double;
}
#[inline]
unsafe extern "C" fn wl_fixed_from_double(mut d: libc::c_double)
 -> wl_fixed_t {
    let mut u: C2RustUnnamed_0 = C2RustUnnamed_0{d: 0.,};
    u.d = d + (3i64 << 51i32 - 8i32) as libc::c_double;
    return u.i as wl_fixed_t;
}
#[inline]
unsafe extern "C" fn wl_signal_init(mut signal: *mut wl_signal) {
    wl_list_init(&mut (*signal).listener_list);
}
#[inline]
unsafe extern "C" fn wl_signal_add(mut signal: *mut wl_signal,
                                   mut listener: *mut wl_listener) {
    wl_list_insert((*signal).listener_list.prev, &mut (*listener).link);
}
/* *
 * @ingroup iface_zwlr_output_manager_v1
 */
/* *
 * @ingroup iface_zwlr_output_manager_v1
 */
/* *
 * @ingroup iface_zwlr_output_manager_v1
 */
/* *
 * @ingroup iface_zwlr_output_manager_v1
 */
/* *
 * @ingroup iface_zwlr_output_manager_v1
 */
/* *
 * @ingroup iface_zwlr_output_manager_v1
 * Sends an head event to the client owning the resource.
 * @param resource_ The client's resource
 */
#[inline]
unsafe extern "C" fn zwlr_output_manager_v1_send_head(mut resource_:
                                                          *mut wl_resource,
                                                      mut head:
                                                          *mut wl_resource) {
    wl_resource_post_event(resource_, 0i32 as uint32_t, head);
}
/* *
 * @ingroup iface_zwlr_output_manager_v1
 * Sends an done event to the client owning the resource.
 * @param resource_ The client's resource
 * @param serial current configuration serial
 */
#[inline]
unsafe extern "C" fn zwlr_output_manager_v1_send_done(mut resource_:
                                                          *mut wl_resource,
                                                      mut serial: uint32_t) {
    wl_resource_post_event(resource_, 1i32 as uint32_t, serial);
}
/* *
 * @ingroup iface_zwlr_output_manager_v1
 * Sends an finished event to the client owning the resource.
 * @param resource_ The client's resource
 */
#[inline]
unsafe extern "C" fn zwlr_output_manager_v1_send_finished(mut resource_:
                                                              *mut wl_resource) {
    wl_resource_post_event(resource_, 2i32 as uint32_t);
}
/* *
 * @ingroup iface_zwlr_output_head_v1
 */
/* *
 * @ingroup iface_zwlr_output_head_v1
 */
/* *
 * @ingroup iface_zwlr_output_head_v1
 */
/* *
 * @ingroup iface_zwlr_output_head_v1
 */
/* *
 * @ingroup iface_zwlr_output_head_v1
 */
/* *
 * @ingroup iface_zwlr_output_head_v1
 */
/* *
 * @ingroup iface_zwlr_output_head_v1
 */
/* *
 * @ingroup iface_zwlr_output_head_v1
 */
/* *
 * @ingroup iface_zwlr_output_head_v1
 */
/* *
 * @ingroup iface_zwlr_output_head_v1
 */
/* *
 * @ingroup iface_zwlr_output_head_v1
 * Sends an name event to the client owning the resource.
 * @param resource_ The client's resource
 */
#[inline]
unsafe extern "C" fn zwlr_output_head_v1_send_name(mut resource_:
                                                       *mut wl_resource,
                                                   mut name:
                                                       *const libc::c_char) {
    wl_resource_post_event(resource_, 0i32 as uint32_t, name);
}
/* *
 * @ingroup iface_zwlr_output_head_v1
 * Sends an description event to the client owning the resource.
 * @param resource_ The client's resource
 */
#[inline]
unsafe extern "C" fn zwlr_output_head_v1_send_description(mut resource_:
                                                              *mut wl_resource,
                                                          mut description:
                                                              *const libc::c_char) {
    wl_resource_post_event(resource_, 1i32 as uint32_t, description);
}
/* *
 * @ingroup iface_zwlr_output_head_v1
 * Sends an physical_size event to the client owning the resource.
 * @param resource_ The client's resource
 * @param width width in millimeters of the output
 * @param height height in millimeters of the output
 */
#[inline]
unsafe extern "C" fn zwlr_output_head_v1_send_physical_size(mut resource_:
                                                                *mut wl_resource,
                                                            mut width:
                                                                int32_t,
                                                            mut height:
                                                                int32_t) {
    wl_resource_post_event(resource_, 2i32 as uint32_t, width, height);
}
/* *
 * @ingroup iface_zwlr_output_head_v1
 * Sends an mode event to the client owning the resource.
 * @param resource_ The client's resource
 */
#[inline]
unsafe extern "C" fn zwlr_output_head_v1_send_mode(mut resource_:
                                                       *mut wl_resource,
                                                   mut mode:
                                                       *mut wl_resource) {
    wl_resource_post_event(resource_, 3i32 as uint32_t, mode);
}
/* *
 * @ingroup iface_zwlr_output_head_v1
 * Sends an enabled event to the client owning the resource.
 * @param resource_ The client's resource
 * @param enabled zero if disabled, non-zero if enabled
 */
#[inline]
unsafe extern "C" fn zwlr_output_head_v1_send_enabled(mut resource_:
                                                          *mut wl_resource,
                                                      mut enabled: int32_t) {
    wl_resource_post_event(resource_, 4i32 as uint32_t, enabled);
}
/* *
 * @ingroup iface_zwlr_output_head_v1
 * Sends an current_mode event to the client owning the resource.
 * @param resource_ The client's resource
 */
#[inline]
unsafe extern "C" fn zwlr_output_head_v1_send_current_mode(mut resource_:
                                                               *mut wl_resource,
                                                           mut mode:
                                                               *mut wl_resource) {
    wl_resource_post_event(resource_, 5i32 as uint32_t, mode);
}
/* *
 * @ingroup iface_zwlr_output_head_v1
 * Sends an position event to the client owning the resource.
 * @param resource_ The client's resource
 * @param x x position within the global compositor space
 * @param y y position within the global compositor space
 */
#[inline]
unsafe extern "C" fn zwlr_output_head_v1_send_position(mut resource_:
                                                           *mut wl_resource,
                                                       mut x: int32_t,
                                                       mut y: int32_t) {
    wl_resource_post_event(resource_, 6i32 as uint32_t, x, y);
}
/* *
 * @ingroup iface_zwlr_output_head_v1
 * Sends an transform event to the client owning the resource.
 * @param resource_ The client's resource
 */
#[inline]
unsafe extern "C" fn zwlr_output_head_v1_send_transform(mut resource_:
                                                            *mut wl_resource,
                                                        mut transform:
                                                            int32_t) {
    wl_resource_post_event(resource_, 7i32 as uint32_t, transform);
}
/* *
 * @ingroup iface_zwlr_output_head_v1
 * Sends an scale event to the client owning the resource.
 * @param resource_ The client's resource
 */
#[inline]
unsafe extern "C" fn zwlr_output_head_v1_send_scale(mut resource_:
                                                        *mut wl_resource,
                                                    mut scale: wl_fixed_t) {
    wl_resource_post_event(resource_, 8i32 as uint32_t, scale);
}
/* *
 * @ingroup iface_zwlr_output_head_v1
 * Sends an finished event to the client owning the resource.
 * @param resource_ The client's resource
 */
#[inline]
unsafe extern "C" fn zwlr_output_head_v1_send_finished(mut resource_:
                                                           *mut wl_resource) {
    wl_resource_post_event(resource_, 9i32 as uint32_t);
}
/* *
 * @ingroup iface_zwlr_output_mode_v1
 */
/* *
 * @ingroup iface_zwlr_output_mode_v1
 */
/* *
 * @ingroup iface_zwlr_output_mode_v1
 */
/* *
 * @ingroup iface_zwlr_output_mode_v1
 */
/* *
 * @ingroup iface_zwlr_output_mode_v1
 * Sends an size event to the client owning the resource.
 * @param resource_ The client's resource
 * @param width width of the mode in hardware units
 * @param height height of the mode in hardware units
 */
#[inline]
unsafe extern "C" fn zwlr_output_mode_v1_send_size(mut resource_:
                                                       *mut wl_resource,
                                                   mut width: int32_t,
                                                   mut height: int32_t) {
    wl_resource_post_event(resource_, 0i32 as uint32_t, width, height);
}
/* *
 * @ingroup iface_zwlr_output_mode_v1
 * Sends an refresh event to the client owning the resource.
 * @param resource_ The client's resource
 * @param refresh vertical refresh rate in mHz
 */
#[inline]
unsafe extern "C" fn zwlr_output_mode_v1_send_refresh(mut resource_:
                                                          *mut wl_resource,
                                                      mut refresh: int32_t) {
    wl_resource_post_event(resource_, 1i32 as uint32_t, refresh);
}
/* *
 * @ingroup iface_zwlr_output_mode_v1
 * Sends an preferred event to the client owning the resource.
 * @param resource_ The client's resource
 */
#[inline]
unsafe extern "C" fn zwlr_output_mode_v1_send_preferred(mut resource_:
                                                            *mut wl_resource) {
    wl_resource_post_event(resource_, 2i32 as uint32_t);
}
/* *
 * @ingroup iface_zwlr_output_mode_v1
 * Sends an finished event to the client owning the resource.
 * @param resource_ The client's resource
 */
#[inline]
unsafe extern "C" fn zwlr_output_mode_v1_send_finished(mut resource_:
                                                           *mut wl_resource) {
    wl_resource_post_event(resource_, 3i32 as uint32_t);
}
/* *
 * @ingroup iface_zwlr_output_configuration_v1
 */
/* *
 * @ingroup iface_zwlr_output_configuration_v1
 */
/* *
 * @ingroup iface_zwlr_output_configuration_v1
 */
/* *
 * @ingroup iface_zwlr_output_configuration_v1
 */
/* *
 * @ingroup iface_zwlr_output_configuration_v1
 */
/* *
 * @ingroup iface_zwlr_output_configuration_v1
 */
/* *
 * @ingroup iface_zwlr_output_configuration_v1
 */
/* *
 * @ingroup iface_zwlr_output_configuration_v1
 */
/* *
 * @ingroup iface_zwlr_output_configuration_v1
 * Sends an succeeded event to the client owning the resource.
 * @param resource_ The client's resource
 */
#[inline]
unsafe extern "C" fn zwlr_output_configuration_v1_send_succeeded(mut resource_:
                                                                     *mut wl_resource) {
    wl_resource_post_event(resource_, 0i32 as uint32_t);
}
/* *
 * @ingroup iface_zwlr_output_configuration_v1
 * Sends an failed event to the client owning the resource.
 * @param resource_ The client's resource
 */
#[inline]
unsafe extern "C" fn zwlr_output_configuration_v1_send_failed(mut resource_:
                                                                  *mut wl_resource) {
    wl_resource_post_event(resource_, 1i32 as uint32_t);
}
/* *
 * @ingroup iface_zwlr_output_configuration_v1
 * Sends an cancelled event to the client owning the resource.
 * @param resource_ The client's resource
 */
#[inline]
unsafe extern "C" fn zwlr_output_configuration_v1_send_cancelled(mut resource_:
                                                                     *mut wl_resource) {
    wl_resource_post_event(resource_, 2i32 as uint32_t);
}
static mut HEAD_STATE_ALL: uint32_t =
    (HEAD_STATE_ENABLED as libc::c_int | HEAD_STATE_MODE as libc::c_int |
         HEAD_STATE_POSITION as libc::c_int |
         HEAD_STATE_TRANSFORM as libc::c_int |
         HEAD_STATE_SCALE as libc::c_int) as uint32_t;
// Can return NULL if the head is inert
unsafe extern "C" fn head_from_resource(mut resource: *mut wl_resource)
 -> *mut wlr_output_head_v1 {
    if wl_resource_instance_of(resource, &zwlr_output_head_v1_interface,
                               0 as *const libc::c_void) != 0 {
    } else {
        __assert_fail(b"wl_resource_instance_of(resource, &zwlr_output_head_v1_interface, NULL)\x00"
                          as *const u8 as *const libc::c_char,
                      b"../types/wlr_output_management_v1.c\x00" as *const u8
                          as *const libc::c_char, 27i32 as libc::c_uint,
                      (*::std::mem::transmute::<&[u8; 68],
                                                &[libc::c_char; 68]>(b"struct wlr_output_head_v1 *head_from_resource(struct wl_resource *)\x00")).as_ptr());
    };
    return wl_resource_get_user_data(resource) as *mut wlr_output_head_v1;
}
unsafe extern "C" fn mode_from_resource(mut resource: *mut wl_resource)
 -> *mut wlr_output_mode {
    if wl_resource_instance_of(resource, &zwlr_output_mode_v1_interface,
                               0 as *const libc::c_void) != 0 {
    } else {
        __assert_fail(b"wl_resource_instance_of(resource, &zwlr_output_mode_v1_interface, NULL)\x00"
                          as *const u8 as *const libc::c_char,
                      b"../types/wlr_output_management_v1.c\x00" as *const u8
                          as *const libc::c_char, 34i32 as libc::c_uint,
                      (*::std::mem::transmute::<&[u8; 65],
                                                &[libc::c_char; 65]>(b"struct wlr_output_mode *mode_from_resource(struct wl_resource *)\x00")).as_ptr());
    };
    return wl_resource_get_user_data(resource) as *mut wlr_output_mode;
}
unsafe extern "C" fn head_destroy(mut head: *mut wlr_output_head_v1) {
    if head.is_null() { return }
    let mut resource: *mut wl_resource = 0 as *mut wl_resource;
    let mut tmp: *mut wl_resource = 0 as *mut wl_resource;
    resource = 0 as *mut wl_resource;
    tmp = 0 as *mut wl_resource;
    resource = wl_resource_from_link((*head).mode_resources.next);
    tmp = wl_resource_from_link((*(*head).mode_resources.next).next);
    while wl_resource_get_link(resource) !=
              &mut (*head).mode_resources as *mut wl_list {
        zwlr_output_mode_v1_send_finished(resource);
        wl_resource_destroy(resource);
        resource = tmp;
        tmp = wl_resource_from_link((*wl_resource_get_link(resource)).next)
    }
    resource = 0 as *mut wl_resource;
    tmp = 0 as *mut wl_resource;
    resource = wl_resource_from_link((*head).resources.next);
    tmp = wl_resource_from_link((*(*head).resources.next).next);
    while wl_resource_get_link(resource) !=
              &mut (*head).resources as *mut wl_list {
        zwlr_output_head_v1_send_finished(resource);
        wl_resource_destroy(resource);
        resource = tmp;
        tmp = wl_resource_from_link((*wl_resource_get_link(resource)).next)
    }
    wl_list_remove(&mut (*head).link);
    wl_list_remove(&mut (*head).output_destroy.link);
    free(head as *mut libc::c_void);
}
unsafe extern "C" fn head_handle_output_destroy(mut listener:
                                                    *mut wl_listener,
                                                mut data: *mut libc::c_void) {
    let mut head: *mut wlr_output_head_v1 =
        (listener as *mut libc::c_char).offset(-112) as
            *mut wlr_output_head_v1;
    head_destroy(head);
}
unsafe extern "C" fn head_create(mut manager: *mut wlr_output_manager_v1,
                                 mut output: *mut wlr_output)
 -> *mut wlr_output_head_v1 {
    let mut head: *mut wlr_output_head_v1 =
        calloc(1i32 as libc::c_ulong,
               ::std::mem::size_of::<wlr_output_head_v1>() as libc::c_ulong)
            as *mut wlr_output_head_v1;
    if head.is_null() { return 0 as *mut wlr_output_head_v1 }
    (*head).manager = manager;
    (*head).state.output = output;
    wl_list_init(&mut (*head).resources);
    wl_list_init(&mut (*head).mode_resources);
    wl_list_insert(&mut (*manager).heads, &mut (*head).link);
    (*head).output_destroy.notify =
        Some(head_handle_output_destroy as
                 unsafe extern "C" fn(_: *mut wl_listener,
                                      _: *mut libc::c_void) -> ());
    wl_signal_add(&mut (*output).events.destroy, &mut (*head).output_destroy);
    return head;
}
unsafe extern "C" fn config_head_destroy(mut config_head:
                                             *mut wlr_output_configuration_head_v1) {
    if config_head.is_null() { return }
    if !(*config_head).resource.is_null() {
        wl_resource_set_user_data((*config_head).resource,
                                  0 as *mut libc::c_void);
        // make inert
    }
    wl_list_remove(&mut (*config_head).link);
    wl_list_remove(&mut (*config_head).output_destroy.link);
    free(config_head as *mut libc::c_void);
}
unsafe extern "C" fn config_head_handle_output_destroy(mut listener:
                                                           *mut wl_listener,
                                                       mut data:
                                                           *mut libc::c_void) {
    let mut config_head: *mut wlr_output_configuration_head_v1 =
        (listener as *mut libc::c_char).offset(-88) as
            *mut wlr_output_configuration_head_v1;
    config_head_destroy(config_head);
}
unsafe extern "C" fn config_head_create(mut config:
                                            *mut wlr_output_configuration_v1,
                                        mut output: *mut wlr_output)
 -> *mut wlr_output_configuration_head_v1 {
    let mut config_head: *mut wlr_output_configuration_head_v1 =
        calloc(1i32 as libc::c_ulong,
               ::std::mem::size_of::<wlr_output_configuration_head_v1>() as
                   libc::c_ulong) as *mut wlr_output_configuration_head_v1;
    if config_head.is_null() {
        return 0 as *mut wlr_output_configuration_head_v1
    }
    (*config_head).config = config;
    (*config_head).state.output = output;
    wl_list_insert(&mut (*config).heads, &mut (*config_head).link);
    (*config_head).output_destroy.notify =
        Some(config_head_handle_output_destroy as
                 unsafe extern "C" fn(_: *mut wl_listener,
                                      _: *mut libc::c_void) -> ());
    wl_signal_add(&mut (*output).events.destroy,
                  &mut (*config_head).output_destroy);
    return config_head;
}
/* *
 * Create a new configuration head for the given output. This adds the head to
 * the provided output configuration.
 *
 * The configuration head will be pre-filled with data from `output`. The
 * compositor should adjust this data according to its current internal state.
 */
#[no_mangle]
pub unsafe extern "C" fn wlr_output_configuration_head_v1_create(mut config:
                                                                     *mut wlr_output_configuration_v1,
                                                                 mut output:
                                                                     *mut wlr_output)
 -> *mut wlr_output_configuration_head_v1 {
    let mut config_head: *mut wlr_output_configuration_head_v1 =
        config_head_create(config, output);
    (*config_head).state.enabled = (*output).enabled;
    (*config_head).state.mode = (*output).current_mode;
    (*config_head).state.custom_mode.width = (*output).width;
    (*config_head).state.custom_mode.height = (*output).height;
    (*config_head).state.custom_mode.refresh = (*output).refresh;
    (*config_head).state.transform = (*output).transform;
    (*config_head).state.scale = (*output).scale as libc::c_double;
    return config_head;
}
// Can return NULL if the configuration head is inert
unsafe extern "C" fn config_head_from_resource(mut resource: *mut wl_resource)
 -> *mut wlr_output_configuration_head_v1 {
    if wl_resource_instance_of(resource,
                               &zwlr_output_configuration_head_v1_interface,
                               &config_head_impl as
                                   *const zwlr_output_configuration_head_v1_interface
                                   as *const libc::c_void) != 0 {
    } else {
        __assert_fail(b"wl_resource_instance_of(resource, &zwlr_output_configuration_head_v1_interface, &config_head_impl)\x00"
                          as *const u8 as *const libc::c_char,
                      b"../types/wlr_output_management_v1.c\x00" as *const u8
                          as *const libc::c_char, 136i32 as libc::c_uint,
                      (*::std::mem::transmute::<&[u8; 89],
                                                &[libc::c_char; 89]>(b"struct wlr_output_configuration_head_v1 *config_head_from_resource(struct wl_resource *)\x00")).as_ptr());
    };
    return wl_resource_get_user_data(resource) as
               *mut wlr_output_configuration_head_v1;
}
unsafe extern "C" fn config_head_handle_set_mode(mut client: *mut wl_client,
                                                 mut config_head_resource:
                                                     *mut wl_resource,
                                                 mut mode_resource:
                                                     *mut wl_resource) {
    let mut config_head: *mut wlr_output_configuration_head_v1 =
        config_head_from_resource(config_head_resource);
    if config_head.is_null() { return }
    // Mode can be NULL if the output doesn't support modes (in which case we
	// expose only one "virtual" mode, the current mode)
    let mut mode: *mut wlr_output_mode = mode_from_resource(mode_resource);
    let mut output: *mut wlr_output = (*config_head).state.output;
    let mut found: bool =
        mode.is_null() && wl_list_empty(&mut (*output).modes) != 0;
    let mut m: *mut wlr_output_mode = 0 as *mut wlr_output_mode;
    m =
        ((*output).modes.next as *mut libc::c_char).offset(-16) as
            *mut wlr_output_mode;
    while &mut (*m).link as *mut wl_list !=
              &mut (*output).modes as *mut wl_list {
        if mode == m {
            found = 1i32 != 0;
            break ;
        } else {
            m =
                ((*m).link.next as *mut libc::c_char).offset(-16) as
                    *mut wlr_output_mode
        }
    }
    if !found {
        wl_resource_post_error(config_head_resource,
                               ZWLR_OUTPUT_CONFIGURATION_HEAD_V1_ERROR_INVALID_MODE
                                   as libc::c_int as uint32_t,
                               b"mode doesn\'t belong to head\x00" as
                                   *const u8 as *const libc::c_char);
        return
    }
    (*config_head).state.mode = mode;
    if !mode.is_null() {
        (*config_head).state.custom_mode.width = 0i32;
        (*config_head).state.custom_mode.height = 0i32;
        (*config_head).state.custom_mode.refresh = 0i32
    };
}
unsafe extern "C" fn config_head_handle_set_custom_mode(mut client:
                                                            *mut wl_client,
                                                        mut config_head_resource:
                                                            *mut wl_resource,
                                                        mut width: int32_t,
                                                        mut height: int32_t,
                                                        mut refresh:
                                                            int32_t) {
    let mut config_head: *mut wlr_output_configuration_head_v1 =
        config_head_from_resource(config_head_resource);
    if config_head.is_null() { return }
    if width <= 0i32 || height <= 0i32 || refresh < 0i32 {
        wl_resource_post_error(config_head_resource,
                               ZWLR_OUTPUT_CONFIGURATION_HEAD_V1_ERROR_INVALID_CUSTOM_MODE
                                   as libc::c_int as uint32_t,
                               b"invalid custom mode\x00" as *const u8 as
                                   *const libc::c_char);
        return
    }
    (*config_head).state.mode = 0 as *mut wlr_output_mode;
    (*config_head).state.custom_mode.width = width;
    (*config_head).state.custom_mode.height = height;
    (*config_head).state.custom_mode.refresh = refresh;
}
unsafe extern "C" fn config_head_handle_set_position(mut client:
                                                         *mut wl_client,
                                                     mut config_head_resource:
                                                         *mut wl_resource,
                                                     mut x: int32_t,
                                                     mut y: int32_t) {
    let mut config_head: *mut wlr_output_configuration_head_v1 =
        config_head_from_resource(config_head_resource);
    if config_head.is_null() { return }
    (*config_head).state.x = x;
    (*config_head).state.y = y;
}
unsafe extern "C" fn config_head_handle_set_transform(mut client:
                                                          *mut wl_client,
                                                      mut config_head_resource:
                                                          *mut wl_resource,
                                                      mut transform:
                                                          int32_t) {
    let mut config_head: *mut wlr_output_configuration_head_v1 =
        config_head_from_resource(config_head_resource);
    if config_head.is_null() { return }
    if transform < WL_OUTPUT_TRANSFORM_NORMAL as libc::c_int ||
           transform > WL_OUTPUT_TRANSFORM_FLIPPED_270 as libc::c_int {
        wl_resource_post_error(config_head_resource,
                               ZWLR_OUTPUT_CONFIGURATION_HEAD_V1_ERROR_INVALID_TRANSFORM
                                   as libc::c_int as uint32_t,
                               b"invalid transform\x00" as *const u8 as
                                   *const libc::c_char);
        return
    }
    (*config_head).state.transform = transform as wl_output_transform;
}
unsafe extern "C" fn config_head_handle_set_scale(mut client: *mut wl_client,
                                                  mut config_head_resource:
                                                      *mut wl_resource,
                                                  mut scale_fixed:
                                                      wl_fixed_t) {
    let mut config_head: *mut wlr_output_configuration_head_v1 =
        config_head_from_resource(config_head_resource);
    if config_head.is_null() { return }
    let mut scale: libc::c_double = wl_fixed_to_double(scale_fixed);
    if scale <= 0i32 as libc::c_double {
        wl_resource_post_error(config_head_resource,
                               ZWLR_OUTPUT_CONFIGURATION_HEAD_V1_ERROR_INVALID_SCALE
                                   as libc::c_int as uint32_t,
                               b"invalid scale\x00" as *const u8 as
                                   *const libc::c_char);
        return
    }
    (*config_head).state.scale = scale;
}
static mut config_head_impl: zwlr_output_configuration_head_v1_interface =
    unsafe {
        {
            let mut init =
                zwlr_output_configuration_head_v1_interface{set_mode:
                                                                Some(config_head_handle_set_mode
                                                                         as
                                                                         unsafe extern "C" fn(_:
                                                                                                  *mut wl_client,
                                                                                              _:
                                                                                                  *mut wl_resource,
                                                                                              _:
                                                                                                  *mut wl_resource)
                                                                             ->
                                                                                 ()),
                                                            set_custom_mode:
                                                                Some(config_head_handle_set_custom_mode
                                                                         as
                                                                         unsafe extern "C" fn(_:
                                                                                                  *mut wl_client,
                                                                                              _:
                                                                                                  *mut wl_resource,
                                                                                              _:
                                                                                                  int32_t,
                                                                                              _:
                                                                                                  int32_t,
                                                                                              _:
                                                                                                  int32_t)
                                                                             ->
                                                                                 ()),
                                                            set_position:
                                                                Some(config_head_handle_set_position
                                                                         as
                                                                         unsafe extern "C" fn(_:
                                                                                                  *mut wl_client,
                                                                                              _:
                                                                                                  *mut wl_resource,
                                                                                              _:
                                                                                                  int32_t,
                                                                                              _:
                                                                                                  int32_t)
                                                                             ->
                                                                                 ()),
                                                            set_transform:
                                                                Some(config_head_handle_set_transform
                                                                         as
                                                                         unsafe extern "C" fn(_:
                                                                                                  *mut wl_client,
                                                                                              _:
                                                                                                  *mut wl_resource,
                                                                                              _:
                                                                                                  int32_t)
                                                                             ->
                                                                                 ()),
                                                            set_scale:
                                                                Some(config_head_handle_set_scale
                                                                         as
                                                                         unsafe extern "C" fn(_:
                                                                                                  *mut wl_client,
                                                                                              _:
                                                                                                  *mut wl_resource,
                                                                                              _:
                                                                                                  wl_fixed_t)
                                                                             ->
                                                                                 ()),};
            init
        }
    };
unsafe extern "C" fn config_head_handle_resource_destroy(mut resource:
                                                             *mut wl_resource) {
    let mut config_head: *mut wlr_output_configuration_head_v1 =
        config_head_from_resource(resource);
    config_head_destroy(config_head);
}
// Can return NULL if the config has been used
unsafe extern "C" fn config_from_resource(mut resource: *mut wl_resource)
 -> *mut wlr_output_configuration_v1 {
    if wl_resource_instance_of(resource,
                               &zwlr_output_configuration_v1_interface,
                               &config_impl as
                                   *const zwlr_output_configuration_v1_interface
                                   as *const libc::c_void) != 0 {
    } else {
        __assert_fail(b"wl_resource_instance_of(resource, &zwlr_output_configuration_v1_interface, &config_impl)\x00"
                          as *const u8 as *const libc::c_char,
                      b"../types/wlr_output_management_v1.c\x00" as *const u8
                          as *const libc::c_char, 271i32 as libc::c_uint,
                      (*::std::mem::transmute::<&[u8; 79],
                                                &[libc::c_char; 79]>(b"struct wlr_output_configuration_v1 *config_from_resource(struct wl_resource *)\x00")).as_ptr());
    };
    return wl_resource_get_user_data(resource) as
               *mut wlr_output_configuration_v1;
}
// Checks that the head is unconfigured (ie. no enable_head/disable_head request
// has yet been sent for this head), if not sends a protocol error.
unsafe extern "C" fn config_check_head_is_unconfigured(mut config:
                                                           *mut wlr_output_configuration_v1,
                                                       mut output:
                                                           *mut wlr_output)
 -> bool {
    let mut head: *mut wlr_output_configuration_head_v1 =
        0 as *mut wlr_output_configuration_head_v1;
    head =
        ((*config).heads.next as *mut libc::c_char).offset(-64) as
            *mut wlr_output_configuration_head_v1;
    while &mut (*head).link as *mut wl_list !=
              &mut (*config).heads as *mut wl_list {
        if (*head).state.output == output {
            wl_resource_post_error((*config).resource,
                                   ZWLR_OUTPUT_CONFIGURATION_V1_ERROR_ALREADY_CONFIGURED_HEAD
                                       as libc::c_int as uint32_t,
                                   b"head has already been configured\x00" as
                                       *const u8 as *const libc::c_char);
            return 0i32 != 0
        }
        head =
            ((*head).link.next as *mut libc::c_char).offset(-64) as
                *mut wlr_output_configuration_head_v1
    }
    return 1i32 != 0;
}
unsafe extern "C" fn config_handle_enable_head(mut client: *mut wl_client,
                                               mut config_resource:
                                                   *mut wl_resource,
                                               mut id: uint32_t,
                                               mut head_resource:
                                                   *mut wl_resource) {
    let mut config: *mut wlr_output_configuration_v1 =
        config_from_resource(config_resource);
    if config.is_null() || (*config).finalized as libc::c_int != 0 {
        wl_resource_post_error(config_resource,
                               ZWLR_OUTPUT_CONFIGURATION_V1_ERROR_ALREADY_USED
                                   as libc::c_int as uint32_t,
                               b"configuration object has already been used\x00"
                                   as *const u8 as *const libc::c_char);
        return
    }
    let mut head: *mut wlr_output_head_v1 = head_from_resource(head_resource);
    // Create an inert resource if the head no longer exists
    let mut config_head: *mut wlr_output_configuration_head_v1 =
        0 as *mut wlr_output_configuration_head_v1;
    if !head.is_null() {
        if !config_check_head_is_unconfigured(config, (*head).state.output) {
            return
        }
        config_head = config_head_create(config, (*head).state.output);
        if config_head.is_null() {
            wl_resource_post_no_memory(config_resource);
            return
        }
        (*config_head).state = (*head).state
    }
    let mut version: uint32_t =
        wl_resource_get_version(config_resource) as uint32_t;
    let mut resource: *mut wl_resource =
        wl_resource_create(client,
                           &zwlr_output_configuration_head_v1_interface,
                           version as libc::c_int, id);
    if resource.is_null() { wl_client_post_no_memory(client); return }
    wl_resource_set_implementation(resource,
                                   &config_head_impl as
                                       *const zwlr_output_configuration_head_v1_interface
                                       as *const libc::c_void,
                                   config_head as *mut libc::c_void,
                                   Some(config_head_handle_resource_destroy as
                                            unsafe extern "C" fn(_:
                                                                     *mut wl_resource)
                                                -> ()));
    if !config_head.is_null() {
        (*config_head).resource = resource;
        (*config_head).state.enabled = 1i32 != 0
    };
}
unsafe extern "C" fn config_handle_disable_head(mut client: *mut wl_client,
                                                mut config_resource:
                                                    *mut wl_resource,
                                                mut head_resource:
                                                    *mut wl_resource) {
    let mut config: *mut wlr_output_configuration_v1 =
        config_from_resource(config_resource);
    if config.is_null() || (*config).finalized as libc::c_int != 0 {
        wl_resource_post_error(config_resource,
                               ZWLR_OUTPUT_CONFIGURATION_V1_ERROR_ALREADY_USED
                                   as libc::c_int as uint32_t,
                               b"configuration object has already been used\x00"
                                   as *const u8 as *const libc::c_char);
        return
    }
    let mut head: *mut wlr_output_head_v1 = head_from_resource(head_resource);
    if head.is_null() { return }
    if !config_check_head_is_unconfigured(config, (*head).state.output) {
        return
    }
    let mut config_head: *mut wlr_output_configuration_head_v1 =
        config_head_create(config, (*head).state.output);
    if config_head.is_null() {
        wl_resource_post_no_memory(config_resource);
        return
    }
    (*config_head).state.enabled = 0i32 != 0;
}
// Finalizes a configuration. This prevents the same config from being used
// multiple times.
unsafe extern "C" fn config_finalize(mut config:
                                         *mut wlr_output_configuration_v1) {
    if (*config).finalized { return }
    // Destroy config head resources now, the client is forbidden to use them at
	// this point anyway
    let mut config_head: *mut wlr_output_configuration_head_v1 =
        0 as *mut wlr_output_configuration_head_v1;
    let mut tmp: *mut wlr_output_configuration_head_v1 =
        0 as *mut wlr_output_configuration_head_v1;
    config_head =
        ((*config).heads.next as *mut libc::c_char).offset(-64) as
            *mut wlr_output_configuration_head_v1;
    tmp =
        ((*config_head).link.next as *mut libc::c_char).offset(-64) as
            *mut wlr_output_configuration_head_v1;
    while &mut (*config_head).link as *mut wl_list !=
              &mut (*config).heads as *mut wl_list {
        // Resource is NULL if head has been disabled
        if !(*config_head).resource.is_null() {
            wl_resource_set_user_data((*config_head).resource,
                                      0 as *mut libc::c_void);
            wl_resource_destroy((*config_head).resource);
            (*config_head).resource = 0 as *mut wl_resource
        }
        config_head = tmp;
        tmp =
            ((*config_head).link.next as *mut libc::c_char).offset(-64) as
                *mut wlr_output_configuration_head_v1
    }
    (*config).finalized = 1i32 != 0;
}
// Destroys the config if serial is invalid
unsafe extern "C" fn config_validate_serial(mut config:
                                                *mut wlr_output_configuration_v1)
 -> bool {
    if (*config).serial != (*(*config).manager).serial {
        _wlr_log(WLR_DEBUG,
                 b"[%s:%d] Ignored configuration request: invalid serial\x00"
                     as *const u8 as *const libc::c_char,
                 b"../types/wlr_output_management_v1.c\x00" as *const u8 as
                     *const libc::c_char, 388i32);
        zwlr_output_configuration_v1_send_cancelled((*config).resource);
        wlr_output_configuration_v1_destroy(config);
        return 0i32 != 0
    }
    return 1i32 != 0;
}
unsafe extern "C" fn config_handle_apply(mut client: *mut wl_client,
                                         mut config_resource:
                                             *mut wl_resource) {
    let mut config: *mut wlr_output_configuration_v1 =
        config_from_resource(config_resource);
    if config.is_null() || (*config).finalized as libc::c_int != 0 {
        wl_resource_post_error(config_resource,
                               ZWLR_OUTPUT_CONFIGURATION_V1_ERROR_ALREADY_USED
                                   as libc::c_int as uint32_t,
                               b"configuration object has already been used\x00"
                                   as *const u8 as *const libc::c_char);
        return
    }
    config_finalize(config);
    if !config_validate_serial(config) { return }
    wlr_signal_emit_safe(&mut (*(*config).manager).events.apply,
                         config as *mut libc::c_void);
}
unsafe extern "C" fn config_handle_test(mut client: *mut wl_client,
                                        mut config_resource:
                                            *mut wl_resource) {
    let mut config: *mut wlr_output_configuration_v1 =
        config_from_resource(config_resource);
    if config.is_null() || (*config).finalized as libc::c_int != 0 {
        wl_resource_post_error(config_resource,
                               ZWLR_OUTPUT_CONFIGURATION_V1_ERROR_ALREADY_USED
                                   as libc::c_int as uint32_t,
                               b"configuration object has already been used\x00"
                                   as *const u8 as *const libc::c_char);
        return
    }
    config_finalize(config);
    if !config_validate_serial(config) { return }
    wlr_signal_emit_safe(&mut (*(*config).manager).events.test,
                         config as *mut libc::c_void);
}
unsafe extern "C" fn config_handle_destroy(mut client: *mut wl_client,
                                           mut config_resource:
                                               *mut wl_resource) {
    wl_resource_destroy(config_resource);
}
static mut config_impl: zwlr_output_configuration_v1_interface =
    unsafe {
        {
            let mut init =
                zwlr_output_configuration_v1_interface{enable_head:
                                                           Some(config_handle_enable_head
                                                                    as
                                                                    unsafe extern "C" fn(_:
                                                                                             *mut wl_client,
                                                                                         _:
                                                                                             *mut wl_resource,
                                                                                         _:
                                                                                             uint32_t,
                                                                                         _:
                                                                                             *mut wl_resource)
                                                                        ->
                                                                            ()),
                                                       disable_head:
                                                           Some(config_handle_disable_head
                                                                    as
                                                                    unsafe extern "C" fn(_:
                                                                                             *mut wl_client,
                                                                                         _:
                                                                                             *mut wl_resource,
                                                                                         _:
                                                                                             *mut wl_resource)
                                                                        ->
                                                                            ()),
                                                       apply:
                                                           Some(config_handle_apply
                                                                    as
                                                                    unsafe extern "C" fn(_:
                                                                                             *mut wl_client,
                                                                                         _:
                                                                                             *mut wl_resource)
                                                                        ->
                                                                            ()),
                                                       test:
                                                           Some(config_handle_test
                                                                    as
                                                                    unsafe extern "C" fn(_:
                                                                                             *mut wl_client,
                                                                                         _:
                                                                                             *mut wl_resource)
                                                                        ->
                                                                            ()),
                                                       destroy:
                                                           Some(config_handle_destroy
                                                                    as
                                                                    unsafe extern "C" fn(_:
                                                                                             *mut wl_client,
                                                                                         _:
                                                                                             *mut wl_resource)
                                                                        ->
                                                                            ()),};
            init
        }
    };
unsafe extern "C" fn config_create(mut finalized: bool)
 -> *mut wlr_output_configuration_v1 {
    let mut config: *mut wlr_output_configuration_v1 =
        calloc(1i32 as libc::c_ulong,
               ::std::mem::size_of::<wlr_output_configuration_v1>() as
                   libc::c_ulong) as *mut wlr_output_configuration_v1;
    if config.is_null() { return 0 as *mut wlr_output_configuration_v1 }
    wl_list_init(&mut (*config).heads);
    (*config).finalized = finalized;
    return config;
}
#[no_mangle]
pub unsafe extern "C" fn wlr_output_configuration_v1_create()
 -> *mut wlr_output_configuration_v1 {
    return config_create(1i32 != 0);
}
#[no_mangle]
pub unsafe extern "C" fn wlr_output_configuration_v1_destroy(mut config:
                                                                 *mut wlr_output_configuration_v1) {
    if config.is_null() { return }
    config_finalize(config);
    if !(*config).resource.is_null() {
        wl_resource_set_user_data((*config).resource, 0 as *mut libc::c_void);
        // make inert
    }
    let mut config_head: *mut wlr_output_configuration_head_v1 =
        0 as *mut wlr_output_configuration_head_v1;
    let mut tmp: *mut wlr_output_configuration_head_v1 =
        0 as *mut wlr_output_configuration_head_v1;
    config_head =
        ((*config).heads.next as *mut libc::c_char).offset(-64) as
            *mut wlr_output_configuration_head_v1;
    tmp =
        ((*config_head).link.next as *mut libc::c_char).offset(-64) as
            *mut wlr_output_configuration_head_v1;
    while &mut (*config_head).link as *mut wl_list !=
              &mut (*config).heads as *mut wl_list {
        config_head_destroy(config_head);
        config_head = tmp;
        tmp =
            ((*config_head).link.next as *mut libc::c_char).offset(-64) as
                *mut wlr_output_configuration_head_v1
    }
    free(config as *mut libc::c_void);
}
unsafe extern "C" fn config_handle_resource_destroy(mut resource:
                                                        *mut wl_resource) {
    let mut config: *mut wlr_output_configuration_v1 =
        config_from_resource(resource);
    if config.is_null() { return }
    if (*config).finalized {
        (*config).resource = 0 as *mut wl_resource
        // we no longer own the config
    } else { wlr_output_configuration_v1_destroy(config); };
}
#[no_mangle]
pub unsafe extern "C" fn wlr_output_configuration_v1_send_succeeded(mut config:
                                                                        *mut wlr_output_configuration_v1) {
    if !(*config).finished {
    } else {
        __assert_fail(b"!config->finished\x00" as *const u8 as
                          *const libc::c_char,
                      b"../types/wlr_output_management_v1.c\x00" as *const u8
                          as *const libc::c_char, 491i32 as libc::c_uint,
                      (*::std::mem::transmute::<&[u8; 86],
                                                &[libc::c_char; 86]>(b"void wlr_output_configuration_v1_send_succeeded(struct wlr_output_configuration_v1 *)\x00")).as_ptr());
    };
    if (*config).resource.is_null() {
        return
        // client destroyed the resource early
    }
    zwlr_output_configuration_v1_send_succeeded((*config).resource);
    (*config).finished = 1i32 != 0;
}
/* *
 * Create a new, empty output configuration. Compositors should add current head
 * status with `wlr_output_configuration_head_v1_create`. They can then call
 * `wlr_output_manager_v1_set_configuration`.
 */
/* *
 * If the configuration comes from a client request, this sends positive
 * feedback to the client (configuration has been applied).
 */
/* *
 * If the configuration comes from a client request, this sends negative
 * feedback to the client (configuration has not been applied).
 */
#[no_mangle]
pub unsafe extern "C" fn wlr_output_configuration_v1_send_failed(mut config:
                                                                     *mut wlr_output_configuration_v1) {
    if !(*config).finished {
    } else {
        __assert_fail(b"!config->finished\x00" as *const u8 as
                          *const libc::c_char,
                      b"../types/wlr_output_management_v1.c\x00" as *const u8
                          as *const libc::c_char, 501i32 as libc::c_uint,
                      (*::std::mem::transmute::<&[u8; 83],
                                                &[libc::c_char; 83]>(b"void wlr_output_configuration_v1_send_failed(struct wlr_output_configuration_v1 *)\x00")).as_ptr());
    };
    if (*config).resource.is_null() {
        return
        // client destroyed the resource early
    }
    zwlr_output_configuration_v1_send_failed((*config).resource);
    (*config).finished = 1i32 != 0;
}
unsafe extern "C" fn manager_from_resource(mut resource: *mut wl_resource)
 -> *mut wlr_output_manager_v1 {
    if wl_resource_instance_of(resource, &zwlr_output_manager_v1_interface,
                               &manager_impl as
                                   *const zwlr_output_manager_v1_interface as
                                   *const libc::c_void) != 0 {
    } else {
        __assert_fail(b"wl_resource_instance_of(resource, &zwlr_output_manager_v1_interface, &manager_impl)\x00"
                          as *const u8 as *const libc::c_char,
                      b"../types/wlr_output_management_v1.c\x00" as *const u8
                          as *const libc::c_char, 515i32 as libc::c_uint,
                      (*::std::mem::transmute::<&[u8; 74],
                                                &[libc::c_char; 74]>(b"struct wlr_output_manager_v1 *manager_from_resource(struct wl_resource *)\x00")).as_ptr());
    };
    return wl_resource_get_user_data(resource) as *mut wlr_output_manager_v1;
}
unsafe extern "C" fn manager_handle_create_configuration(mut client:
                                                             *mut wl_client,
                                                         mut manager_resource:
                                                             *mut wl_resource,
                                                         mut id: uint32_t,
                                                         mut serial:
                                                             uint32_t) {
    let mut manager: *mut wlr_output_manager_v1 =
        manager_from_resource(manager_resource);
    let mut config: *mut wlr_output_configuration_v1 =
        config_create(0i32 != 0);
    if config.is_null() {
        wl_resource_post_no_memory(manager_resource);
        return
    }
    (*config).manager = manager;
    (*config).serial = serial;
    let mut version: uint32_t =
        wl_resource_get_version(manager_resource) as uint32_t;
    (*config).resource =
        wl_resource_create(client, &zwlr_output_configuration_v1_interface,
                           version as libc::c_int, id);
    if (*config).resource.is_null() {
        wl_client_post_no_memory(client);
        return
    }
    wl_resource_set_implementation((*config).resource,
                                   &config_impl as
                                       *const zwlr_output_configuration_v1_interface
                                       as *const libc::c_void,
                                   config as *mut libc::c_void,
                                   Some(config_handle_resource_destroy as
                                            unsafe extern "C" fn(_:
                                                                     *mut wl_resource)
                                                -> ()));
}
unsafe extern "C" fn manager_handle_stop(mut client: *mut wl_client,
                                         mut manager_resource:
                                             *mut wl_resource) {
    zwlr_output_manager_v1_send_finished(manager_resource);
    wl_resource_destroy(manager_resource);
}
static mut manager_impl: zwlr_output_manager_v1_interface =
    unsafe {
        {
            let mut init =
                zwlr_output_manager_v1_interface{create_configuration:
                                                     Some(manager_handle_create_configuration
                                                              as
                                                              unsafe extern "C" fn(_:
                                                                                       *mut wl_client,
                                                                                   _:
                                                                                       *mut wl_resource,
                                                                                   _:
                                                                                       uint32_t,
                                                                                   _:
                                                                                       uint32_t)
                                                                  -> ()),
                                                 stop:
                                                     Some(manager_handle_stop
                                                              as
                                                              unsafe extern "C" fn(_:
                                                                                       *mut wl_client,
                                                                                   _:
                                                                                       *mut wl_resource)
                                                                  -> ()),};
            init
        }
    };
unsafe extern "C" fn manager_handle_resource_destroy(mut resource:
                                                         *mut wl_resource) {
    wl_list_remove(wl_resource_get_link(resource));
}
unsafe extern "C" fn manager_bind(mut client: *mut wl_client,
                                  mut data: *mut libc::c_void,
                                  mut version: uint32_t, mut id: uint32_t) {
    let mut manager: *mut wlr_output_manager_v1 =
        data as *mut wlr_output_manager_v1;
    let mut resource: *mut wl_resource =
        wl_resource_create(client, &zwlr_output_manager_v1_interface,
                           version as libc::c_int, id);
    if resource.is_null() { wl_client_post_no_memory(client); return }
    wl_resource_set_implementation(resource,
                                   &manager_impl as
                                       *const zwlr_output_manager_v1_interface
                                       as *const libc::c_void,
                                   manager as *mut libc::c_void,
                                   Some(manager_handle_resource_destroy as
                                            unsafe extern "C" fn(_:
                                                                     *mut wl_resource)
                                                -> ()));
    wl_list_insert(&mut (*manager).resources, wl_resource_get_link(resource));
    let mut head: *mut wlr_output_head_v1 = 0 as *mut wlr_output_head_v1;
    head =
        ((*manager).heads.next as *mut libc::c_char).offset(-64) as
            *mut wlr_output_head_v1;
    while &mut (*head).link as *mut wl_list !=
              &mut (*manager).heads as *mut wl_list {
        manager_send_head(manager, head, resource);
        head =
            ((*head).link.next as *mut libc::c_char).offset(-64) as
                *mut wlr_output_head_v1
    }
    zwlr_output_manager_v1_send_done(resource, (*manager).serial);
}
unsafe extern "C" fn manager_handle_display_destroy(mut listener:
                                                        *mut wl_listener,
                                                    mut data:
                                                        *mut libc::c_void) {
    let mut manager: *mut wlr_output_manager_v1 =
        (listener as *mut libc::c_char).offset(-104) as
            *mut wlr_output_manager_v1;
    wlr_signal_emit_safe(&mut (*manager).events.destroy,
                         manager as *mut libc::c_void);
    wl_list_remove(&mut (*manager).display_destroy.link);
    let mut head: *mut wlr_output_head_v1 = 0 as *mut wlr_output_head_v1;
    let mut tmp: *mut wlr_output_head_v1 = 0 as *mut wlr_output_head_v1;
    head =
        ((*manager).heads.next as *mut libc::c_char).offset(-64) as
            *mut wlr_output_head_v1;
    tmp =
        ((*head).link.next as *mut libc::c_char).offset(-64) as
            *mut wlr_output_head_v1;
    while &mut (*head).link as *mut wl_list !=
              &mut (*manager).heads as *mut wl_list {
        head_destroy(head);
        head = tmp;
        tmp =
            ((*head).link.next as *mut libc::c_char).offset(-64) as
                *mut wlr_output_head_v1
    }
    wl_global_destroy((*manager).global);
    free(manager as *mut libc::c_void);
}
#[no_mangle]
pub unsafe extern "C" fn wlr_output_manager_v1_create(mut display:
                                                          *mut wl_display)
 -> *mut wlr_output_manager_v1 {
    let mut manager: *mut wlr_output_manager_v1 =
        calloc(1i32 as libc::c_ulong,
               ::std::mem::size_of::<wlr_output_manager_v1>() as
                   libc::c_ulong) as *mut wlr_output_manager_v1;
    if manager.is_null() { return 0 as *mut wlr_output_manager_v1 }
    (*manager).display = display;
    wl_list_init(&mut (*manager).resources);
    wl_list_init(&mut (*manager).heads);
    wl_signal_init(&mut (*manager).events.destroy);
    wl_signal_init(&mut (*manager).events.apply);
    wl_signal_init(&mut (*manager).events.test);
    (*manager).global =
        wl_global_create(display, &zwlr_output_manager_v1_interface, 1i32,
                         manager as *mut libc::c_void,
                         Some(manager_bind as
                                  unsafe extern "C" fn(_: *mut wl_client,
                                                       _: *mut libc::c_void,
                                                       _: uint32_t,
                                                       _: uint32_t) -> ()));
    if (*manager).global.is_null() {
        free(manager as *mut libc::c_void);
        return 0 as *mut wlr_output_manager_v1
    }
    (*manager).display_destroy.notify =
        Some(manager_handle_display_destroy as
                 unsafe extern "C" fn(_: *mut wl_listener,
                                      _: *mut libc::c_void) -> ());
    wl_display_add_destroy_listener(display, &mut (*manager).display_destroy);
    return manager;
}
unsafe extern "C" fn configuration_get_head(mut config:
                                                *mut wlr_output_configuration_v1,
                                            mut output: *mut wlr_output)
 -> *mut wlr_output_configuration_head_v1 {
    let mut head: *mut wlr_output_configuration_head_v1 =
        0 as *mut wlr_output_configuration_head_v1;
    head =
        ((*config).heads.next as *mut libc::c_char).offset(-64) as
            *mut wlr_output_configuration_head_v1;
    while &mut (*head).link as *mut wl_list !=
              &mut (*config).heads as *mut wl_list {
        if (*head).state.output == output { return head }
        head =
            ((*head).link.next as *mut libc::c_char).offset(-64) as
                *mut wlr_output_configuration_head_v1
    }
    return 0 as *mut wlr_output_configuration_head_v1;
}
unsafe extern "C" fn send_mode_state(mut mode_resource: *mut wl_resource,
                                     mut mode: *mut wlr_output_mode) {
    zwlr_output_mode_v1_send_size(mode_resource, (*mode).width,
                                  (*mode).height);
    if (*mode).refresh > 0i32 {
        zwlr_output_mode_v1_send_refresh(mode_resource, (*mode).refresh);
    }
    if (*mode).preferred {
        zwlr_output_mode_v1_send_preferred(mode_resource);
    };
}
unsafe extern "C" fn mode_handle_resource_destroy(mut resource:
                                                      *mut wl_resource) {
    wl_list_remove(wl_resource_get_link(resource));
}
unsafe extern "C" fn head_send_mode(mut head: *mut wlr_output_head_v1,
                                    mut head_resource: *mut wl_resource,
                                    mut mode: *mut wlr_output_mode)
 -> *mut wl_resource {
    let mut client: *mut wl_client = wl_resource_get_client(head_resource);
    let mut version: uint32_t =
        wl_resource_get_version(head_resource) as uint32_t;
    let mut mode_resource: *mut wl_resource =
        wl_resource_create(client, &zwlr_output_mode_v1_interface,
                           version as libc::c_int, 0i32 as uint32_t);
    if mode_resource.is_null() {
        wl_resource_post_no_memory(head_resource);
        return 0 as *mut wl_resource
    }
    wl_resource_set_implementation(mode_resource, 0 as *const libc::c_void,
                                   mode as *mut libc::c_void,
                                   Some(mode_handle_resource_destroy as
                                            unsafe extern "C" fn(_:
                                                                     *mut wl_resource)
                                                -> ()));
    wl_list_insert(&mut (*head).mode_resources,
                   wl_resource_get_link(mode_resource));
    zwlr_output_head_v1_send_mode(head_resource, mode_resource);
    if !mode.is_null() { send_mode_state(mode_resource, mode); }
    return mode_resource;
}
// Sends new head state to a client.
unsafe extern "C" fn head_send_state(mut head: *mut wlr_output_head_v1,
                                     mut head_resource: *mut wl_resource,
                                     mut state: uint32_t) {
    let mut client: *mut wl_client = wl_resource_get_client(head_resource);
    if state & HEAD_STATE_ENABLED as libc::c_int as libc::c_uint != 0 {
        zwlr_output_head_v1_send_enabled(head_resource,
                                         (*head).state.enabled as int32_t);
    }
    if !(*head).state.enabled { return }
    if state & HEAD_STATE_MODE as libc::c_int as libc::c_uint != 0 {
        if !(*head).state.mode.is_null() ||
               wl_list_empty(&mut (*(*head).state.output).modes) != 0 {
        } else {
            __assert_fail(b"head->state.mode != NULL || wl_list_empty(&head->state.output->modes)\x00"
                              as *const u8 as *const libc::c_char,
                          b"../types/wlr_output_management_v1.c\x00" as
                              *const u8 as *const libc::c_char,
                          690i32 as libc::c_uint,
                          (*::std::mem::transmute::<&[u8; 82],
                                                    &[libc::c_char; 82]>(b"void head_send_state(struct wlr_output_head_v1 *, struct wl_resource *, uint32_t)\x00")).as_ptr());
        };
        let mut found: bool = 0i32 != 0;
        let mut mode_resource: *mut wl_resource = 0 as *mut wl_resource;
        mode_resource = 0 as *mut wl_resource;
        mode_resource = wl_resource_from_link((*head).mode_resources.next);
        while wl_resource_get_link(mode_resource) !=
                  &mut (*head).mode_resources as *mut wl_list {
            if wl_resource_get_client(mode_resource) == client &&
                   mode_from_resource(mode_resource) == (*head).state.mode {
                found = 1i32 != 0;
                break ;
            } else {
                mode_resource =
                    wl_resource_from_link((*wl_resource_get_link(mode_resource)).next)
            }
        }
        if found as libc::c_int != 0 {
        } else {
            __assert_fail(b"found\x00" as *const u8 as *const libc::c_char,
                          b"../types/wlr_output_management_v1.c\x00" as
                              *const u8 as *const libc::c_char,
                          701i32 as libc::c_uint,
                          (*::std::mem::transmute::<&[u8; 82],
                                                    &[libc::c_char; 82]>(b"void head_send_state(struct wlr_output_head_v1 *, struct wl_resource *, uint32_t)\x00")).as_ptr());
        };
        if (*head).state.mode.is_null() {
            // Fake a single output mode if output doesn't support modes
            let mut virtual_mode: wlr_output_mode =
                {
                    let mut init =
                        wlr_output_mode{width:
                                            (*head).state.custom_mode.width,
                                        height:
                                            (*head).state.custom_mode.height,
                                        refresh:
                                            (*head).state.custom_mode.refresh,
                                        preferred: false,
                                        link:
                                            wl_list{prev: 0 as *mut wl_list,
                                                    next:
                                                        0 as *mut wl_list,},};
                    init
                };
            send_mode_state(mode_resource, &mut virtual_mode);
        }
        zwlr_output_head_v1_send_current_mode(head_resource, mode_resource);
    }
    if state & HEAD_STATE_POSITION as libc::c_int as libc::c_uint != 0 {
        zwlr_output_head_v1_send_position(head_resource, (*head).state.x,
                                          (*head).state.y);
    }
    if state & HEAD_STATE_TRANSFORM as libc::c_int as libc::c_uint != 0 {
        zwlr_output_head_v1_send_transform(head_resource,
                                           (*head).state.transform as
                                               int32_t);
    }
    if state & HEAD_STATE_SCALE as libc::c_int as libc::c_uint != 0 {
        zwlr_output_head_v1_send_scale(head_resource,
                                       wl_fixed_from_double((*head).state.scale));
    };
}
unsafe extern "C" fn head_handle_resource_destroy(mut resource:
                                                      *mut wl_resource) {
    wl_list_remove(wl_resource_get_link(resource));
}
unsafe extern "C" fn manager_send_head(mut manager:
                                           *mut wlr_output_manager_v1,
                                       mut head: *mut wlr_output_head_v1,
                                       mut manager_resource:
                                           *mut wl_resource) {
    let mut output: *mut wlr_output = (*head).state.output;
    let mut client: *mut wl_client = wl_resource_get_client(manager_resource);
    let mut version: uint32_t =
        wl_resource_get_version(manager_resource) as uint32_t;
    let mut head_resource: *mut wl_resource =
        wl_resource_create(client, &zwlr_output_head_v1_interface,
                           version as libc::c_int, 0i32 as uint32_t);
    if head_resource.is_null() {
        wl_resource_post_no_memory(manager_resource);
        return
    }
    wl_resource_set_implementation(head_resource, 0 as *const libc::c_void,
                                   head as *mut libc::c_void,
                                   Some(head_handle_resource_destroy as
                                            unsafe extern "C" fn(_:
                                                                     *mut wl_resource)
                                                -> ()));
    wl_list_insert(&mut (*head).resources,
                   wl_resource_get_link(head_resource));
    zwlr_output_manager_v1_send_head(manager_resource, head_resource);
    zwlr_output_head_v1_send_name(head_resource, (*output).name.as_mut_ptr());
    let mut description: [libc::c_char; 128] = [0; 128];
    snprintf(description.as_mut_ptr(),
             ::std::mem::size_of::<[libc::c_char; 128]>() as libc::c_ulong,
             b"%s %s %s (%s)\x00" as *const u8 as *const libc::c_char,
             (*output).make.as_mut_ptr(), (*output).model.as_mut_ptr(),
             (*output).serial.as_mut_ptr(), (*output).name.as_mut_ptr());
    zwlr_output_head_v1_send_description(head_resource,
                                         description.as_mut_ptr());
    if (*output).phys_width > 0i32 && (*output).phys_height > 0i32 {
        zwlr_output_head_v1_send_physical_size(head_resource,
                                               (*output).phys_width,
                                               (*output).phys_height);
    }
    let mut mode: *mut wlr_output_mode = 0 as *mut wlr_output_mode;
    mode =
        ((*output).modes.next as *mut libc::c_char).offset(-16) as
            *mut wlr_output_mode;
    while &mut (*mode).link as *mut wl_list !=
              &mut (*output).modes as *mut wl_list {
        head_send_mode(head, head_resource, mode);
        mode =
            ((*mode).link.next as *mut libc::c_char).offset(-16) as
                *mut wlr_output_mode
    }
    if wl_list_empty(&mut (*output).modes) != 0 {
        // Output doesn't support modes. Send a virtual one.
        head_send_mode(head, head_resource, 0 as *mut wlr_output_mode);
    }
    head_send_state(head, head_resource, HEAD_STATE_ALL);
}
// Compute state that has changed and sends it to all clients. Then writes the
// new state to the head.
unsafe extern "C" fn manager_update_head(mut manager:
                                             *mut wlr_output_manager_v1,
                                         mut head: *mut wlr_output_head_v1,
                                         mut next:
                                             *mut wlr_output_head_v1_state)
 -> bool {
    let mut current: *mut wlr_output_head_v1_state = &mut (*head).state;
    let mut state: uint32_t = 0i32 as uint32_t;
    if (*current).enabled as libc::c_int != (*next).enabled as libc::c_int {
        state |= HEAD_STATE_ENABLED as libc::c_int as libc::c_uint
    }
    if (*current).mode != (*next).mode {
        state |= HEAD_STATE_MODE as libc::c_int as libc::c_uint
    }
    if (*current).custom_mode.width != (*next).custom_mode.width ||
           (*current).custom_mode.height != (*next).custom_mode.height ||
           (*current).custom_mode.refresh != (*next).custom_mode.refresh {
        state |= HEAD_STATE_MODE as libc::c_int as libc::c_uint
    }
    if (*current).x != (*next).x || (*current).y != (*next).y {
        state |= HEAD_STATE_POSITION as libc::c_int as libc::c_uint
    }
    if (*current).transform as libc::c_uint !=
           (*next).transform as libc::c_uint {
        state |= HEAD_STATE_TRANSFORM as libc::c_int as libc::c_uint
    }
    if (*current).scale != (*next).scale {
        state |= HEAD_STATE_SCALE as libc::c_int as libc::c_uint
    }
    if state != 0i32 as libc::c_uint {
        *current = *next;
        let mut resource: *mut wl_resource = 0 as *mut wl_resource;
        resource = 0 as *mut wl_resource;
        resource = wl_resource_from_link((*head).resources.next);
        while wl_resource_get_link(resource) !=
                  &mut (*head).resources as *mut wl_list {
            head_send_state(head, resource, state);
            resource =
                wl_resource_from_link((*wl_resource_get_link(resource)).next)
        }
    }
    return state != 0i32 as libc::c_uint;
}
/*
 * This an unstable interface of wlroots. No guarantees are made regarding the
 * future consistency of this API.
 */
// wl_resource_get_link
// wlr_output_head_v1::link
/* *
		 * The `apply` and `test` events are emitted when a client requests a
		 * configuration to be applied or tested. The compositor should send
		 * feedback with `wlr_output_configuration_v1_send_succeeded` xor
		 * `wlr_output_configuration_v1_send_failed`.
		 *
		 * The compositor gains ownership over the configuration (passed as the
		 * event data). That is, the compositor is responsible for destroying
		 * the configuration.
		 */
// wlr_output_configuration_v1
// wlr_output_configuration_v1
// wlr_output_manager_v1::heads
// wl_resource_get_link
// wl_resource_get_link
// wlr_output_configuration_head_v1::link
// client state
// client has requested to apply the config
// feedback has been sent by the compositor
// can be NULL if destroyed early
// wlr_output_configuration_v1::heads
// client state
// can be NULL if finalized or disabled
/* *
 * Create a new output manager. The compositor is responsible for calling
 * `wlr_output_manager_v1_set_configuration` whenever the current output
 * configuration changes.
 */
/* *
 * Updates the output manager's current configuration. This will broadcast any
 * changes to all clients.
 *
 * This function takes ownership over `config`. That is, the compositor must not
 * access the configuration anymore.
 */
#[no_mangle]
pub unsafe extern "C" fn wlr_output_manager_v1_set_configuration(mut manager:
                                                                     *mut wlr_output_manager_v1,
                                                                 mut config:
                                                                     *mut wlr_output_configuration_v1) {
    let mut changed: bool = 0i32 != 0;
    // Either update or destroy existing heads
    let mut existing_head: *mut wlr_output_head_v1 =
        0 as *mut wlr_output_head_v1;
    let mut head_tmp: *mut wlr_output_head_v1 = 0 as *mut wlr_output_head_v1;
    existing_head =
        ((*manager).heads.next as *mut libc::c_char).offset(-64) as
            *mut wlr_output_head_v1;
    head_tmp =
        ((*existing_head).link.next as *mut libc::c_char).offset(-64) as
            *mut wlr_output_head_v1;
    while &mut (*existing_head).link as *mut wl_list !=
              &mut (*manager).heads as *mut wl_list {
        let mut updated_head: *mut wlr_output_configuration_head_v1 =
            configuration_get_head(config, (*existing_head).state.output);
        if !updated_head.is_null() {
            changed =
                (changed as libc::c_int |
                     manager_update_head(manager, existing_head,
                                         &mut (*updated_head).state) as
                         libc::c_int) != 0;
            config_head_destroy(updated_head);
        } else { head_destroy(existing_head); changed = 1i32 != 0 }
        existing_head = head_tmp;
        head_tmp =
            ((*existing_head).link.next as *mut libc::c_char).offset(-64) as
                *mut wlr_output_head_v1
    }
    // Heads remaining in `config` are new heads
    // Move new heads to current config
    let mut config_head: *mut wlr_output_configuration_head_v1 =
        0 as *mut wlr_output_configuration_head_v1;
    let mut config_head_tmp: *mut wlr_output_configuration_head_v1 =
        0 as *mut wlr_output_configuration_head_v1;
    config_head =
        ((*config).heads.next as *mut libc::c_char).offset(-64) as
            *mut wlr_output_configuration_head_v1;
    config_head_tmp =
        ((*config_head).link.next as *mut libc::c_char).offset(-64) as
            *mut wlr_output_configuration_head_v1;
    while &mut (*config_head).link as *mut wl_list !=
              &mut (*config).heads as *mut wl_list {
        let mut head: *mut wlr_output_head_v1 =
            head_create(manager, (*config_head).state.output);
        if head.is_null() {
            _wlr_log(WLR_ERROR,
                     b"[%s:%d] Allocation failed: %s\x00" as *const u8 as
                         *const libc::c_char,
                     b"../types/wlr_output_management_v1.c\x00" as *const u8
                         as *const libc::c_char, 848i32,
                     strerror(*__errno_location()));
        } else {
            (*head).state = (*config_head).state;
            let mut manager_resource: *mut wl_resource =
                0 as *mut wl_resource;
            manager_resource = 0 as *mut wl_resource;
            manager_resource =
                wl_resource_from_link((*manager).resources.next);
            while wl_resource_get_link(manager_resource) !=
                      &mut (*manager).resources as *mut wl_list {
                manager_send_head(manager, head, manager_resource);
                manager_resource =
                    wl_resource_from_link((*wl_resource_get_link(manager_resource)).next)
            }
            changed = 1i32 != 0
        }
        config_head = config_head_tmp;
        config_head_tmp =
            ((*config_head).link.next as *mut libc::c_char).offset(-64) as
                *mut wlr_output_configuration_head_v1
    }
    wlr_output_configuration_v1_destroy(config);
    if !changed { return }
    (*manager).serial = wl_display_next_serial((*manager).display);
    let mut manager_resource_0: *mut wl_resource = 0 as *mut wl_resource;
    manager_resource_0 = 0 as *mut wl_resource;
    manager_resource_0 = wl_resource_from_link((*manager).resources.next);
    while wl_resource_get_link(manager_resource_0) !=
              &mut (*manager).resources as *mut wl_list {
        zwlr_output_manager_v1_send_done(manager_resource_0,
                                         (*manager).serial);
        manager_resource_0 =
            wl_resource_from_link((*wl_resource_get_link(manager_resource_0)).next)
    };
}
