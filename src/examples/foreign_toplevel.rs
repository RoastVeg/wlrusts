use libc;
extern "C" {
    pub type _IO_wide_data;
    pub type _IO_codecvt;
    pub type _IO_marker;
    pub type wl_proxy;
    pub type wl_display;
    /* Generated by wayland-scanner 1.17.0 */
    /* *
 * @page page_wlr_foreign_toplevel_management_unstable_v1 The wlr_foreign_toplevel_management_unstable_v1 protocol
 * @section page_ifaces_wlr_foreign_toplevel_management_unstable_v1 Interfaces
 * - @subpage page_iface_zwlr_foreign_toplevel_manager_v1 - list and control opened apps
 * - @subpage page_iface_zwlr_foreign_toplevel_handle_v1 - an opened toplevel
 * @section page_copyright_wlr_foreign_toplevel_management_unstable_v1 Copyright
 * <pre>
 *
 * Copyright Â© 2018 Ilia Bozhinov
 *
 * Permission to use, copy, modify, distribute, and sell this
 * software and its documentation for any purpose is hereby granted
 * without fee, provided that the above copyright notice appear in
 * all copies and that both that copyright notice and this permission
 * notice appear in supporting documentation, and that the name of
 * the copyright holders not be used in advertising or publicity
 * pertaining to distribution of the software without specific,
 * written prior permission.  The copyright holders make no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied
 * warranty.
 *
 * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
 * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
 * FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
 * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
 * ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
 * THIS SOFTWARE.
 * </pre>
 */
    pub type wl_output;
    pub type wl_registry;
    pub type wl_seat;
    pub type zwlr_foreign_toplevel_manager_v1;
    pub type zwlr_foreign_toplevel_handle_v1;
    #[no_mangle]
    static mut optarg: *mut libc::c_char;
    #[no_mangle]
    fn getopt(___argc: libc::c_int, ___argv: *const *mut libc::c_char,
              __shortopts: *const libc::c_char) -> libc::c_int;
    #[no_mangle]
    static mut stderr: *mut FILE;
    #[no_mangle]
    fn fprintf(_: *mut FILE, _: *const libc::c_char, _: ...) -> libc::c_int;
    #[no_mangle]
    fn printf(_: *const libc::c_char, _: ...) -> libc::c_int;
    #[no_mangle]
    fn atoi(__nptr: *const libc::c_char) -> libc::c_int;
    #[no_mangle]
    fn calloc(_: libc::c_ulong, _: libc::c_ulong) -> *mut libc::c_void;
    #[no_mangle]
    fn free(__ptr: *mut libc::c_void);
    #[no_mangle]
    fn exit(_: libc::c_int) -> !;
    #[no_mangle]
    fn strcmp(_: *const libc::c_char, _: *const libc::c_char) -> libc::c_int;
    #[no_mangle]
    fn strdup(__s: *const libc::c_char) -> *mut libc::c_char;
    #[no_mangle]
    fn wl_list_init(list: *mut wl_list);
    #[no_mangle]
    fn wl_list_insert(list: *mut wl_list, elm: *mut wl_list);
    #[no_mangle]
    fn wl_proxy_marshal(p: *mut wl_proxy, opcode: uint32_t, _: ...);
    #[no_mangle]
    fn wl_proxy_marshal_constructor(proxy: *mut wl_proxy, opcode: uint32_t,
                                    interface: *const wl_interface, _: ...)
     -> *mut wl_proxy;
    #[no_mangle]
    fn wl_proxy_marshal_constructor_versioned(proxy: *mut wl_proxy,
                                              opcode: uint32_t,
                                              interface: *const wl_interface,
                                              version: uint32_t, _: ...)
     -> *mut wl_proxy;
    #[no_mangle]
    fn wl_proxy_destroy(proxy: *mut wl_proxy);
    #[no_mangle]
    fn wl_proxy_add_listener(proxy: *mut wl_proxy,
                             implementation:
                                 *mut Option<unsafe extern "C" fn() -> ()>,
                             data: *mut libc::c_void) -> libc::c_int;
    #[no_mangle]
    fn wl_proxy_set_user_data(proxy: *mut wl_proxy,
                              user_data: *mut libc::c_void);
    #[no_mangle]
    fn wl_proxy_get_user_data(proxy: *mut wl_proxy) -> *mut libc::c_void;
    #[no_mangle]
    fn wl_display_connect(name: *const libc::c_char) -> *mut wl_display;
    #[no_mangle]
    fn wl_display_dispatch(display: *mut wl_display) -> libc::c_int;
    #[no_mangle]
    fn wl_display_flush(display: *mut wl_display) -> libc::c_int;
    #[no_mangle]
    fn wl_display_roundtrip(display: *mut wl_display) -> libc::c_int;
    #[no_mangle]
    static wl_registry_interface: wl_interface;
    #[no_mangle]
    static wl_seat_interface: wl_interface;
    #[no_mangle]
    static wl_output_interface: wl_interface;
    /* *
 * @page page_iface_zwlr_foreign_toplevel_manager_v1 zwlr_foreign_toplevel_manager_v1
 * @section page_iface_zwlr_foreign_toplevel_manager_v1_desc Description
 *
 * The purpose of this protocol is to enable the creation of taskbars
 * and docks by providing them with a list of opened applications and
 * letting them request certain actions on them, like maximizing, etc.
 *
 * After a client binds the zwlr_foreign_toplevel_manager_v1, each opened
 * toplevel window will be sent via the toplevel event
 * @section page_iface_zwlr_foreign_toplevel_manager_v1_api API
 * See @ref iface_zwlr_foreign_toplevel_manager_v1.
 */
/* *
 * @defgroup iface_zwlr_foreign_toplevel_manager_v1 The zwlr_foreign_toplevel_manager_v1 interface
 *
 * The purpose of this protocol is to enable the creation of taskbars
 * and docks by providing them with a list of opened applications and
 * letting them request certain actions on them, like maximizing, etc.
 *
 * After a client binds the zwlr_foreign_toplevel_manager_v1, each opened
 * toplevel window will be sent via the toplevel event
 */
    #[no_mangle]
    static zwlr_foreign_toplevel_manager_v1_interface: wl_interface;
}
pub type size_t = libc::c_ulong;
pub type __int32_t = libc::c_int;
pub type __uint32_t = libc::c_uint;
pub type __off_t = libc::c_long;
pub type __off64_t = libc::c_long;
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct _IO_FILE {
    pub _flags: libc::c_int,
    pub _IO_read_ptr: *mut libc::c_char,
    pub _IO_read_end: *mut libc::c_char,
    pub _IO_read_base: *mut libc::c_char,
    pub _IO_write_base: *mut libc::c_char,
    pub _IO_write_ptr: *mut libc::c_char,
    pub _IO_write_end: *mut libc::c_char,
    pub _IO_buf_base: *mut libc::c_char,
    pub _IO_buf_end: *mut libc::c_char,
    pub _IO_save_base: *mut libc::c_char,
    pub _IO_backup_base: *mut libc::c_char,
    pub _IO_save_end: *mut libc::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: libc::c_int,
    pub _flags2: libc::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: libc::c_ushort,
    pub _vtable_offset: libc::c_schar,
    pub _shortbuf: [libc::c_char; 1],
    pub _lock: *mut libc::c_void,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut libc::c_void,
    pub __pad5: size_t,
    pub _mode: libc::c_int,
    pub _unused2: [libc::c_char; 20],
}
pub type _IO_lock_t = ();
pub type FILE = _IO_FILE;
pub type int32_t = __int32_t;
pub type uint32_t = __uint32_t;
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wl_message {
    pub name: *const libc::c_char,
    pub signature: *const libc::c_char,
    pub types: *mut *const wl_interface,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wl_interface {
    pub name: *const libc::c_char,
    pub version: libc::c_int,
    pub method_count: libc::c_int,
    pub methods: *const wl_message,
    pub event_count: libc::c_int,
    pub events: *const wl_message,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wl_list {
    pub prev: *mut wl_list,
    pub next: *mut wl_list,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wl_array {
    pub size: size_t,
    pub alloc: size_t,
    pub data: *mut libc::c_void,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct toplevel_v1 {
    pub link: wl_list,
    pub zwlr_toplevel: *mut zwlr_foreign_toplevel_handle_v1,
    pub id: uint32_t,
    pub current: toplevel_state,
    pub pending: toplevel_state,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct toplevel_state {
    pub title: *mut libc::c_char,
    pub app_id: *mut libc::c_char,
    pub state: uint32_t,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wl_registry_listener {
    pub global: Option<unsafe extern "C" fn(_: *mut libc::c_void,
                                            _: *mut wl_registry, _: uint32_t,
                                            _: *const libc::c_char,
                                            _: uint32_t) -> ()>,
    pub global_remove: Option<unsafe extern "C" fn(_: *mut libc::c_void,
                                                   _: *mut wl_registry,
                                                   _: uint32_t) -> ()>,
}
/* *
 * @ingroup iface_zwlr_foreign_toplevel_manager_v1
 * @struct zwlr_foreign_toplevel_manager_v1_listener
 */
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct zwlr_foreign_toplevel_manager_v1_listener {
    pub toplevel: Option<unsafe extern "C" fn(_: *mut libc::c_void,
                                              _:
                                                  *mut zwlr_foreign_toplevel_manager_v1,
                                              _:
                                                  *mut zwlr_foreign_toplevel_handle_v1)
                             -> ()>,
    pub finished: Option<unsafe extern "C" fn(_: *mut libc::c_void,
                                              _:
                                                  *mut zwlr_foreign_toplevel_manager_v1)
                             -> ()>,
}
/* *
 * @ingroup iface_zwlr_foreign_toplevel_handle_v1
 * types of states on the toplevel
 *
 * The different states that a toplevel can have. These have the same meaning
 * as the states with the same names defined in xdg-toplevel
 */
pub type zwlr_foreign_toplevel_handle_v1_state = libc::c_uint;
/* *
	 * the toplevel is fullscreen
	 * @since 2
	 */
pub const ZWLR_FOREIGN_TOPLEVEL_HANDLE_V1_STATE_FULLSCREEN:
          zwlr_foreign_toplevel_handle_v1_state =
    3;
/* *
	 * the toplevel is active
	 */
pub const ZWLR_FOREIGN_TOPLEVEL_HANDLE_V1_STATE_ACTIVATED:
          zwlr_foreign_toplevel_handle_v1_state =
    2;
/* *
	 * the toplevel is minimized
	 */
pub const ZWLR_FOREIGN_TOPLEVEL_HANDLE_V1_STATE_MINIMIZED:
          zwlr_foreign_toplevel_handle_v1_state =
    1;
/* *
	 * the toplevel is maximized
	 */
pub const ZWLR_FOREIGN_TOPLEVEL_HANDLE_V1_STATE_MAXIMIZED:
          zwlr_foreign_toplevel_handle_v1_state =
    0;
/* ZWLR_FOREIGN_TOPLEVEL_HANDLE_V1_ERROR_ENUM */
/* *
 * @ingroup iface_zwlr_foreign_toplevel_handle_v1
 * @struct zwlr_foreign_toplevel_handle_v1_listener
 */
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct zwlr_foreign_toplevel_handle_v1_listener {
    pub title: Option<unsafe extern "C" fn(_: *mut libc::c_void,
                                           _:
                                               *mut zwlr_foreign_toplevel_handle_v1,
                                           _: *const libc::c_char) -> ()>,
    pub app_id: Option<unsafe extern "C" fn(_: *mut libc::c_void,
                                            _:
                                                *mut zwlr_foreign_toplevel_handle_v1,
                                            _: *const libc::c_char) -> ()>,
    pub output_enter: Option<unsafe extern "C" fn(_: *mut libc::c_void,
                                                  _:
                                                      *mut zwlr_foreign_toplevel_handle_v1,
                                                  _: *mut wl_output) -> ()>,
    pub output_leave: Option<unsafe extern "C" fn(_: *mut libc::c_void,
                                                  _:
                                                      *mut zwlr_foreign_toplevel_handle_v1,
                                                  _: *mut wl_output) -> ()>,
    pub state: Option<unsafe extern "C" fn(_: *mut libc::c_void,
                                           _:
                                               *mut zwlr_foreign_toplevel_handle_v1,
                                           _: *mut wl_array) -> ()>,
    pub done: Option<unsafe extern "C" fn(_: *mut libc::c_void,
                                          _:
                                              *mut zwlr_foreign_toplevel_handle_v1)
                         -> ()>,
    pub closed: Option<unsafe extern "C" fn(_: *mut libc::c_void,
                                            _:
                                                *mut zwlr_foreign_toplevel_handle_v1)
                           -> ()>,
}
/* *
 * Usage:
 * 1. foreign-toplevel
 * 	  Prints a list of opened toplevels
 * 2. foreign-toplevel -f <id>
 *    Focus the toplevel with the given id
 * 3. foreign-toplevel -a <id>
 *    Maximize the toplevel with the given id
 * 4. foreign-toplevel -u <id>
 *    Unmaximize the toplevel with the given id
 * 5. foreign-toplevel -i <id>
 *    Minimize the toplevel with the given id
 * 6. foreign-toplevel -r <id>
 * 	  Restore(unminimize) the toplevel with the given id
 * 7. foreign-toplevel -c <id>
 *    Close the toplevel with the given id
 * 8. foreign-toplevel -m
 *    Continuously print changes to the list of opened toplevels.
 *    Can be used together with some of the previous options.
 */
pub type toplevel_state_field = libc::c_uint;
pub const TOPLEVEL_STATE_INVALID: toplevel_state_field = 16;
pub const TOPLEVEL_STATE_FULLSCREEN: toplevel_state_field = 8;
pub const TOPLEVEL_STATE_ACTIVATED: toplevel_state_field = 4;
pub const TOPLEVEL_STATE_MINIMIZED: toplevel_state_field = 2;
pub const TOPLEVEL_STATE_MAXIMIZED: toplevel_state_field = 1;
#[inline]
unsafe extern "C" fn wl_display_get_registry(mut wl_display: *mut wl_display)
 -> *mut wl_registry {
    let mut registry: *mut wl_proxy = 0 as *mut wl_proxy;
    registry =
        wl_proxy_marshal_constructor(wl_display as *mut wl_proxy,
                                     1i32 as uint32_t,
                                     &wl_registry_interface as
                                         *const wl_interface,
                                     0 as *mut libc::c_void);
    return registry as *mut wl_registry;
}
#[inline]
unsafe extern "C" fn wl_registry_add_listener(mut wl_registry:
                                                  *mut wl_registry,
                                              mut listener:
                                                  *const wl_registry_listener,
                                              mut data: *mut libc::c_void)
 -> libc::c_int {
    return wl_proxy_add_listener(wl_registry as *mut wl_proxy,
                                 listener as
                                     *mut Option<unsafe extern "C" fn()
                                                     -> ()>, data);
}
#[inline]
unsafe extern "C" fn wl_registry_bind(mut wl_registry: *mut wl_registry,
                                      mut name: uint32_t,
                                      mut interface: *const wl_interface,
                                      mut version: uint32_t)
 -> *mut libc::c_void {
    let mut id: *mut wl_proxy = 0 as *mut wl_proxy;
    id =
        wl_proxy_marshal_constructor_versioned(wl_registry as *mut wl_proxy,
                                               0i32 as uint32_t, interface,
                                               version, name,
                                               (*interface).name, version,
                                               0 as *mut libc::c_void);
    return id as *mut libc::c_void;
}
#[inline]
unsafe extern "C" fn wl_output_set_user_data(mut wl_output: *mut wl_output,
                                             mut user_data:
                                                 *mut libc::c_void) {
    wl_proxy_set_user_data(wl_output as *mut wl_proxy, user_data);
}
#[inline]
unsafe extern "C" fn wl_output_get_user_data(mut wl_output: *mut wl_output)
 -> *mut libc::c_void {
    return wl_proxy_get_user_data(wl_output as *mut wl_proxy);
}
/* *
 * @ingroup iface_zwlr_foreign_toplevel_manager_v1
 */
#[inline]
unsafe extern "C" fn zwlr_foreign_toplevel_manager_v1_add_listener(mut zwlr_foreign_toplevel_manager_v1:
                                                                       *mut zwlr_foreign_toplevel_manager_v1,
                                                                   mut listener:
                                                                       *const zwlr_foreign_toplevel_manager_v1_listener,
                                                                   mut data:
                                                                       *mut libc::c_void)
 -> libc::c_int {
    return wl_proxy_add_listener(zwlr_foreign_toplevel_manager_v1 as
                                     *mut wl_proxy,
                                 listener as
                                     *mut Option<unsafe extern "C" fn()
                                                     -> ()>, data);
}
/* * @ingroup iface_zwlr_foreign_toplevel_manager_v1 */
#[inline]
unsafe extern "C" fn zwlr_foreign_toplevel_manager_v1_destroy(mut zwlr_foreign_toplevel_manager_v1:
                                                                  *mut zwlr_foreign_toplevel_manager_v1) {
    wl_proxy_destroy(zwlr_foreign_toplevel_manager_v1 as *mut wl_proxy);
}
/* *
 * @ingroup iface_zwlr_foreign_toplevel_handle_v1
 */
#[inline]
unsafe extern "C" fn zwlr_foreign_toplevel_handle_v1_add_listener(mut zwlr_foreign_toplevel_handle_v1:
                                                                      *mut zwlr_foreign_toplevel_handle_v1,
                                                                  mut listener:
                                                                      *const zwlr_foreign_toplevel_handle_v1_listener,
                                                                  mut data:
                                                                      *mut libc::c_void)
 -> libc::c_int {
    return wl_proxy_add_listener(zwlr_foreign_toplevel_handle_v1 as
                                     *mut wl_proxy,
                                 listener as
                                     *mut Option<unsafe extern "C" fn()
                                                     -> ()>, data);
}
/* *
 * @ingroup iface_zwlr_foreign_toplevel_handle_v1
 *
 * Requests that the toplevel be maximized. If the maximized state actually
 * changes, this will be indicated by the state event.
 */
#[inline]
unsafe extern "C" fn zwlr_foreign_toplevel_handle_v1_set_maximized(mut zwlr_foreign_toplevel_handle_v1:
                                                                       *mut zwlr_foreign_toplevel_handle_v1) {
    wl_proxy_marshal(zwlr_foreign_toplevel_handle_v1 as *mut wl_proxy,
                     0i32 as uint32_t);
}
/* *
 * @ingroup iface_zwlr_foreign_toplevel_handle_v1
 *
 * Requests that the toplevel be unmaximized. If the maximized state actually
 * changes, this will be indicated by the state event.
 */
#[inline]
unsafe extern "C" fn zwlr_foreign_toplevel_handle_v1_unset_maximized(mut zwlr_foreign_toplevel_handle_v1:
                                                                         *mut zwlr_foreign_toplevel_handle_v1) {
    wl_proxy_marshal(zwlr_foreign_toplevel_handle_v1 as *mut wl_proxy,
                     1i32 as uint32_t);
}
/* *
 * @ingroup iface_zwlr_foreign_toplevel_handle_v1
 *
 * Requests that the toplevel be minimized. If the minimized state actually
 * changes, this will be indicated by the state event.
 */
#[inline]
unsafe extern "C" fn zwlr_foreign_toplevel_handle_v1_set_minimized(mut zwlr_foreign_toplevel_handle_v1:
                                                                       *mut zwlr_foreign_toplevel_handle_v1) {
    wl_proxy_marshal(zwlr_foreign_toplevel_handle_v1 as *mut wl_proxy,
                     2i32 as uint32_t);
}
/* *
 * @ingroup iface_zwlr_foreign_toplevel_handle_v1
 *
 * Requests that the toplevel be unminimized. If the minimized state actually
 * changes, this will be indicated by the state event.
 */
#[inline]
unsafe extern "C" fn zwlr_foreign_toplevel_handle_v1_unset_minimized(mut zwlr_foreign_toplevel_handle_v1:
                                                                         *mut zwlr_foreign_toplevel_handle_v1) {
    wl_proxy_marshal(zwlr_foreign_toplevel_handle_v1 as *mut wl_proxy,
                     3i32 as uint32_t);
}
/* *
 * @ingroup iface_zwlr_foreign_toplevel_handle_v1
 *
 * Request that this toplevel be activated on the given seat.
 * There is no guarantee the toplevel will be actually activated.
 */
#[inline]
unsafe extern "C" fn zwlr_foreign_toplevel_handle_v1_activate(mut zwlr_foreign_toplevel_handle_v1:
                                                                  *mut zwlr_foreign_toplevel_handle_v1,
                                                              mut seat_0:
                                                                  *mut wl_seat) {
    wl_proxy_marshal(zwlr_foreign_toplevel_handle_v1 as *mut wl_proxy,
                     4i32 as uint32_t, seat_0);
}
/* *
 * @ingroup iface_zwlr_foreign_toplevel_handle_v1
 *
 * Send a request to the toplevel to close itself. The compositor would
 * typically use a shell-specific method to carry out this request, for
 * example by sending the xdg_toplevel.close event. However, this gives
 * no guarantees the toplevel will actually be destroyed. If and when
 * this happens, the zwlr_foreign_toplevel_handle_v1.closed event will
 * be emitted.
 */
#[inline]
unsafe extern "C" fn zwlr_foreign_toplevel_handle_v1_close(mut zwlr_foreign_toplevel_handle_v1:
                                                               *mut zwlr_foreign_toplevel_handle_v1) {
    wl_proxy_marshal(zwlr_foreign_toplevel_handle_v1 as *mut wl_proxy,
                     5i32 as uint32_t);
}
/* *
 * @ingroup iface_zwlr_foreign_toplevel_handle_v1
 *
 * Destroys the zwlr_foreign_toplevel_handle_v1 object.
 *
 * This request should be called either when the client does not want to
 * use the toplevel anymore or after the closed event to finalize the
 * destruction of the object.
 */
#[inline]
unsafe extern "C" fn zwlr_foreign_toplevel_handle_v1_destroy(mut zwlr_foreign_toplevel_handle_v1:
                                                                 *mut zwlr_foreign_toplevel_handle_v1) {
    wl_proxy_marshal(zwlr_foreign_toplevel_handle_v1 as *mut wl_proxy,
                     7i32 as uint32_t);
    wl_proxy_destroy(zwlr_foreign_toplevel_handle_v1 as *mut wl_proxy);
}
/* *
 * @ingroup iface_zwlr_foreign_toplevel_handle_v1
 *
 * Requests that the toplevel be fullscreened on the given output. If the
 * fullscreen state and/or the outputs the toplevel is visible on actually
 * change, this will be indicated by the state and output_enter/leave
 * events.
 *
 * The output parameter is only a hint to the compositor. Also, if output
 * is NULL, the compositor should decide which output the toplevel will be
 * fullscreened on, if at all.
 */
#[inline]
unsafe extern "C" fn zwlr_foreign_toplevel_handle_v1_set_fullscreen(mut zwlr_foreign_toplevel_handle_v1:
                                                                        *mut zwlr_foreign_toplevel_handle_v1,
                                                                    mut output:
                                                                        *mut wl_output) {
    wl_proxy_marshal(zwlr_foreign_toplevel_handle_v1 as *mut wl_proxy,
                     8i32 as uint32_t, output);
}
/* *
 * @ingroup iface_zwlr_foreign_toplevel_handle_v1
 *
 * Requests that the toplevel be unfullscreened. If the fullscreen state
 * actually changes, this will be indicated by the state event.
 */
#[inline]
unsafe extern "C" fn zwlr_foreign_toplevel_handle_v1_unset_fullscreen(mut zwlr_foreign_toplevel_handle_v1:
                                                                          *mut zwlr_foreign_toplevel_handle_v1) {
    wl_proxy_marshal(zwlr_foreign_toplevel_handle_v1 as *mut wl_proxy,
                     9i32 as uint32_t);
}
unsafe extern "C" fn copy_state(mut current: *mut toplevel_state,
                                mut pending: *mut toplevel_state) {
    if !(*current).title.is_null() && !(*pending).title.is_null() {
        free((*current).title as *mut libc::c_void);
    }
    if !(*current).app_id.is_null() && !(*pending).app_id.is_null() {
        free((*current).app_id as *mut libc::c_void);
    }
    if !(*pending).title.is_null() {
        (*current).title = (*pending).title;
        (*pending).title = 0 as *mut libc::c_char
    }
    if !(*pending).app_id.is_null() {
        (*current).app_id = (*pending).app_id;
        (*pending).app_id = 0 as *mut libc::c_char
    }
    if (*pending).state &
           TOPLEVEL_STATE_INVALID as libc::c_int as libc::c_uint == 0 {
        (*current).state = (*pending).state
    }
    (*pending).state = TOPLEVEL_STATE_INVALID as libc::c_int as uint32_t;
}
static mut global_id: uint32_t = 0i32 as uint32_t;
unsafe extern "C" fn print_toplevel(mut toplevel: *mut toplevel_v1,
                                    mut print_endl: bool) {
    printf(b"-> %d. \x00" as *const u8 as *const libc::c_char,
           (*toplevel).id);
    if print_endl { printf(b"\n\x00" as *const u8 as *const libc::c_char); };
}
unsafe extern "C" fn print_toplevel_state(mut toplevel: *mut toplevel_v1,
                                          mut print_endl: bool) {
    if (*toplevel).current.state &
           TOPLEVEL_STATE_MAXIMIZED as libc::c_int as libc::c_uint != 0 {
        printf(b" maximized\x00" as *const u8 as *const libc::c_char);
    } else {
        printf(b" unmaximized\x00" as *const u8 as *const libc::c_char);
    }
    if (*toplevel).current.state &
           TOPLEVEL_STATE_MINIMIZED as libc::c_int as libc::c_uint != 0 {
        printf(b" minimized\x00" as *const u8 as *const libc::c_char);
    } else {
        printf(b" unminimized\x00" as *const u8 as *const libc::c_char);
    }
    if (*toplevel).current.state &
           TOPLEVEL_STATE_ACTIVATED as libc::c_int as libc::c_uint != 0 {
        printf(b" active\x00" as *const u8 as *const libc::c_char);
    } else { printf(b" inactive\x00" as *const u8 as *const libc::c_char); }
    if (*toplevel).current.state &
           TOPLEVEL_STATE_FULLSCREEN as libc::c_int as libc::c_uint != 0 {
        printf(b" fullscreen\x00" as *const u8 as *const libc::c_char);
    }
    if print_endl { printf(b"\n\x00" as *const u8 as *const libc::c_char); };
}
unsafe extern "C" fn toplevel_handle_title(mut data: *mut libc::c_void,
                                           mut zwlr_toplevel:
                                               *mut zwlr_foreign_toplevel_handle_v1,
                                           mut title: *const libc::c_char) {
    let mut toplevel: *mut toplevel_v1 = data as *mut toplevel_v1;
    free((*toplevel).pending.title as *mut libc::c_void);
    (*toplevel).pending.title = strdup(title);
}
unsafe extern "C" fn toplevel_handle_app_id(mut data: *mut libc::c_void,
                                            mut zwlr_toplevel:
                                                *mut zwlr_foreign_toplevel_handle_v1,
                                            mut app_id: *const libc::c_char) {
    let mut toplevel: *mut toplevel_v1 = data as *mut toplevel_v1;
    free((*toplevel).pending.app_id as *mut libc::c_void);
    (*toplevel).pending.app_id = strdup(app_id);
}
unsafe extern "C" fn toplevel_handle_output_enter(mut data: *mut libc::c_void,
                                                  mut zwlr_toplevel:
                                                      *mut zwlr_foreign_toplevel_handle_v1,
                                                  mut output:
                                                      *mut wl_output) {
    let mut toplevel: *mut toplevel_v1 = data as *mut toplevel_v1;
    print_toplevel(toplevel, 0i32 != 0);
    printf(b" enter output %u\n\x00" as *const u8 as *const libc::c_char,
           wl_output_get_user_data(output) as size_t as uint32_t);
}
unsafe extern "C" fn toplevel_handle_output_leave(mut data: *mut libc::c_void,
                                                  mut zwlr_toplevel:
                                                      *mut zwlr_foreign_toplevel_handle_v1,
                                                  mut output:
                                                      *mut wl_output) {
    let mut toplevel: *mut toplevel_v1 = data as *mut toplevel_v1;
    print_toplevel(toplevel, 0i32 != 0);
    printf(b" leave output %u\n\x00" as *const u8 as *const libc::c_char,
           wl_output_get_user_data(output) as size_t as uint32_t);
}
unsafe extern "C" fn array_to_state(mut array: *mut wl_array) -> uint32_t {
    let mut state: uint32_t = 0i32 as uint32_t;
    let mut entry: *mut uint32_t = 0 as *mut uint32_t;
    entry = (*array).data as *mut uint32_t;
    while (entry as *const libc::c_char) <
              ((*array).data as
                   *const libc::c_char).offset((*array).size as isize) {
        if *entry ==
               ZWLR_FOREIGN_TOPLEVEL_HANDLE_V1_STATE_MAXIMIZED as libc::c_int
                   as libc::c_uint {
            state |= TOPLEVEL_STATE_MAXIMIZED as libc::c_int as libc::c_uint
        }
        if *entry ==
               ZWLR_FOREIGN_TOPLEVEL_HANDLE_V1_STATE_MINIMIZED as libc::c_int
                   as libc::c_uint {
            state |= TOPLEVEL_STATE_MINIMIZED as libc::c_int as libc::c_uint
        }
        if *entry ==
               ZWLR_FOREIGN_TOPLEVEL_HANDLE_V1_STATE_ACTIVATED as libc::c_int
                   as libc::c_uint {
            state |= TOPLEVEL_STATE_ACTIVATED as libc::c_int as libc::c_uint
        }
        if *entry ==
               ZWLR_FOREIGN_TOPLEVEL_HANDLE_V1_STATE_FULLSCREEN as libc::c_int
                   as libc::c_uint {
            state |= TOPLEVEL_STATE_FULLSCREEN as libc::c_int as libc::c_uint
        }
        entry = entry.offset(1)
    }
    return state;
}
unsafe extern "C" fn toplevel_handle_state(mut data: *mut libc::c_void,
                                           mut zwlr_toplevel:
                                               *mut zwlr_foreign_toplevel_handle_v1,
                                           mut state: *mut wl_array) {
    let mut toplevel: *mut toplevel_v1 = data as *mut toplevel_v1;
    (*toplevel).pending.state = array_to_state(state);
}
unsafe extern "C" fn toplevel_handle_done(mut data: *mut libc::c_void,
                                          mut zwlr_toplevel:
                                              *mut zwlr_foreign_toplevel_handle_v1) {
    let mut toplevel: *mut toplevel_v1 = data as *mut toplevel_v1;
    let mut state_changed: bool =
        (*toplevel).current.state != (*toplevel).pending.state;
    copy_state(&mut (*toplevel).current, &mut (*toplevel).pending);
    print_toplevel(toplevel, !state_changed);
    if state_changed { print_toplevel_state(toplevel, 1i32 != 0); };
}
unsafe extern "C" fn toplevel_handle_closed(mut data: *mut libc::c_void,
                                            mut zwlr_toplevel:
                                                *mut zwlr_foreign_toplevel_handle_v1) {
    let mut toplevel: *mut toplevel_v1 = data as *mut toplevel_v1;
    print_toplevel(toplevel, 0i32 != 0);
    printf(b" closed\n\x00" as *const u8 as *const libc::c_char);
    zwlr_foreign_toplevel_handle_v1_destroy(zwlr_toplevel);
}
static mut toplevel_impl: zwlr_foreign_toplevel_handle_v1_listener =
    unsafe {
        {
            let mut init =
                zwlr_foreign_toplevel_handle_v1_listener{title:
                                                             Some(toplevel_handle_title
                                                                      as
                                                                      unsafe extern "C" fn(_:
                                                                                               *mut libc::c_void,
                                                                                           _:
                                                                                               *mut zwlr_foreign_toplevel_handle_v1,
                                                                                           _:
                                                                                               *const libc::c_char)
                                                                          ->
                                                                              ()),
                                                         app_id:
                                                             Some(toplevel_handle_app_id
                                                                      as
                                                                      unsafe extern "C" fn(_:
                                                                                               *mut libc::c_void,
                                                                                           _:
                                                                                               *mut zwlr_foreign_toplevel_handle_v1,
                                                                                           _:
                                                                                               *const libc::c_char)
                                                                          ->
                                                                              ()),
                                                         output_enter:
                                                             Some(toplevel_handle_output_enter
                                                                      as
                                                                      unsafe extern "C" fn(_:
                                                                                               *mut libc::c_void,
                                                                                           _:
                                                                                               *mut zwlr_foreign_toplevel_handle_v1,
                                                                                           _:
                                                                                               *mut wl_output)
                                                                          ->
                                                                              ()),
                                                         output_leave:
                                                             Some(toplevel_handle_output_leave
                                                                      as
                                                                      unsafe extern "C" fn(_:
                                                                                               *mut libc::c_void,
                                                                                           _:
                                                                                               *mut zwlr_foreign_toplevel_handle_v1,
                                                                                           _:
                                                                                               *mut wl_output)
                                                                          ->
                                                                              ()),
                                                         state:
                                                             Some(toplevel_handle_state
                                                                      as
                                                                      unsafe extern "C" fn(_:
                                                                                               *mut libc::c_void,
                                                                                           _:
                                                                                               *mut zwlr_foreign_toplevel_handle_v1,
                                                                                           _:
                                                                                               *mut wl_array)
                                                                          ->
                                                                              ()),
                                                         done:
                                                             Some(toplevel_handle_done
                                                                      as
                                                                      unsafe extern "C" fn(_:
                                                                                               *mut libc::c_void,
                                                                                           _:
                                                                                               *mut zwlr_foreign_toplevel_handle_v1)
                                                                          ->
                                                                              ()),
                                                         closed:
                                                             Some(toplevel_handle_closed
                                                                      as
                                                                      unsafe extern "C" fn(_:
                                                                                               *mut libc::c_void,
                                                                                           _:
                                                                                               *mut zwlr_foreign_toplevel_handle_v1)
                                                                          ->
                                                                              ()),};
            init
        }
    };
static mut toplevel_manager: *mut zwlr_foreign_toplevel_manager_v1 =
    0 as *const zwlr_foreign_toplevel_manager_v1 as
        *mut zwlr_foreign_toplevel_manager_v1;
static mut toplevel_list: wl_list =
    wl_list{prev: 0 as *const wl_list as *mut wl_list,
            next: 0 as *const wl_list as *mut wl_list,};
unsafe extern "C" fn toplevel_manager_handle_toplevel(mut data:
                                                          *mut libc::c_void,
                                                      mut toplevel_manager_0:
                                                          *mut zwlr_foreign_toplevel_manager_v1,
                                                      mut zwlr_toplevel:
                                                          *mut zwlr_foreign_toplevel_handle_v1) {
    let mut toplevel: *mut toplevel_v1 =
        calloc(1i32 as libc::c_ulong,
               ::std::mem::size_of::<toplevel_v1>() as libc::c_ulong) as
            *mut toplevel_v1;
    if toplevel.is_null() {
        fprintf(stderr,
                b"Failed to allocate memory for toplevel\n\x00" as *const u8
                    as *const libc::c_char);
        return
    }
    let fresh0 = global_id;
    global_id = global_id.wrapping_add(1);
    (*toplevel).id = fresh0;
    (*toplevel).zwlr_toplevel = zwlr_toplevel;
    wl_list_insert(&mut toplevel_list, &mut (*toplevel).link);
    zwlr_foreign_toplevel_handle_v1_add_listener(zwlr_toplevel,
                                                 &toplevel_impl,
                                                 toplevel as
                                                     *mut libc::c_void);
}
unsafe extern "C" fn toplevel_manager_handle_finished(mut data:
                                                          *mut libc::c_void,
                                                      mut toplevel_manager_0:
                                                          *mut zwlr_foreign_toplevel_manager_v1) {
    zwlr_foreign_toplevel_manager_v1_destroy(toplevel_manager_0);
}
static mut toplevel_manager_impl: zwlr_foreign_toplevel_manager_v1_listener =
    unsafe {
        {
            let mut init =
                zwlr_foreign_toplevel_manager_v1_listener{toplevel:
                                                              Some(toplevel_manager_handle_toplevel
                                                                       as
                                                                       unsafe extern "C" fn(_:
                                                                                                *mut libc::c_void,
                                                                                            _:
                                                                                                *mut zwlr_foreign_toplevel_manager_v1,
                                                                                            _:
                                                                                                *mut zwlr_foreign_toplevel_handle_v1)
                                                                           ->
                                                                               ()),
                                                          finished:
                                                              Some(toplevel_manager_handle_finished
                                                                       as
                                                                       unsafe extern "C" fn(_:
                                                                                                *mut libc::c_void,
                                                                                            _:
                                                                                                *mut zwlr_foreign_toplevel_manager_v1)
                                                                           ->
                                                                               ()),};
            init
        }
    };
#[no_mangle]
pub static mut seat: *mut wl_seat = 0 as *const wl_seat as *mut wl_seat;
unsafe extern "C" fn handle_global(mut data: *mut libc::c_void,
                                   mut registry: *mut wl_registry,
                                   mut name: uint32_t,
                                   mut interface: *const libc::c_char,
                                   mut version: uint32_t) {
    if strcmp(interface, wl_output_interface.name) == 0i32 {
        let mut output: *mut wl_output =
            wl_registry_bind(registry, name, &wl_output_interface, version) as
                *mut wl_output;
        wl_output_set_user_data(output, name as size_t as *mut libc::c_void);
        // assign some ID to the output
    } else if strcmp(interface,
                     zwlr_foreign_toplevel_manager_v1_interface.name) == 0i32
     {
        toplevel_manager =
            wl_registry_bind(registry, name,
                             &zwlr_foreign_toplevel_manager_v1_interface,
                             2i32 as uint32_t) as
                *mut zwlr_foreign_toplevel_manager_v1;
        wl_list_init(&mut toplevel_list);
        zwlr_foreign_toplevel_manager_v1_add_listener(toplevel_manager,
                                                      &toplevel_manager_impl,
                                                      0 as *mut libc::c_void);
    } else if strcmp(interface, wl_seat_interface.name) == 0i32 &&
                  seat.is_null() {
        seat =
            wl_registry_bind(registry, name, &wl_seat_interface, version) as
                *mut wl_seat
    };
}
unsafe extern "C" fn handle_global_remove(mut data: *mut libc::c_void,
                                          mut registry: *mut wl_registry,
                                          mut name: uint32_t) {
    // who cares
}
static mut registry_listener: wl_registry_listener =
    unsafe {
        {
            let mut init =
                wl_registry_listener{global:
                                         Some(handle_global as
                                                  unsafe extern "C" fn(_:
                                                                           *mut libc::c_void,
                                                                       _:
                                                                           *mut wl_registry,
                                                                       _:
                                                                           uint32_t,
                                                                       _:
                                                                           *const libc::c_char,
                                                                       _:
                                                                           uint32_t)
                                                      -> ()),
                                     global_remove:
                                         Some(handle_global_remove as
                                                  unsafe extern "C" fn(_:
                                                                           *mut libc::c_void,
                                                                       _:
                                                                           *mut wl_registry,
                                                                       _:
                                                                           uint32_t)
                                                      -> ()),};
            init
        }
    };
/* return NULL when id == -1
 * exit if the given ID cannot be found in the list of toplevels */
unsafe extern "C" fn toplevel_by_id_or_bail(mut id: int32_t)
 -> *mut toplevel_v1 {
    if id == -1i32 { return 0 as *mut toplevel_v1 }
    let mut toplevel: *mut toplevel_v1 = 0 as *mut toplevel_v1;
    toplevel =
        (toplevel_list.next as *mut libc::c_char).offset(-0) as
            *mut toplevel_v1;
    while &mut (*toplevel).link as *mut wl_list !=
              &mut toplevel_list as *mut wl_list {
        if (*toplevel).id == id as uint32_t { return toplevel }
        toplevel =
            ((*toplevel).link.next as *mut libc::c_char).offset(-0) as
                *mut toplevel_v1
    }
    fprintf(stderr,
            b"No toplevel with the given id: %d\n\x00" as *const u8 as
                *const libc::c_char, id);
    exit(1i32);
}
unsafe fn main_0(mut argc: libc::c_int, mut argv: *mut *mut libc::c_char)
 -> libc::c_int {
    let mut focus_id: libc::c_int = -1i32;
    let mut close_id: libc::c_int = -1i32;
    let mut maximize_id: libc::c_int = -1i32;
    let mut unmaximize_id: libc::c_int = -1i32;
    let mut minimize_id: libc::c_int = -1i32;
    let mut restore_id: libc::c_int = -1i32;
    let mut fullscreen_id: libc::c_int = -1i32;
    let mut unfullscreen_id: libc::c_int = -1i32;
    let mut one_shot: libc::c_int = 1i32;
    let mut c: libc::c_int = 0;
    loop 
         // TODO maybe print usage with -h?
         {
        c =
            getopt(argc, argv,
                   b"f:a:u:i:r:c:s:S:m\x00" as *const u8 as
                       *const libc::c_char); // load list of toplevels
        if !(c != -1i32) {
            break ; // load toplevel details
        }
        match c {
            102 => { focus_id = atoi(optarg) }
            97 => { maximize_id = atoi(optarg) }
            117 => { unmaximize_id = atoi(optarg) }
            105 => { minimize_id = atoi(optarg) }
            114 => { restore_id = atoi(optarg) }
            99 => { close_id = atoi(optarg) }
            115 => { fullscreen_id = atoi(optarg) }
            83 => { unfullscreen_id = atoi(optarg) }
            109 => { one_shot = 0i32 }
            _ => { }
        }
    }
    let mut display: *mut wl_display =
        wl_display_connect(0 as *const libc::c_char);
    if display.is_null() {
        fprintf(stderr,
                b"Failed to create display\n\x00" as *const u8 as
                    *const libc::c_char);
        return 1i32
    }
    let mut registry: *mut wl_registry = wl_display_get_registry(display);
    wl_registry_add_listener(registry, &registry_listener,
                             0 as *mut libc::c_void);
    wl_display_dispatch(display);
    wl_display_roundtrip(display);
    if toplevel_manager.is_null() {
        fprintf(stderr,
                b"wlr-foreign-toplevel not available\n\x00" as *const u8 as
                    *const libc::c_char);
        return 1i32
    }
    wl_display_roundtrip(display);
    wl_display_roundtrip(display);
    let mut toplevel: *mut toplevel_v1 = 0 as *mut toplevel_v1;
    toplevel = toplevel_by_id_or_bail(focus_id);
    if !toplevel.is_null() {
        zwlr_foreign_toplevel_handle_v1_activate((*toplevel).zwlr_toplevel,
                                                 seat);
    }
    toplevel = toplevel_by_id_or_bail(maximize_id);
    if !toplevel.is_null() {
        zwlr_foreign_toplevel_handle_v1_set_maximized((*toplevel).zwlr_toplevel);
    }
    toplevel = toplevel_by_id_or_bail(unmaximize_id);
    if !toplevel.is_null() {
        zwlr_foreign_toplevel_handle_v1_unset_maximized((*toplevel).zwlr_toplevel);
    }
    toplevel = toplevel_by_id_or_bail(minimize_id);
    if !toplevel.is_null() {
        zwlr_foreign_toplevel_handle_v1_set_minimized((*toplevel).zwlr_toplevel);
    }
    toplevel = toplevel_by_id_or_bail(restore_id);
    if !toplevel.is_null() {
        zwlr_foreign_toplevel_handle_v1_unset_minimized((*toplevel).zwlr_toplevel);
    }
    toplevel = toplevel_by_id_or_bail(fullscreen_id);
    if !toplevel.is_null() {
        zwlr_foreign_toplevel_handle_v1_set_fullscreen((*toplevel).zwlr_toplevel,
                                                       0 as *mut wl_output);
    }
    toplevel = toplevel_by_id_or_bail(unfullscreen_id);
    if !toplevel.is_null() {
        zwlr_foreign_toplevel_handle_v1_unset_fullscreen((*toplevel).zwlr_toplevel);
    }
    toplevel = toplevel_by_id_or_bail(close_id);
    if !toplevel.is_null() {
        zwlr_foreign_toplevel_handle_v1_close((*toplevel).zwlr_toplevel);
    }
    wl_display_flush(display);
    if one_shot == 0i32 {
        // This space intentionally left blank
        while wl_display_dispatch(display) != -1i32 { }
    }
    return 0i32;
}
#[main]
pub fn main() {
    let mut args: Vec<*mut libc::c_char> = Vec::new();
    for arg in ::std::env::args() {
        args.push(::std::ffi::CString::new(arg).expect("Failed to convert argument into CString.").into_raw());
    };
    args.push(::std::ptr::null_mut());
    unsafe {
        ::std::process::exit(main_0((args.len() - 1) as libc::c_int,
                                    args.as_mut_ptr() as
                                        *mut *mut libc::c_char) as i32)
    }
}
