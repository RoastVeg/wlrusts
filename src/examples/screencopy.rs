use libc;
extern "C" {
    pub type _IO_wide_data;
    pub type _IO_codecvt;
    pub type _IO_marker;
    pub type png_struct_def;
    pub type png_info_def;
    pub type wl_proxy;
    pub type wl_display;
    /* Generated by wayland-scanner 1.17.0 */
    /* *
 * @page page_wlr_screencopy_unstable_v1 The wlr_screencopy_unstable_v1 protocol
 * screen content capturing on client buffers
 *
 * @section page_desc_wlr_screencopy_unstable_v1 Description
 *
 * This protocol allows clients to ask the compositor to copy part of the
 * screen content to a client buffer.
 *
 * Warning! The protocol described in this file is experimental and
 * backward incompatible changes may be made. Backward compatible changes
 * may be added together with the corresponding interface version bump.
 * Backward incompatible changes are done by bumping the version number in
 * the protocol and interface names and resetting the interface version.
 * Once the protocol is to be declared stable, the 'z' prefix and the
 * version number in the protocol and interface names are removed and the
 * interface version number is reset.
 *
 * @section page_ifaces_wlr_screencopy_unstable_v1 Interfaces
 * - @subpage page_iface_zwlr_screencopy_manager_v1 - manager to inform clients and begin capturing
 * - @subpage page_iface_zwlr_screencopy_frame_v1 - a frame ready for copy
 * @section page_copyright_wlr_screencopy_unstable_v1 Copyright
 * <pre>
 *
 * Copyright © 2018 Simon Ser
 * Copyright © 2019 Andri Yngvason
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 * </pre>
 */
    pub type wl_buffer;
    pub type wl_output;
    pub type wl_registry;
    pub type wl_shm;
    pub type wl_shm_pool;
    pub type zwlr_screencopy_manager_v1;
    pub type zwlr_screencopy_frame_v1;
    /* Allocate and initialize png_ptr struct for writing, and any other memory */
    #[no_mangle]
    fn png_create_write_struct(user_png_ver: png_const_charp,
                               error_ptr: png_voidp, error_fn: png_error_ptr,
                               warn_fn: png_error_ptr) -> png_structp;
    /* Allocate and initialize the info structure */
    #[no_mangle]
    fn png_create_info_struct(png_ptr: png_const_structrp) -> png_infop;
    #[no_mangle]
    fn png_write_info(png_ptr: png_structrp, info_ptr: png_const_inforp);
    /* Use blue, green, red order for pixels. */
    #[no_mangle]
    fn png_set_bgr(png_ptr: png_structrp);
    /* Write a row of image data */
    #[no_mangle]
    fn png_write_row(png_ptr: png_structrp, row: png_const_bytep);
    /* Write the end of the PNG file. */
    #[no_mangle]
    fn png_write_end(png_ptr: png_structrp, info_ptr: png_inforp);
    /* Free any memory associated with the png_struct and the png_info_structs */
    #[no_mangle]
    fn png_destroy_write_struct(png_ptr_ptr: png_structpp,
                                info_ptr_ptr: png_infopp);
    /* WRITE_CUSTOMIZE_ZTXT_COMPRESSION */
    /* WRITE */
    /* These next functions are called for input/output, memory, and error
 * handling.  They are in the file pngrio.c, pngwio.c, and pngerror.c,
 * and call standard C I/O routines such as fread(), fwrite(), and
 * fprintf().  These functions can be made to use other I/O routines
 * at run time for those applications that need to handle I/O in a
 * different manner by calling png_set_???_fn().  See libpng-manual.txt for
 * more information.
 */
    /* Initialize the input/output for the PNG file to the default functions. */
    #[no_mangle]
    fn png_init_io(png_ptr: png_structrp, fp: png_FILE_p);
    #[no_mangle]
    fn fclose(__stream: *mut FILE) -> libc::c_int;
    #[no_mangle]
    static mut stderr: *mut FILE;
    #[no_mangle]
    fn png_set_IHDR(png_ptr: png_const_structrp, info_ptr: png_inforp,
                    width: png_uint_32, height: png_uint_32,
                    bit_depth: libc::c_int, color_type: libc::c_int,
                    interlace_method: libc::c_int,
                    compression_method: libc::c_int,
                    filter_method: libc::c_int);
    #[no_mangle]
    fn fopen(_: *const libc::c_char, _: *const libc::c_char) -> *mut FILE;
    #[no_mangle]
    fn fprintf(_: *mut FILE, _: *const libc::c_char, _: ...) -> libc::c_int;
    #[no_mangle]
    fn exit(_: libc::c_int) -> !;
    #[no_mangle]
    fn strcmp(_: *const libc::c_char, _: *const libc::c_char) -> libc::c_int;
    #[no_mangle]
    fn mmap(__addr: *mut libc::c_void, __len: size_t, __prot: libc::c_int,
            __flags: libc::c_int, __fd: libc::c_int, __offset: __off64_t)
     -> *mut libc::c_void;
    #[no_mangle]
    fn shm_open(__name: *const libc::c_char, __oflag: libc::c_int,
                __mode: mode_t) -> libc::c_int;
    #[no_mangle]
    fn shm_unlink(__name: *const libc::c_char) -> libc::c_int;
    #[no_mangle]
    fn close(__fd: libc::c_int) -> libc::c_int;
    #[no_mangle]
    fn ftruncate(__fd: libc::c_int, __length: __off64_t) -> libc::c_int;
    #[no_mangle]
    fn wl_proxy_marshal(p: *mut wl_proxy, opcode: uint32_t, _: ...);
    #[no_mangle]
    fn wl_proxy_marshal_constructor(proxy: *mut wl_proxy, opcode: uint32_t,
                                    interface: *const wl_interface, _: ...)
     -> *mut wl_proxy;
    #[no_mangle]
    fn wl_proxy_marshal_constructor_versioned(proxy: *mut wl_proxy,
                                              opcode: uint32_t,
                                              interface: *const wl_interface,
                                              version: uint32_t, _: ...)
     -> *mut wl_proxy;
    #[no_mangle]
    fn wl_proxy_destroy(proxy: *mut wl_proxy);
    #[no_mangle]
    fn wl_proxy_add_listener(proxy: *mut wl_proxy,
                             implementation:
                                 *mut Option<unsafe extern "C" fn() -> ()>,
                             data: *mut libc::c_void) -> libc::c_int;
    #[no_mangle]
    fn wl_display_connect(name: *const libc::c_char) -> *mut wl_display;
    #[no_mangle]
    fn wl_display_dispatch(display: *mut wl_display) -> libc::c_int;
    #[no_mangle]
    fn wl_display_roundtrip(display: *mut wl_display) -> libc::c_int;
    #[no_mangle]
    static wl_registry_interface: wl_interface;
    #[no_mangle]
    static wl_shm_pool_interface: wl_interface;
    #[no_mangle]
    static wl_shm_interface: wl_interface;
    #[no_mangle]
    static wl_buffer_interface: wl_interface;
    #[no_mangle]
    static wl_output_interface: wl_interface;
    /* *
 * @page page_iface_zwlr_screencopy_manager_v1 zwlr_screencopy_manager_v1
 * @section page_iface_zwlr_screencopy_manager_v1_desc Description
 *
 * This object is a manager which offers requests to start capturing from a
 * source.
 * @section page_iface_zwlr_screencopy_manager_v1_api API
 * See @ref iface_zwlr_screencopy_manager_v1.
 */
/* *
 * @defgroup iface_zwlr_screencopy_manager_v1 The zwlr_screencopy_manager_v1 interface
 *
 * This object is a manager which offers requests to start capturing from a
 * source.
 */
    #[no_mangle]
    static zwlr_screencopy_manager_v1_interface: wl_interface;
    /* *
 * @page page_iface_zwlr_screencopy_frame_v1 zwlr_screencopy_frame_v1
 * @section page_iface_zwlr_screencopy_frame_v1_desc Description
 *
 * This object represents a single frame.
 *
 * When created, a "buffer" event will be sent. The client will then be able
 * to send a "copy" request. If the capture is successful, the compositor
 * will send a "flags" followed by a "ready" event.
 *
 * If the capture failed, the "failed" event is sent. This can happen anytime
 * before the "ready" event.
 *
 * Once either a "ready" or a "failed" event is received, the client should
 * destroy the frame.
 * @section page_iface_zwlr_screencopy_frame_v1_api API
 * See @ref iface_zwlr_screencopy_frame_v1.
 */
/* *
 * @defgroup iface_zwlr_screencopy_frame_v1 The zwlr_screencopy_frame_v1 interface
 *
 * This object represents a single frame.
 *
 * When created, a "buffer" event will be sent. The client will then be able
 * to send a "copy" request. If the capture is successful, the compositor
 * will send a "flags" followed by a "ready" event.
 *
 * If the capture failed, the "failed" event is sent. This can happen anytime
 * before the "ready" event.
 *
 * Once either a "ready" or a "failed" event is received, the client should
 * destroy the frame.
 */
    #[no_mangle]
    static zwlr_screencopy_frame_v1_interface: wl_interface;
}
pub type __int32_t = libc::c_int;
pub type __uint32_t = libc::c_uint;
pub type __mode_t = libc::c_uint;
pub type __off_t = libc::c_long;
pub type __off64_t = libc::c_long;
pub type mode_t = __mode_t;
pub type size_t = libc::c_ulong;
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct _IO_FILE {
    pub _flags: libc::c_int,
    pub _IO_read_ptr: *mut libc::c_char,
    pub _IO_read_end: *mut libc::c_char,
    pub _IO_read_base: *mut libc::c_char,
    pub _IO_write_base: *mut libc::c_char,
    pub _IO_write_ptr: *mut libc::c_char,
    pub _IO_write_end: *mut libc::c_char,
    pub _IO_buf_base: *mut libc::c_char,
    pub _IO_buf_end: *mut libc::c_char,
    pub _IO_save_base: *mut libc::c_char,
    pub _IO_backup_base: *mut libc::c_char,
    pub _IO_save_end: *mut libc::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: libc::c_int,
    pub _flags2: libc::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: libc::c_ushort,
    pub _vtable_offset: libc::c_schar,
    pub _shortbuf: [libc::c_char; 1],
    pub _lock: *mut libc::c_void,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut libc::c_void,
    pub __pad5: size_t,
    pub _mode: libc::c_int,
    pub _unused2: [libc::c_char; 20],
}
pub type _IO_lock_t = ();
pub type FILE = _IO_FILE;
pub type png_byte = libc::c_uchar;
pub type png_uint_32 = libc::c_uint;
pub type png_voidp = *mut libc::c_void;
pub type png_bytep = *mut png_byte;
pub type png_const_bytep = *const png_byte;
pub type png_const_charp = *const libc::c_char;
pub type png_FILE_p = *mut FILE;
/* Basic control structions.  Read libpng-manual.txt or libpng.3 for more info.
 *
 * png_struct is the cache of information used while reading or writing a single
 * PNG file.  One of these is always required, although the simplified API
 * (below) hides the creation and destruction of it.
 */
pub type png_struct = png_struct_def;
pub type png_structp = *mut png_struct;
pub type png_structpp = *mut *mut png_struct;
/* png_info contains information read from or to be written to a PNG file.  One
 * or more of these must exist while reading or creating a PNG file.  The
 * information is not used by libpng during read but is used to control what
 * gets written when a PNG file is created.  "png_get_" function calls read
 * information during read and "png_set_" functions calls write information
 * when creating a PNG.
 * been moved into a separate header file that is not accessible to
 * applications.  Read libpng-manual.txt or libpng.3 for more info.
 */
pub type png_info = png_info_def;
pub type png_infop = *mut png_info;
pub type png_infopp = *mut *mut png_info;
/* Types with names ending 'p' are pointer types.  The corresponding types with
 * names ending 'rp' are identical pointer types except that the pointer is
 * marked 'restrict', which means that it is the only pointer to the object
 * passed to the function.  Applications should not use the 'restrict' types;
 * it is always valid to pass 'p' to a pointer with a function argument of the
 * corresponding 'rp' type.  Different compilers have different rules with
 * regard to type matching in the presence of 'restrict'.  For backward
 * compatibility libpng callbacks never have 'restrict' in their parameters and,
 * consequentially, writing portable application code is extremely difficult if
 * an attempt is made to use 'restrict'.
 */
pub type png_structrp = *mut png_struct;
pub type png_const_structrp = *const png_struct;
pub type png_inforp = *mut png_info;
pub type png_const_inforp = *const png_info;
/* These are the function types for the I/O functions and for the functions
 * that allow the user to override the default I/O functions with his or her
 * own.  The png_error_ptr type should match that of user-supplied warning
 * and error functions, while the png_rw_ptr type should match that of the
 * user read/write data functions.  Note that the 'write' function must not
 * modify the buffer it is passed. The 'read' function, on the other hand, is
 * expected to return the read data in the buffer.
 */
pub type png_error_ptr
    =
    Option<unsafe extern "C" fn(_: png_structp, _: png_const_charp) -> ()>;
pub type int32_t = __int32_t;
pub type uint32_t = __uint32_t;
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wl_message {
    pub name: *const libc::c_char,
    pub signature: *const libc::c_char,
    pub types: *mut *const wl_interface,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wl_interface {
    pub name: *const libc::c_char,
    pub version: libc::c_int,
    pub method_count: libc::c_int,
    pub methods: *const wl_message,
    pub event_count: libc::c_int,
    pub events: *const wl_message,
}
/*
 * Copyright © 2008 Kristian Høgsberg
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct format {
    pub wl_format: wl_shm_format,
    pub is_bgr: bool,
}
pub type wl_shm_format = libc::c_uint;
pub const WL_SHM_FORMAT_YVU444: wl_shm_format = 875714137;
pub const WL_SHM_FORMAT_YUV444: wl_shm_format = 875713881;
pub const WL_SHM_FORMAT_YVU422: wl_shm_format = 909203033;
pub const WL_SHM_FORMAT_YUV422: wl_shm_format = 909202777;
pub const WL_SHM_FORMAT_YVU420: wl_shm_format = 842094169;
pub const WL_SHM_FORMAT_YUV420: wl_shm_format = 842093913;
pub const WL_SHM_FORMAT_YVU411: wl_shm_format = 825316953;
pub const WL_SHM_FORMAT_YUV411: wl_shm_format = 825316697;
pub const WL_SHM_FORMAT_YVU410: wl_shm_format = 961893977;
pub const WL_SHM_FORMAT_YUV410: wl_shm_format = 961959257;
pub const WL_SHM_FORMAT_NV61: wl_shm_format = 825644622;
pub const WL_SHM_FORMAT_NV16: wl_shm_format = 909203022;
pub const WL_SHM_FORMAT_NV21: wl_shm_format = 825382478;
pub const WL_SHM_FORMAT_NV12: wl_shm_format = 842094158;
pub const WL_SHM_FORMAT_AYUV: wl_shm_format = 1448433985;
pub const WL_SHM_FORMAT_VYUY: wl_shm_format = 1498765654;
pub const WL_SHM_FORMAT_UYVY: wl_shm_format = 1498831189;
pub const WL_SHM_FORMAT_YVYU: wl_shm_format = 1431918169;
pub const WL_SHM_FORMAT_YUYV: wl_shm_format = 1448695129;
pub const WL_SHM_FORMAT_BGRA1010102: wl_shm_format = 808665410;
pub const WL_SHM_FORMAT_RGBA1010102: wl_shm_format = 808665426;
pub const WL_SHM_FORMAT_ABGR2101010: wl_shm_format = 808665665;
pub const WL_SHM_FORMAT_ARGB2101010: wl_shm_format = 808669761;
pub const WL_SHM_FORMAT_BGRX1010102: wl_shm_format = 808671298;
pub const WL_SHM_FORMAT_RGBX1010102: wl_shm_format = 808671314;
pub const WL_SHM_FORMAT_XBGR2101010: wl_shm_format = 808665688;
pub const WL_SHM_FORMAT_XRGB2101010: wl_shm_format = 808669784;
pub const WL_SHM_FORMAT_BGRA8888: wl_shm_format = 875708738;
pub const WL_SHM_FORMAT_RGBA8888: wl_shm_format = 875708754;
pub const WL_SHM_FORMAT_ABGR8888: wl_shm_format = 875708993;
pub const WL_SHM_FORMAT_BGRX8888: wl_shm_format = 875714626;
pub const WL_SHM_FORMAT_RGBX8888: wl_shm_format = 875714642;
pub const WL_SHM_FORMAT_XBGR8888: wl_shm_format = 875709016;
pub const WL_SHM_FORMAT_BGR888: wl_shm_format = 875710274;
pub const WL_SHM_FORMAT_RGB888: wl_shm_format = 875710290;
pub const WL_SHM_FORMAT_BGR565: wl_shm_format = 909199170;
pub const WL_SHM_FORMAT_RGB565: wl_shm_format = 909199186;
pub const WL_SHM_FORMAT_BGRA5551: wl_shm_format = 892420418;
pub const WL_SHM_FORMAT_RGBA5551: wl_shm_format = 892420434;
pub const WL_SHM_FORMAT_ABGR1555: wl_shm_format = 892420673;
pub const WL_SHM_FORMAT_ARGB1555: wl_shm_format = 892424769;
pub const WL_SHM_FORMAT_BGRX5551: wl_shm_format = 892426306;
pub const WL_SHM_FORMAT_RGBX5551: wl_shm_format = 892426322;
pub const WL_SHM_FORMAT_XBGR1555: wl_shm_format = 892420696;
pub const WL_SHM_FORMAT_XRGB1555: wl_shm_format = 892424792;
pub const WL_SHM_FORMAT_BGRA4444: wl_shm_format = 842088770;
pub const WL_SHM_FORMAT_RGBA4444: wl_shm_format = 842088786;
pub const WL_SHM_FORMAT_ABGR4444: wl_shm_format = 842089025;
pub const WL_SHM_FORMAT_ARGB4444: wl_shm_format = 842093121;
pub const WL_SHM_FORMAT_BGRX4444: wl_shm_format = 842094658;
pub const WL_SHM_FORMAT_RGBX4444: wl_shm_format = 842094674;
pub const WL_SHM_FORMAT_XBGR4444: wl_shm_format = 842089048;
pub const WL_SHM_FORMAT_XRGB4444: wl_shm_format = 842093144;
pub const WL_SHM_FORMAT_BGR233: wl_shm_format = 944916290;
pub const WL_SHM_FORMAT_RGB332: wl_shm_format = 943867730;
pub const WL_SHM_FORMAT_C8: wl_shm_format = 538982467;
pub const WL_SHM_FORMAT_XRGB8888: wl_shm_format = 1;
pub const WL_SHM_FORMAT_ARGB8888: wl_shm_format = 0;
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wl_registry_listener {
    pub global: Option<unsafe extern "C" fn(_: *mut libc::c_void,
                                            _: *mut wl_registry, _: uint32_t,
                                            _: *const libc::c_char,
                                            _: uint32_t) -> ()>,
    pub global_remove: Option<unsafe extern "C" fn(_: *mut libc::c_void,
                                                   _: *mut wl_registry,
                                                   _: uint32_t) -> ()>,
}
/* ZWLR_SCREENCOPY_FRAME_V1_ERROR_ENUM */
pub type zwlr_screencopy_frame_v1_flags = libc::c_uint;
/* *
	 * contents are y-inverted
	 */
pub const ZWLR_SCREENCOPY_FRAME_V1_FLAGS_Y_INVERT:
          zwlr_screencopy_frame_v1_flags =
    1;
/* ZWLR_SCREENCOPY_FRAME_V1_FLAGS_ENUM */
/* *
 * @ingroup iface_zwlr_screencopy_frame_v1
 * @struct zwlr_screencopy_frame_v1_listener
 */
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct zwlr_screencopy_frame_v1_listener {
    pub buffer: Option<unsafe extern "C" fn(_: *mut libc::c_void,
                                            _: *mut zwlr_screencopy_frame_v1,
                                            _: uint32_t, _: uint32_t,
                                            _: uint32_t, _: uint32_t) -> ()>,
    pub flags: Option<unsafe extern "C" fn(_: *mut libc::c_void,
                                           _: *mut zwlr_screencopy_frame_v1,
                                           _: uint32_t) -> ()>,
    pub ready: Option<unsafe extern "C" fn(_: *mut libc::c_void,
                                           _: *mut zwlr_screencopy_frame_v1,
                                           _: uint32_t, _: uint32_t,
                                           _: uint32_t) -> ()>,
    pub failed: Option<unsafe extern "C" fn(_: *mut libc::c_void,
                                            _: *mut zwlr_screencopy_frame_v1)
                           -> ()>,
    pub damage: Option<unsafe extern "C" fn(_: *mut libc::c_void,
                                            _: *mut zwlr_screencopy_frame_v1,
                                            _: uint32_t, _: uint32_t,
                                            _: uint32_t, _: uint32_t) -> ()>,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct C2RustUnnamed {
    pub wl_buffer: *mut wl_buffer,
    pub data: *mut libc::c_void,
    pub format: wl_shm_format,
    pub width: libc::c_int,
    pub height: libc::c_int,
    pub stride: libc::c_int,
    pub y_invert: bool,
}
#[inline]
unsafe extern "C" fn wl_display_get_registry(mut wl_display: *mut wl_display)
 -> *mut wl_registry {
    let mut registry: *mut wl_proxy = 0 as *mut wl_proxy;
    registry =
        wl_proxy_marshal_constructor(wl_display as *mut wl_proxy,
                                     1i32 as uint32_t,
                                     &wl_registry_interface as
                                         *const wl_interface,
                                     0 as *mut libc::c_void);
    return registry as *mut wl_registry;
}
#[inline]
unsafe extern "C" fn wl_registry_add_listener(mut wl_registry:
                                                  *mut wl_registry,
                                              mut listener:
                                                  *const wl_registry_listener,
                                              mut data: *mut libc::c_void)
 -> libc::c_int {
    return wl_proxy_add_listener(wl_registry as *mut wl_proxy,
                                 listener as
                                     *mut Option<unsafe extern "C" fn()
                                                     -> ()>, data);
}
#[inline]
unsafe extern "C" fn wl_registry_bind(mut wl_registry: *mut wl_registry,
                                      mut name: uint32_t,
                                      mut interface: *const wl_interface,
                                      mut version: uint32_t)
 -> *mut libc::c_void {
    let mut id: *mut wl_proxy = 0 as *mut wl_proxy;
    id =
        wl_proxy_marshal_constructor_versioned(wl_registry as *mut wl_proxy,
                                               0i32 as uint32_t, interface,
                                               version, name,
                                               (*interface).name, version,
                                               0 as *mut libc::c_void);
    return id as *mut libc::c_void;
}
#[inline]
unsafe extern "C" fn wl_shm_pool_create_buffer(mut wl_shm_pool:
                                                   *mut wl_shm_pool,
                                               mut offset: int32_t,
                                               mut width: int32_t,
                                               mut height: int32_t,
                                               mut stride: int32_t,
                                               mut format: uint32_t)
 -> *mut wl_buffer {
    let mut id: *mut wl_proxy = 0 as *mut wl_proxy;
    id =
        wl_proxy_marshal_constructor(wl_shm_pool as *mut wl_proxy,
                                     0i32 as uint32_t,
                                     &wl_buffer_interface as
                                         *const wl_interface,
                                     0 as *mut libc::c_void, offset, width,
                                     height, stride, format);
    return id as *mut wl_buffer;
}
#[inline]
unsafe extern "C" fn wl_shm_pool_destroy(mut wl_shm_pool: *mut wl_shm_pool) {
    wl_proxy_marshal(wl_shm_pool as *mut wl_proxy, 1i32 as uint32_t);
    wl_proxy_destroy(wl_shm_pool as *mut wl_proxy);
}
#[inline]
unsafe extern "C" fn wl_shm_create_pool(mut wl_shm: *mut wl_shm,
                                        mut fd: int32_t, mut size: int32_t)
 -> *mut wl_shm_pool {
    let mut id: *mut wl_proxy = 0 as *mut wl_proxy;
    id =
        wl_proxy_marshal_constructor(wl_shm as *mut wl_proxy,
                                     0i32 as uint32_t,
                                     &wl_shm_pool_interface as
                                         *const wl_interface,
                                     0 as *mut libc::c_void, fd, size);
    return id as *mut wl_shm_pool;
}
#[inline]
unsafe extern "C" fn wl_buffer_destroy(mut wl_buffer: *mut wl_buffer) {
    wl_proxy_marshal(wl_buffer as *mut wl_proxy, 0i32 as uint32_t);
    wl_proxy_destroy(wl_buffer as *mut wl_proxy);
}
/* *
 * @ingroup iface_zwlr_screencopy_manager_v1
 *
 * Capture the next frame of an entire output.
 */
#[inline]
unsafe extern "C" fn zwlr_screencopy_manager_v1_capture_output(mut zwlr_screencopy_manager_v1:
                                                                   *mut zwlr_screencopy_manager_v1,
                                                               mut overlay_cursor:
                                                                   int32_t,
                                                               mut output_0:
                                                                   *mut wl_output)
 -> *mut zwlr_screencopy_frame_v1 {
    let mut frame: *mut wl_proxy = 0 as *mut wl_proxy;
    frame =
        wl_proxy_marshal_constructor(zwlr_screencopy_manager_v1 as
                                         *mut wl_proxy, 0i32 as uint32_t,
                                     &zwlr_screencopy_frame_v1_interface as
                                         *const wl_interface,
                                     0 as *mut libc::c_void, overlay_cursor,
                                     output_0);
    return frame as *mut zwlr_screencopy_frame_v1;
}
/* *
 * @ingroup iface_zwlr_screencopy_frame_v1
 */
#[inline]
unsafe extern "C" fn zwlr_screencopy_frame_v1_add_listener(mut zwlr_screencopy_frame_v1:
                                                               *mut zwlr_screencopy_frame_v1,
                                                           mut listener:
                                                               *const zwlr_screencopy_frame_v1_listener,
                                                           mut data:
                                                               *mut libc::c_void)
 -> libc::c_int {
    return wl_proxy_add_listener(zwlr_screencopy_frame_v1 as *mut wl_proxy,
                                 listener as
                                     *mut Option<unsafe extern "C" fn()
                                                     -> ()>, data);
}
/* *
 * @ingroup iface_zwlr_screencopy_frame_v1
 *
 * Copy the frame to the supplied buffer. The buffer must have a the
 * correct size, see zwlr_screencopy_frame_v1.buffer. The buffer needs to
 * have a supported format.
 *
 * If the frame is successfully copied, a "flags" and a "ready" events are
 * sent. Otherwise, a "failed" event is sent.
 */
#[inline]
unsafe extern "C" fn zwlr_screencopy_frame_v1_copy(mut zwlr_screencopy_frame_v1:
                                                       *mut zwlr_screencopy_frame_v1,
                                                   mut buffer_0:
                                                       *mut wl_buffer) {
    wl_proxy_marshal(zwlr_screencopy_frame_v1 as *mut wl_proxy,
                     0i32 as uint32_t, buffer_0);
}
static mut shm: *mut wl_shm = 0 as *const wl_shm as *mut wl_shm;
static mut screencopy_manager: *mut zwlr_screencopy_manager_v1 =
    0 as *const zwlr_screencopy_manager_v1 as *mut zwlr_screencopy_manager_v1;
static mut output: *mut wl_output = 0 as *const wl_output as *mut wl_output;
static mut buffer: C2RustUnnamed =
    C2RustUnnamed{wl_buffer: 0 as *const wl_buffer as *mut wl_buffer,
                  data: 0 as *const libc::c_void as *mut libc::c_void,
                  format: WL_SHM_FORMAT_ARGB8888,
                  width: 0,
                  height: 0,
                  stride: 0,
                  y_invert: false,};
#[no_mangle]
pub static mut buffer_copy_done: bool = 0i32 != 0;
// wl_shm_format describes little-endian formats, libpng uses big-endian
// formats (so Wayland's ABGR is libpng's RGBA).
static mut formats: [format; 4] =
    [{
         let mut init =
             format{wl_format: WL_SHM_FORMAT_XRGB8888, is_bgr: 1i32 != 0,};
         init
     },
     {
         let mut init =
             format{wl_format: WL_SHM_FORMAT_ARGB8888, is_bgr: 1i32 != 0,};
         init
     },
     {
         let mut init =
             format{wl_format: WL_SHM_FORMAT_XBGR8888, is_bgr: 0i32 != 0,};
         init
     },
     {
         let mut init =
             format{wl_format: WL_SHM_FORMAT_ABGR8888, is_bgr: 0i32 != 0,};
         init
     }];
unsafe extern "C" fn create_shm_buffer(mut fmt: wl_shm_format,
                                       mut width: libc::c_int,
                                       mut height: libc::c_int,
                                       mut stride: libc::c_int,
                                       mut data_out: *mut *mut libc::c_void)
 -> *mut wl_buffer {
    let mut size: libc::c_int = stride * height;
    let shm_name: [libc::c_char; 20] =
        *::std::mem::transmute::<&[u8; 20],
                                 &[libc::c_char; 20]>(b"/wlroots-screencopy\x00");
    let mut fd: libc::c_int =
        shm_open(shm_name.as_ptr(), 0o2i32 | 0o100i32 | 0o200i32,
                 (0o400i32 | 0o200i32) as mode_t);
    if fd < 0i32 {
        fprintf(stderr,
                b"shm_open failed\n\x00" as *const u8 as *const libc::c_char);
        return 0 as *mut wl_buffer
    }
    shm_unlink(shm_name.as_ptr());
    let mut ret: libc::c_int = 0;
    loop 
         // No-op
         {
        ret = ftruncate(fd, size as __off64_t);
        if !(ret == 4i32) { break ; }
    }
    if ret < 0i32 {
        close(fd);
        fprintf(stderr,
                b"ftruncate failed\n\x00" as *const u8 as
                    *const libc::c_char);
        return 0 as *mut wl_buffer
    }
    let mut data: *mut libc::c_void =
        mmap(0 as *mut libc::c_void, size as size_t, 0x1i32 | 0x2i32, 0x1i32,
             fd, 0i32 as __off64_t);
    if data == -1i32 as *mut libc::c_void {
        fprintf(stderr,
                b"mmap failed: %m\n\x00" as *const u8 as *const libc::c_char);
        close(fd);
        return 0 as *mut wl_buffer
    }
    let mut pool: *mut wl_shm_pool = wl_shm_create_pool(shm, fd, size);
    close(fd);
    let mut buffer_0: *mut wl_buffer =
        wl_shm_pool_create_buffer(pool, 0i32, width, height, stride,
                                  fmt as uint32_t);
    wl_shm_pool_destroy(pool);
    *data_out = data;
    return buffer_0;
}
unsafe extern "C" fn frame_handle_buffer(mut data: *mut libc::c_void,
                                         mut frame:
                                             *mut zwlr_screencopy_frame_v1,
                                         mut format: uint32_t,
                                         mut width: uint32_t,
                                         mut height: uint32_t,
                                         mut stride: uint32_t) {
    buffer.format = format as wl_shm_format;
    buffer.width = width as libc::c_int;
    buffer.height = height as libc::c_int;
    buffer.stride = stride as libc::c_int;
    buffer.wl_buffer =
        create_shm_buffer(format as wl_shm_format, width as libc::c_int,
                          height as libc::c_int, stride as libc::c_int,
                          &mut buffer.data);
    if buffer.wl_buffer.is_null() {
        fprintf(stderr,
                b"failed to create buffer\n\x00" as *const u8 as
                    *const libc::c_char);
        exit(1i32);
    }
    zwlr_screencopy_frame_v1_copy(frame, buffer.wl_buffer);
}
unsafe extern "C" fn frame_handle_flags(mut data: *mut libc::c_void,
                                        mut frame:
                                            *mut zwlr_screencopy_frame_v1,
                                        mut flags: uint32_t) {
    buffer.y_invert =
        flags &
            ZWLR_SCREENCOPY_FRAME_V1_FLAGS_Y_INVERT as libc::c_int as
                libc::c_uint != 0;
}
unsafe extern "C" fn frame_handle_ready(mut data: *mut libc::c_void,
                                        mut frame:
                                            *mut zwlr_screencopy_frame_v1,
                                        mut tv_sec_hi: uint32_t,
                                        mut tv_sec_lo: uint32_t,
                                        mut tv_nsec: uint32_t) {
    buffer_copy_done = 1i32 != 0;
}
unsafe extern "C" fn frame_handle_failed(mut data: *mut libc::c_void,
                                         mut frame:
                                             *mut zwlr_screencopy_frame_v1) {
    fprintf(stderr,
            b"failed to copy frame\n\x00" as *const u8 as
                *const libc::c_char);
    exit(1i32);
}
static mut frame_listener: zwlr_screencopy_frame_v1_listener =
    unsafe {
        {
            let mut init =
                zwlr_screencopy_frame_v1_listener{buffer:
                                                      Some(frame_handle_buffer
                                                               as
                                                               unsafe extern "C" fn(_:
                                                                                        *mut libc::c_void,
                                                                                    _:
                                                                                        *mut zwlr_screencopy_frame_v1,
                                                                                    _:
                                                                                        uint32_t,
                                                                                    _:
                                                                                        uint32_t,
                                                                                    _:
                                                                                        uint32_t,
                                                                                    _:
                                                                                        uint32_t)
                                                                   -> ()),
                                                  flags:
                                                      Some(frame_handle_flags
                                                               as
                                                               unsafe extern "C" fn(_:
                                                                                        *mut libc::c_void,
                                                                                    _:
                                                                                        *mut zwlr_screencopy_frame_v1,
                                                                                    _:
                                                                                        uint32_t)
                                                                   -> ()),
                                                  ready:
                                                      Some(frame_handle_ready
                                                               as
                                                               unsafe extern "C" fn(_:
                                                                                        *mut libc::c_void,
                                                                                    _:
                                                                                        *mut zwlr_screencopy_frame_v1,
                                                                                    _:
                                                                                        uint32_t,
                                                                                    _:
                                                                                        uint32_t,
                                                                                    _:
                                                                                        uint32_t)
                                                                   -> ()),
                                                  failed:
                                                      Some(frame_handle_failed
                                                               as
                                                               unsafe extern "C" fn(_:
                                                                                        *mut libc::c_void,
                                                                                    _:
                                                                                        *mut zwlr_screencopy_frame_v1)
                                                                   -> ()),
                                                  damage: None,};
            init
        }
    };
unsafe extern "C" fn handle_global(mut data: *mut libc::c_void,
                                   mut registry: *mut wl_registry,
                                   mut name: uint32_t,
                                   mut interface: *const libc::c_char,
                                   mut version: uint32_t) {
    if strcmp(interface, wl_output_interface.name) == 0i32 && output.is_null()
       {
        output =
            wl_registry_bind(registry, name, &wl_output_interface,
                             1i32 as uint32_t) as *mut wl_output
    } else if strcmp(interface, wl_shm_interface.name) == 0i32 {
        shm =
            wl_registry_bind(registry, name, &wl_shm_interface,
                             1i32 as uint32_t) as *mut wl_shm
    } else if strcmp(interface, zwlr_screencopy_manager_v1_interface.name) ==
                  0i32 {
        screencopy_manager =
            wl_registry_bind(registry, name,
                             &zwlr_screencopy_manager_v1_interface,
                             1i32 as uint32_t) as
                *mut zwlr_screencopy_manager_v1
    };
}
unsafe extern "C" fn handle_global_remove(mut data: *mut libc::c_void,
                                          mut registry: *mut wl_registry,
                                          mut name: uint32_t) {
    // Who cares?
}
static mut registry_listener: wl_registry_listener =
    unsafe {
        {
            let mut init =
                wl_registry_listener{global:
                                         Some(handle_global as
                                                  unsafe extern "C" fn(_:
                                                                           *mut libc::c_void,
                                                                       _:
                                                                           *mut wl_registry,
                                                                       _:
                                                                           uint32_t,
                                                                       _:
                                                                           *const libc::c_char,
                                                                       _:
                                                                           uint32_t)
                                                      -> ()),
                                     global_remove:
                                         Some(handle_global_remove as
                                                  unsafe extern "C" fn(_:
                                                                           *mut libc::c_void,
                                                                       _:
                                                                           *mut wl_registry,
                                                                       _:
                                                                           uint32_t)
                                                      -> ()),};
            init
        }
    };
unsafe extern "C" fn write_image(mut filename: *mut libc::c_char,
                                 mut wl_fmt: wl_shm_format,
                                 mut width: libc::c_int,
                                 mut height: libc::c_int,
                                 mut stride: libc::c_int, mut y_invert: bool,
                                 mut data: png_bytep) {
    let mut fmt: *const format = 0 as *const format;
    let mut i: size_t = 0i32 as size_t;
    while i <
              (::std::mem::size_of::<[format; 4]>() as
                   libc::c_ulong).wrapping_div(::std::mem::size_of::<format>()
                                                   as libc::c_ulong) {
        if formats[i as usize].wl_format as libc::c_uint ==
               wl_fmt as libc::c_uint {
            fmt = &*formats.as_ptr().offset(i as isize) as *const format;
            break ;
        } else { i = i.wrapping_add(1) }
    }
    if fmt.is_null() {
        fprintf(stderr,
                b"unsupported format %u\n\x00" as *const u8 as
                    *const libc::c_char, wl_fmt as libc::c_uint);
        exit(1i32);
    }
    let mut f: *mut FILE =
        fopen(filename, b"wb\x00" as *const u8 as *const libc::c_char);
    if f.is_null() {
        fprintf(stderr,
                b"failed to open output file\n\x00" as *const u8 as
                    *const libc::c_char);
        exit(1i32);
    }
    let mut png: png_structp =
        png_create_write_struct(b"1.6.37\x00" as *const u8 as
                                    *const libc::c_char,
                                0 as *mut libc::c_void, None, None);
    let mut info: png_infop =
        png_create_info_struct(png as *const png_struct);
    png_init_io(png, f);
    png_set_IHDR(png as *const png_struct, info, width as png_uint_32,
                 height as png_uint_32, 8i32, 2i32 | 4i32, 0i32, 0i32, 0i32);
    if (*fmt).is_bgr { png_set_bgr(png); }
    png_write_info(png, info as *const png_info);
    let mut i_0: size_t = 0i32 as size_t;
    while i_0 < height as size_t {
        let mut row: png_bytep = 0 as *mut png_byte;
        if y_invert {
            row =
                data.offset((height as
                                 libc::c_ulong).wrapping_sub(i_0).wrapping_sub(1i32
                                                                                   as
                                                                                   libc::c_ulong).wrapping_mul(stride
                                                                                                                   as
                                                                                                                   libc::c_ulong)
                                as isize)
        } else {
            row =
                data.offset(i_0.wrapping_mul(stride as libc::c_ulong) as
                                isize)
        }
        png_write_row(png, row as png_const_bytep);
        i_0 = i_0.wrapping_add(1)
    }
    png_write_end(png, 0 as *mut png_info);
    png_destroy_write_struct(&mut png, &mut info);
    fclose(f);
}
unsafe fn main_0(mut argc: libc::c_int, mut argv: *mut *mut libc::c_char)
 -> libc::c_int {
    let mut display: *mut wl_display =
        wl_display_connect(0 as *const libc::c_char);
    if display.is_null() {
        fprintf(stderr,
                b"failed to create display: %m\n\x00" as *const u8 as
                    *const libc::c_char);
        return 1i32
    }
    let mut registry: *mut wl_registry = wl_display_get_registry(display);
    wl_registry_add_listener(registry, &registry_listener,
                             0 as *mut libc::c_void);
    wl_display_dispatch(display);
    wl_display_roundtrip(display);
    if shm.is_null() {
        fprintf(stderr,
                b"compositor is missing wl_shm\n\x00" as *const u8 as
                    *const libc::c_char);
        return 1i32
    }
    if screencopy_manager.is_null() {
        fprintf(stderr,
                b"compositor doesn\'t support wlr-screencopy-unstable-v1\n\x00"
                    as *const u8 as *const libc::c_char);
        return 1i32
    }
    if output.is_null() {
        fprintf(stderr,
                b"no output available\n\x00" as *const u8 as
                    *const libc::c_char);
        return 1i32
    }
    let mut frame: *mut zwlr_screencopy_frame_v1 =
        zwlr_screencopy_manager_v1_capture_output(screencopy_manager, 0i32,
                                                  output);
    zwlr_screencopy_frame_v1_add_listener(frame, &frame_listener,
                                          0 as *mut libc::c_void);
    // This space is intentionally left blank
    while !buffer_copy_done && wl_display_dispatch(display) != -1i32 { }
    let mut png: [libc::c_char; 23] =
        *::std::mem::transmute::<&[u8; 23],
                                 &mut [libc::c_char; 23]>(b"wayland-screenshot.png\x00");
    write_image(png.as_mut_ptr(), buffer.format, buffer.width, buffer.height,
                buffer.stride, buffer.y_invert, buffer.data as png_bytep);
    wl_buffer_destroy(buffer.wl_buffer);
    return 0i32;
}
#[main]
pub fn main() {
    let mut args: Vec<*mut libc::c_char> = Vec::new();
    for arg in ::std::env::args() {
        args.push(::std::ffi::CString::new(arg).expect("Failed to convert argument into CString.").into_raw());
    };
    args.push(::std::ptr::null_mut());
    unsafe {
        ::std::process::exit(main_0((args.len() - 1) as libc::c_int,
                                    args.as_mut_ptr() as
                                        *mut *mut libc::c_char) as i32)
    }
}
