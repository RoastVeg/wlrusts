use libc;
extern "C" {
    pub type wl_event_loop;
    pub type wl_event_source;
    pub type wl_display;
    pub type wl_client;
    pub type wl_global;
    pub type udev;
    pub type udev_monitor;
    pub type session_impl;
    pub type wlr_renderer_impl;
    pub type xkb_keymap;
    pub type xkb_state;
    pub type wlr_keyboard_impl;
    pub type wlr_keyboard_group;
    pub type wlr_pointer_impl;
    pub type wlr_tablet_pad_impl;
    pub type wlr_tablet_impl;
    pub type wlr_touch_impl;
    pub type wlr_switch_impl;
    /* Generated by wayland-scanner 1.17.0 */
    /* *
 * @page page_linux_dmabuf_unstable_v1 The linux_dmabuf_unstable_v1 protocol
 * @section page_ifaces_linux_dmabuf_unstable_v1 Interfaces
 * - @subpage page_iface_zwp_linux_dmabuf_v1 - factory for creating dmabuf-based wl_buffers
 * - @subpage page_iface_zwp_linux_buffer_params_v1 - parameters for creating a dmabuf-based wl_buffer
 * @section page_copyright_linux_dmabuf_unstable_v1 Copyright
 * <pre>
 *
 * Copyright © 2014, 2015 Collabora, Ltd.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 * </pre>
 */
    pub type wl_buffer;
    pub type wl_callback;
    pub type wl_compositor;
    pub type wl_keyboard;
    /* Generated by wayland-scanner 1.17.0 */
    /* *
 * @page page_pointer_gestures_unstable_v1 The pointer_gestures_unstable_v1 protocol
 * @section page_ifaces_pointer_gestures_unstable_v1 Interfaces
 * - @subpage page_iface_zwp_pointer_gestures_v1 - touchpad gestures
 * - @subpage page_iface_zwp_pointer_gesture_swipe_v1 - a swipe gesture object
 * - @subpage page_iface_zwp_pointer_gesture_pinch_v1 - a pinch gesture object
 */
    /* Generated by wayland-scanner 1.17.0 */
    /* *
 * @page page_relative_pointer_unstable_v1 The relative_pointer_unstable_v1 protocol
 * protocol for relative pointer motion events
 *
 * @section page_desc_relative_pointer_unstable_v1 Description
 *
 * This protocol specifies a set of interfaces used for making clients able to
 * receive relative pointer events not obstructed by barriers (such as the
 * monitor edge or other pointer barriers).
 *
 * To start receiving relative pointer events, a client must first bind the
 * global interface "wp_relative_pointer_manager" which, if a compositor
 * supports relative pointer motion events, is exposed by the registry. After
 * having created the relative pointer manager proxy object, the client uses
 * it to create the actual relative pointer object using the
 * "get_relative_pointer" request given a wl_pointer. The relative pointer
 * motion events will then, when applicable, be transmitted via the proxy of
 * the newly created relative pointer object. See the documentation of the
 * relative pointer interface for more details.
 *
 * Warning! The protocol described in this file is experimental and backward
 * incompatible changes may be made. Backward compatible changes may be added
 * together with the corresponding interface version bump. Backward
 * incompatible changes are done by bumping the version number in the protocol
 * and interface names and resetting the interface version. Once the protocol
 * is to be declared stable, the 'z' prefix and the version number in the
 * protocol and interface names are removed and the interface version number is
 * reset.
 *
 * @section page_ifaces_relative_pointer_unstable_v1 Interfaces
 * - @subpage page_iface_zwp_relative_pointer_manager_v1 - get relative pointer objects
 * - @subpage page_iface_zwp_relative_pointer_v1 - relative pointer object
 * @section page_copyright_relative_pointer_unstable_v1 Copyright
 * <pre>
 *
 * Copyright © 2014      Jonas Ådahl
 * Copyright © 2015      Red Hat Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 * </pre>
 */
    pub type wl_pointer;
    pub type wl_registry;
    /* Generated by wayland-scanner 1.17.0 */
    /* *
 * @page page_tablet_unstable_v2 The tablet_unstable_v2 protocol
 * Wayland protocol for graphics tablets
 *
 * @section page_desc_tablet_unstable_v2 Description
 *
 * This description provides a high-level overview of the interplay between
 * the interfaces defined this protocol. For details, see the protocol
 * specification.
 *
 * More than one tablet may exist, and device-specifics matter. Tablets are
 * not represented by a single virtual device like wl_pointer. A client
 * binds to the tablet manager object which is just a proxy object. From
 * that, the client requests wp_tablet_manager.get_tablet_seat(wl_seat)
 * and that returns the actual interface that has all the tablets. With
 * this indirection, we can avoid merging wp_tablet into the actual Wayland
 * protocol, a long-term benefit.
 *
 * The wp_tablet_seat sends a "tablet added" event for each tablet
 * connected. That event is followed by descriptive events about the
 * hardware; currently that includes events for name, vid/pid and
 * a wp_tablet.path event that describes a local path. This path can be
 * used to uniquely identify a tablet or get more information through
 * libwacom. Emulated or nested tablets can skip any of those, e.g. a
 * virtual tablet may not have a vid/pid. The sequence of descriptive
 * events is terminated by a wp_tablet.done event to signal that a client
 * may now finalize any initialization for that tablet.
 *
 * Events from tablets require a tool in proximity. Tools are also managed
 * by the tablet seat; a "tool added" event is sent whenever a tool is new
 * to the compositor. That event is followed by a number of descriptive
 * events about the hardware; currently that includes capabilities,
 * hardware id and serial number, and tool type. Similar to the tablet
 * interface, a wp_tablet_tool.done event is sent to terminate that initial
 * sequence.
 *
 * Any event from a tool happens on the wp_tablet_tool interface. When the
 * tool gets into proximity of the tablet, a proximity_in event is sent on
 * the wp_tablet_tool interface, listing the tablet and the surface. That
 * event is followed by a motion event with the coordinates. After that,
 * it's the usual motion, axis, button, etc. events. The protocol's
 * serialisation means events are grouped by wp_tablet_tool.frame events.
 *
 * Two special events (that don't exist in X) are down and up. They signal
 * "tip touching the surface". For tablets without real proximity
 * detection, the sequence is: proximity_in, motion, down, frame.
 *
 * When the tool leaves proximity, a proximity_out event is sent. If any
 * button is still down, a button release event is sent before this
 * proximity event. These button events are sent in the same frame as the
 * proximity event to signal to the client that the buttons were held when
 * the tool left proximity.
 *
 * If the tool moves out of the surface but stays in proximity (i.e.
 * between windows), compositor-specific grab policies apply. This usually
 * means that the proximity-out is delayed until all buttons are released.
 *
 * Moving a tool physically from one tablet to the other has no real effect
 * on the protocol, since we already have the tool object from the "tool
 * added" event. All the information is already there and the proximity
 * events on both tablets are all a client needs to reconstruct what
 * happened.
 *
 * Some extra axes are normalized, i.e. the client knows the range as
 * specified in the protocol (e.g. [0, 65535]), the granularity however is
 * unknown. The current normalized axes are pressure, distance, and slider.
 *
 * Other extra axes are in physical units as specified in the protocol.
 * The current extra axes with physical units are tilt, rotation and
 * wheel rotation.
 *
 * Since tablets work independently of the pointer controlled by the mouse,
 * the focus handling is independent too and controlled by proximity.
 * The wp_tablet_tool.set_cursor request sets a tool-specific cursor.
 * This cursor surface may be the same as the mouse cursor, and it may be
 * the same across tools but it is possible to be more fine-grained. For
 * example, a client may set different cursors for the pen and eraser.
 *
 * Tools are generally independent of tablets and it is
 * compositor-specific policy when a tool can be removed. Common approaches
 * will likely include some form of removing a tool when all tablets the
 * tool was used on are removed.
 *
 * Warning! The protocol described in this file is experimental and
 * backward incompatible changes may be made. Backward compatible changes
 * may be added together with the corresponding interface version bump.
 * Backward incompatible changes are done by bumping the version number in
 * the protocol and interface names and resetting the interface version.
 * Once the protocol is to be declared stable, the 'z' prefix and the
 * version number in the protocol and interface names are removed and the
 * interface version number is reset.
 *
 * @section page_ifaces_tablet_unstable_v2 Interfaces
 * - @subpage page_iface_zwp_tablet_manager_v2 - controller object for graphic tablet devices
 * - @subpage page_iface_zwp_tablet_seat_v2 - controller object for graphic tablet devices of a seat
 * - @subpage page_iface_zwp_tablet_tool_v2 - a physical tablet tool
 * - @subpage page_iface_zwp_tablet_v2 - graphics tablet device
 * - @subpage page_iface_zwp_tablet_pad_ring_v2 - pad ring
 * - @subpage page_iface_zwp_tablet_pad_strip_v2 - pad strip
 * - @subpage page_iface_zwp_tablet_pad_group_v2 - a set of buttons, rings and strips
 * - @subpage page_iface_zwp_tablet_pad_v2 - a set of buttons, rings and strips
 * @section page_copyright_tablet_unstable_v2 Copyright
 * <pre>
 *
 * Copyright 2014 © Stephen "Lyude" Chandler Paul
 * Copyright 2015-2016 © Red Hat, Inc.
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation files
 * (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial
 * portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 * </pre>
 */
    pub type wl_seat;
    pub type wl_surface;
    pub type wlr_texture_impl;
    pub type wlr_surface;
    pub type wl_proxy;
    pub type wl_egl_window;
    pub type zwp_tablet_manager_v2;
    pub type zxdg_toplevel_decoration_v1;
    /* Generated by wayland-scanner 1.17.0 */
    /* *
 * @page page_xdg_decoration_unstable_v1 The xdg_decoration_unstable_v1 protocol
 * @section page_ifaces_xdg_decoration_unstable_v1 Interfaces
 * - @subpage page_iface_zxdg_decoration_manager_v1 - window decoration manager
 * - @subpage page_iface_zxdg_toplevel_decoration_v1 - decoration object for a toplevel surface
 * @section page_copyright_xdg_decoration_unstable_v1 Copyright
 * <pre>
 *
 * Copyright © 2018 Simon Ser
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 * </pre>
 */
    pub type xdg_toplevel;
    pub type xdg_surface;
    pub type zwp_relative_pointer_v1;
    pub type zwp_pointer_gesture_pinch_v1;
    pub type zwp_pointer_gesture_swipe_v1;
    pub type zwp_relative_pointer_manager_v1;
    pub type zwp_linux_dmabuf_v1;
    pub type wp_presentation;
    pub type zwp_pointer_gestures_v1;
    pub type zxdg_decoration_manager_v1;
    pub type xdg_wm_base;
    pub type wlr_wl_tablet_seat;
    #[no_mangle]
    fn __assert_fail(__assertion: *const libc::c_char,
                     __file: *const libc::c_char, __line: libc::c_uint,
                     __function: *const libc::c_char) -> !;
    #[no_mangle]
    fn calloc(_: libc::c_ulong, _: libc::c_ulong) -> *mut libc::c_void;
    #[no_mangle]
    fn free(__ptr: *mut libc::c_void);
    #[no_mangle]
    fn wl_event_source_remove(source: *mut wl_event_source) -> libc::c_int;
    #[no_mangle]
    fn wl_list_init(list: *mut wl_list);
    #[no_mangle]
    fn wl_list_remove(elm: *mut wl_list);
    #[no_mangle]
    fn wl_event_loop_add_fd(loop_0: *mut wl_event_loop, fd: libc::c_int,
                            mask: uint32_t, func: wl_event_loop_fd_func_t,
                            data: *mut libc::c_void) -> *mut wl_event_source;
    #[no_mangle]
    fn wl_display_get_event_loop(display: *mut wl_display)
     -> *mut wl_event_loop;
    #[no_mangle]
    fn wl_display_terminate(display: *mut wl_display);
    #[no_mangle]
    fn wl_display_add_destroy_listener(display: *mut wl_display,
                                       listener: *mut wl_listener);
    #[no_mangle]
    fn wl_event_source_check(source: *mut wl_event_source);
    #[no_mangle]
    fn wlr_drm_format_set_finish(set: *mut wlr_drm_format_set);
    #[no_mangle]
    fn wlr_drm_format_set_add(set: *mut wlr_drm_format_set, format: uint32_t,
                              modifier: uint64_t) -> bool;
    /* *
 * Frees all related EGL resources, makes the context not-current and
 * unbinds a bound wayland display.
 */
    #[no_mangle]
    fn wlr_egl_finish(egl: *mut wlr_egl);
    /* *
 * Initializes common state on a wlr_backend and sets the implementation to the
 * provided wlr_backend_impl reference.
 */
    #[no_mangle]
    fn wlr_backend_init(backend: *mut wlr_backend,
                        impl_0: *const wlr_backend_impl);
    #[no_mangle]
    fn wlr_input_device_destroy(dev: *mut wlr_input_device);
    #[no_mangle]
    static wl_registry_interface: wl_interface;
    #[no_mangle]
    static wl_compositor_interface: wl_interface;
    #[no_mangle]
    static wl_seat_interface: wl_interface;
    #[no_mangle]
    fn wlr_output_destroy(output: *mut wlr_output);
    /* *
 * Defines a scissor box. Only pixels that lie within the scissor box can be
 * modified by drawing functions. Providing a NULL `box` disables the scissor
 * box.
 */
    /* *
 * Renders the requested texture.
 */
    /* *
 * Renders the requested texture using the provided matrix.
 */
    /* *
 * Renders a solid rectangle in the specified color.
 */
    /* *
 * Renders a solid quadrangle in the specified color with the specified matrix.
 */
    /* *
 * Renders a solid ellipse in the specified color.
 */
    /* *
 * Renders a solid ellipse in the specified color with the specified matrix.
 */
    /* *
 * Returns a list of pixel formats supported by this renderer.
 */
    /* *
 * Returns true if this wl_buffer is a wl_drm buffer.
 */
    /* *
 * Gets the width and height of a wl_drm buffer.
 */
    /* *
 * Get the available DMA-BUF formats.
 */
    /* *
 * Reads out of pixels of the currently bound surface into data. `stride` is in
 * bytes.
 *
 * If `flags` is not NULl, the caller indicates that it accepts frame flags
 * defined in `enum wlr_renderer_read_pixels_flags`.
 */
    /* *
 * Checks if a format is supported.
 */
    /* *
 * Destroys this wlr_renderer. Textures must be destroyed separately.
 */
    #[no_mangle]
    fn wlr_renderer_destroy(renderer: *mut wlr_renderer);
    #[no_mangle]
    fn wlr_renderer_autocreate(egl: *mut wlr_egl, platform: EGLenum,
                               remote_display: *mut libc::c_void,
                               config_attribs: *mut EGLint, visual_id: EGLint)
     -> *mut wlr_renderer;
    #[no_mangle]
    fn strcmp(_: *const libc::c_char, _: *const libc::c_char) -> libc::c_int;
    #[no_mangle]
    fn strerror(_: libc::c_int) -> *mut libc::c_char;
    #[no_mangle]
    fn _wlr_log(verbosity: wlr_log_importance, format: *const libc::c_char,
                _: ...);
    #[no_mangle]
    fn __errno_location() -> *mut libc::c_int;
    /* *
 * Creates a new wlr_wl_backend. This backend will be created with no outputs;
 * you must use wlr_wl_output_create to add them.
 *
 * The `remote` argument is the name of the host compositor wayland socket. Set
 * to NULL for the default behaviour (WAYLAND_DISPLAY env variable or wayland-0
 * default)
 */
    /* *
 * Returns the remote wl_display used by the Wayland backend.
 */
    /* *
 * Adds a new output to this backend. You may remove outputs by destroying them.
 * Note that if called before initializing the backend, this will return NULL
 * and your outputs will be created during initialization (and given to you via
 * the output_add signal).
 */
    #[no_mangle]
    fn wlr_wl_output_create(backend: *mut wlr_backend) -> *mut wlr_output;
    #[no_mangle]
    fn wl_display_roundtrip(display: *mut wl_display) -> libc::c_int;
    #[no_mangle]
    fn wl_display_flush(display: *mut wl_display) -> libc::c_int;
    #[no_mangle]
    fn wl_display_dispatch_pending(display: *mut wl_display) -> libc::c_int;
    #[no_mangle]
    fn wl_display_dispatch(display: *mut wl_display) -> libc::c_int;
    #[no_mangle]
    fn wl_display_get_fd(display: *mut wl_display) -> libc::c_int;
    #[no_mangle]
    fn wl_display_disconnect(display: *mut wl_display);
    #[no_mangle]
    fn wl_display_connect(name: *const libc::c_char) -> *mut wl_display;
    #[no_mangle]
    fn wl_proxy_add_listener(proxy: *mut wl_proxy,
                             implementation:
                                 *mut Option<unsafe extern "C" fn() -> ()>,
                             data: *mut libc::c_void) -> libc::c_int;
    #[no_mangle]
    static seat_listener: wl_seat_listener;
    #[no_mangle]
    fn wl_proxy_destroy(proxy: *mut wl_proxy);
    #[no_mangle]
    fn wl_add_tablet_seat(manager: *mut zwp_tablet_manager_v2,
                          seat: *mut wl_seat, backend: *mut wlr_wl_backend)
     -> *mut wlr_wl_tablet_seat;
    #[no_mangle]
    fn create_wl_keyboard(wl_keyboard: *mut wl_keyboard,
                          wl: *mut wlr_wl_backend);
    #[no_mangle]
    fn wl_proxy_marshal(p: *mut wl_proxy, opcode: uint32_t, _: ...);
    #[no_mangle]
    fn wl_proxy_marshal_constructor(proxy: *mut wl_proxy, opcode: uint32_t,
                                    interface: *const wl_interface, _: ...)
     -> *mut wl_proxy;
    #[no_mangle]
    fn wl_proxy_marshal_constructor_versioned(proxy: *mut wl_proxy,
                                              opcode: uint32_t,
                                              interface: *const wl_interface,
                                              version: uint32_t, _: ...)
     -> *mut wl_proxy;
    #[no_mangle]
    fn wlr_signal_emit_safe(signal: *mut wl_signal, data: *mut libc::c_void);
    /* *
 * @page page_iface_zwp_linux_dmabuf_v1 zwp_linux_dmabuf_v1
 * @section page_iface_zwp_linux_dmabuf_v1_desc Description
 *
 * Following the interfaces from:
 * https://www.khronos.org/registry/egl/extensions/EXT/EGL_EXT_image_dma_buf_import.txt
 * https://www.khronos.org/registry/EGL/extensions/EXT/EGL_EXT_image_dma_buf_import_modifiers.txt
 * and the Linux DRM sub-system's AddFb2 ioctl.
 *
 * This interface offers ways to create generic dmabuf-based
 * wl_buffers. Immediately after a client binds to this interface,
 * the set of supported formats and format modifiers is sent with
 * 'format' and 'modifier' events.
 *
 * The following are required from clients:
 *
 * - Clients must ensure that either all data in the dma-buf is
 * coherent for all subsequent read access or that coherency is
 * correctly handled by the underlying kernel-side dma-buf
 * implementation.
 *
 * - Don't make any more attachments after sending the buffer to the
 * compositor. Making more attachments later increases the risk of
 * the compositor not being able to use (re-import) an existing
 * dmabuf-based wl_buffer.
 *
 * The underlying graphics stack must ensure the following:
 *
 * - The dmabuf file descriptors relayed to the server will stay valid
 * for the whole lifetime of the wl_buffer. This means the server may
 * at any time use those fds to import the dmabuf into any kernel
 * sub-system that might accept it.
 *
 * To create a wl_buffer from one or more dmabufs, a client creates a
 * zwp_linux_dmabuf_params_v1 object with a zwp_linux_dmabuf_v1.create_params
 * request. All planes required by the intended format are added with
 * the 'add' request. Finally, a 'create' or 'create_immed' request is
 * issued, which has the following outcome depending on the import success.
 *
 * The 'create' request,
 * - on success, triggers a 'created' event which provides the final
 * wl_buffer to the client.
 * - on failure, triggers a 'failed' event to convey that the server
 * cannot use the dmabufs received from the client.
 *
 * For the 'create_immed' request,
 * - on success, the server immediately imports the added dmabufs to
 * create a wl_buffer. No event is sent from the server in this case.
 * - on failure, the server can choose to either:
 * - terminate the client by raising a fatal error.
 * - mark the wl_buffer as failed, and send a 'failed' event to the
 * client. If the client uses a failed wl_buffer as an argument to any
 * request, the behaviour is compositor implementation-defined.
 *
 * Warning! The protocol described in this file is experimental and
 * backward incompatible changes may be made. Backward compatible changes
 * may be added together with the corresponding interface version bump.
 * Backward incompatible changes are done by bumping the version number in
 * the protocol and interface names and resetting the interface version.
 * Once the protocol is to be declared stable, the 'z' prefix and the
 * version number in the protocol and interface names are removed and the
 * interface version number is reset.
 * @section page_iface_zwp_linux_dmabuf_v1_api API
 * See @ref iface_zwp_linux_dmabuf_v1.
 */
/* *
 * @defgroup iface_zwp_linux_dmabuf_v1 The zwp_linux_dmabuf_v1 interface
 *
 * Following the interfaces from:
 * https://www.khronos.org/registry/egl/extensions/EXT/EGL_EXT_image_dma_buf_import.txt
 * https://www.khronos.org/registry/EGL/extensions/EXT/EGL_EXT_image_dma_buf_import_modifiers.txt
 * and the Linux DRM sub-system's AddFb2 ioctl.
 *
 * This interface offers ways to create generic dmabuf-based
 * wl_buffers. Immediately after a client binds to this interface,
 * the set of supported formats and format modifiers is sent with
 * 'format' and 'modifier' events.
 *
 * The following are required from clients:
 *
 * - Clients must ensure that either all data in the dma-buf is
 * coherent for all subsequent read access or that coherency is
 * correctly handled by the underlying kernel-side dma-buf
 * implementation.
 *
 * - Don't make any more attachments after sending the buffer to the
 * compositor. Making more attachments later increases the risk of
 * the compositor not being able to use (re-import) an existing
 * dmabuf-based wl_buffer.
 *
 * The underlying graphics stack must ensure the following:
 *
 * - The dmabuf file descriptors relayed to the server will stay valid
 * for the whole lifetime of the wl_buffer. This means the server may
 * at any time use those fds to import the dmabuf into any kernel
 * sub-system that might accept it.
 *
 * To create a wl_buffer from one or more dmabufs, a client creates a
 * zwp_linux_dmabuf_params_v1 object with a zwp_linux_dmabuf_v1.create_params
 * request. All planes required by the intended format are added with
 * the 'add' request. Finally, a 'create' or 'create_immed' request is
 * issued, which has the following outcome depending on the import success.
 *
 * The 'create' request,
 * - on success, triggers a 'created' event which provides the final
 * wl_buffer to the client.
 * - on failure, triggers a 'failed' event to convey that the server
 * cannot use the dmabufs received from the client.
 *
 * For the 'create_immed' request,
 * - on success, the server immediately imports the added dmabufs to
 * create a wl_buffer. No event is sent from the server in this case.
 * - on failure, the server can choose to either:
 * - terminate the client by raising a fatal error.
 * - mark the wl_buffer as failed, and send a 'failed' event to the
 * client. If the client uses a failed wl_buffer as an argument to any
 * request, the behaviour is compositor implementation-defined.
 *
 * Warning! The protocol described in this file is experimental and
 * backward incompatible changes may be made. Backward compatible changes
 * may be added together with the corresponding interface version bump.
 * Backward incompatible changes are done by bumping the version number in
 * the protocol and interface names and resetting the interface version.
 * Once the protocol is to be declared stable, the 'z' prefix and the
 * version number in the protocol and interface names are removed and the
 * interface version number is reset.
 */
    #[no_mangle]
    static zwp_linux_dmabuf_v1_interface: wl_interface;
    /* *
 * @page page_iface_zwp_pointer_gestures_v1 zwp_pointer_gestures_v1
 * @section page_iface_zwp_pointer_gestures_v1_desc Description
 *
 * A global interface to provide semantic touchpad gestures for a given
 * pointer.
 *
 * Two gestures are currently supported: swipe and zoom/rotate.
 * All gestures follow a three-stage cycle: begin, update, end and
 * are identified by a unique id.
 *
 * Warning! The protocol described in this file is experimental and
 * backward incompatible changes may be made. Backward compatible changes
 * may be added together with the corresponding interface version bump.
 * Backward incompatible changes are done by bumping the version number in
 * the protocol and interface names and resetting the interface version.
 * Once the protocol is to be declared stable, the 'z' prefix and the
 * version number in the protocol and interface names are removed and the
 * interface version number is reset.
 * @section page_iface_zwp_pointer_gestures_v1_api API
 * See @ref iface_zwp_pointer_gestures_v1.
 */
/* *
 * @defgroup iface_zwp_pointer_gestures_v1 The zwp_pointer_gestures_v1 interface
 *
 * A global interface to provide semantic touchpad gestures for a given
 * pointer.
 *
 * Two gestures are currently supported: swipe and zoom/rotate.
 * All gestures follow a three-stage cycle: begin, update, end and
 * are identified by a unique id.
 *
 * Warning! The protocol described in this file is experimental and
 * backward incompatible changes may be made. Backward compatible changes
 * may be added together with the corresponding interface version bump.
 * Backward incompatible changes are done by bumping the version number in
 * the protocol and interface names and resetting the interface version.
 * Once the protocol is to be declared stable, the 'z' prefix and the
 * version number in the protocol and interface names are removed and the
 * interface version number is reset.
 */
    #[no_mangle]
    static zwp_pointer_gestures_v1_interface: wl_interface;
    /* *
 * @page page_iface_wp_presentation wp_presentation
 * @section page_iface_wp_presentation_desc Description
 *
 *
 *
 *
 * The main feature of this interface is accurate presentation
 * timing feedback to ensure smooth video playback while maintaining
 * audio/video synchronization. Some features use the concept of a
 * presentation clock, which is defined in the
 * presentation.clock_id event.
 *
 * A content update for a wl_surface is submitted by a
 * wl_surface.commit request. Request 'feedback' associates with
 * the wl_surface.commit and provides feedback on the content
 * update, particularly the final realized presentation time.
 *
 *
 *
 * When the final realized presentation time is available, e.g.
 * after a framebuffer flip completes, the requested
 * presentation_feedback.presented events are sent. The final
 * presentation time can differ from the compositor's predicted
 * display update time and the update's target time, especially
 * when the compositor misses its target vertical blanking period.
 * @section page_iface_wp_presentation_api API
 * See @ref iface_wp_presentation.
 */
/* *
 * @defgroup iface_wp_presentation The wp_presentation interface
 *
 *
 *
 *
 * The main feature of this interface is accurate presentation
 * timing feedback to ensure smooth video playback while maintaining
 * audio/video synchronization. Some features use the concept of a
 * presentation clock, which is defined in the
 * presentation.clock_id event.
 *
 * A content update for a wl_surface is submitted by a
 * wl_surface.commit request. Request 'feedback' associates with
 * the wl_surface.commit and provides feedback on the content
 * update, particularly the final realized presentation time.
 *
 *
 *
 * When the final realized presentation time is available, e.g.
 * after a framebuffer flip completes, the requested
 * presentation_feedback.presented events are sent. The final
 * presentation time can differ from the compositor's predicted
 * display update time and the update's target time, especially
 * when the compositor misses its target vertical blanking period.
 */
    #[no_mangle]
    static wp_presentation_interface: wl_interface;
    /* *
 * @page page_iface_zxdg_decoration_manager_v1 zxdg_decoration_manager_v1
 * @section page_iface_zxdg_decoration_manager_v1_desc Description
 *
 * This interface allows a compositor to announce support for server-side
 * decorations.
 *
 * A window decoration is a set of window controls as deemed appropriate by
 * the party managing them, such as user interface components used to move,
 * resize and change a window's state.
 *
 * A client can use this protocol to request being decorated by a supporting
 * compositor.
 *
 * If compositor and client do not negotiate the use of a server-side
 * decoration using this protocol, clients continue to self-decorate as they
 * see fit.
 *
 * Warning! The protocol described in this file is experimental and
 * backward incompatible changes may be made. Backward compatible changes
 * may be added together with the corresponding interface version bump.
 * Backward incompatible changes are done by bumping the version number in
 * the protocol and interface names and resetting the interface version.
 * Once the protocol is to be declared stable, the 'z' prefix and the
 * version number in the protocol and interface names are removed and the
 * interface version number is reset.
 * @section page_iface_zxdg_decoration_manager_v1_api API
 * See @ref iface_zxdg_decoration_manager_v1.
 */
/* *
 * @defgroup iface_zxdg_decoration_manager_v1 The zxdg_decoration_manager_v1 interface
 *
 * This interface allows a compositor to announce support for server-side
 * decorations.
 *
 * A window decoration is a set of window controls as deemed appropriate by
 * the party managing them, such as user interface components used to move,
 * resize and change a window's state.
 *
 * A client can use this protocol to request being decorated by a supporting
 * compositor.
 *
 * If compositor and client do not negotiate the use of a server-side
 * decoration using this protocol, clients continue to self-decorate as they
 * see fit.
 *
 * Warning! The protocol described in this file is experimental and
 * backward incompatible changes may be made. Backward compatible changes
 * may be added together with the corresponding interface version bump.
 * Backward incompatible changes are done by bumping the version number in
 * the protocol and interface names and resetting the interface version.
 * Once the protocol is to be declared stable, the 'z' prefix and the
 * version number in the protocol and interface names are removed and the
 * interface version number is reset.
 */
    #[no_mangle]
    static zxdg_decoration_manager_v1_interface: wl_interface;
    /* *
 * @page page_iface_xdg_wm_base xdg_wm_base
 * @section page_iface_xdg_wm_base_desc Description
 *
 * The xdg_wm_base interface is exposed as a global object enabling clients
 * to turn their wl_surfaces into windows in a desktop environment. It
 * defines the basic functionality needed for clients and the compositor to
 * create windows that can be dragged, resized, maximized, etc, as well as
 * creating transient windows such as popup menus.
 * @section page_iface_xdg_wm_base_api API
 * See @ref iface_xdg_wm_base.
 */
/* *
 * @defgroup iface_xdg_wm_base The xdg_wm_base interface
 *
 * The xdg_wm_base interface is exposed as a global object enabling clients
 * to turn their wl_surfaces into windows in a desktop environment. It
 * defines the basic functionality needed for clients and the compositor to
 * create windows that can be dragged, resized, maximized, etc, as well as
 * creating transient windows such as popup menus.
 */
    #[no_mangle]
    static xdg_wm_base_interface: wl_interface;
    /* *
 * @page page_iface_zwp_tablet_manager_v2 zwp_tablet_manager_v2
 * @section page_iface_zwp_tablet_manager_v2_desc Description
 *
 * An object that provides access to the graphics tablets available on this
 * system. All tablets are associated with a seat, to get access to the
 * actual tablets, use wp_tablet_manager.get_tablet_seat.
 * @section page_iface_zwp_tablet_manager_v2_api API
 * See @ref iface_zwp_tablet_manager_v2.
 */
/* *
 * @defgroup iface_zwp_tablet_manager_v2 The zwp_tablet_manager_v2 interface
 *
 * An object that provides access to the graphics tablets available on this
 * system. All tablets are associated with a seat, to get access to the
 * actual tablets, use wp_tablet_manager.get_tablet_seat.
 */
    #[no_mangle]
    static zwp_tablet_manager_v2_interface: wl_interface;
    /* *
 * @page page_iface_zwp_relative_pointer_manager_v1 zwp_relative_pointer_manager_v1
 * @section page_iface_zwp_relative_pointer_manager_v1_desc Description
 *
 * A global interface used for getting the relative pointer object for a
 * given pointer.
 * @section page_iface_zwp_relative_pointer_manager_v1_api API
 * See @ref iface_zwp_relative_pointer_manager_v1.
 */
/* *
 * @defgroup iface_zwp_relative_pointer_manager_v1 The zwp_relative_pointer_manager_v1 interface
 *
 * A global interface used for getting the relative pointer object for a
 * given pointer.
 */
    #[no_mangle]
    static zwp_relative_pointer_manager_v1_interface: wl_interface;
}
pub type __uint16_t = libc::c_ushort;
pub type __int32_t = libc::c_int;
pub type __uint32_t = libc::c_uint;
pub type __uint64_t = libc::c_ulong;
pub type __clockid_t = libc::c_int;
pub type int32_t = __int32_t;
pub type uint16_t = __uint16_t;
pub type uint32_t = __uint32_t;
pub type uint64_t = __uint64_t;
pub type size_t = libc::c_ulong;
pub type __u64 = libc::c_ulonglong;
pub type clockid_t = __clockid_t;
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wl_object {
    pub interface: *const wl_interface,
    pub implementation: *const libc::c_void,
    pub id: uint32_t,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wl_interface {
    pub name: *const libc::c_char,
    pub version: libc::c_int,
    pub method_count: libc::c_int,
    pub methods: *const wl_message,
    pub event_count: libc::c_int,
    pub events: *const wl_message,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wl_message {
    pub name: *const libc::c_char,
    pub signature: *const libc::c_char,
    pub types: *mut *const wl_interface,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wl_list {
    pub prev: *mut wl_list,
    pub next: *mut wl_list,
}
pub type C2RustUnnamed = libc::c_uint;
pub const WL_EVENT_ERROR: C2RustUnnamed = 8;
pub const WL_EVENT_HANGUP: C2RustUnnamed = 4;
pub const WL_EVENT_WRITABLE: C2RustUnnamed = 2;
pub const WL_EVENT_READABLE: C2RustUnnamed = 1;
pub type wl_event_loop_fd_func_t
    =
    Option<unsafe extern "C" fn(_: libc::c_int, _: uint32_t,
                                _: *mut libc::c_void) -> libc::c_int>;
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wl_listener {
    pub link: wl_list,
    pub notify: wl_notify_func_t,
}
pub type wl_notify_func_t
    =
    Option<unsafe extern "C" fn(_: *mut wl_listener, _: *mut libc::c_void)
               -> ()>;
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wl_resource {
    pub object: wl_object,
    pub destroy: wl_resource_destroy_func_t,
    pub link: wl_list,
    pub destroy_signal: wl_signal,
    pub client: *mut wl_client,
    pub data: *mut libc::c_void,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wl_signal {
    pub listener_list: wl_list,
}
pub type wl_resource_destroy_func_t
    =
    Option<unsafe extern "C" fn(_: *mut wl_resource) -> ()>;
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wlr_session {
    pub impl_0: *const session_impl,
    pub session_signal: wl_signal,
    pub active: bool,
    pub vtnr: libc::c_uint,
    pub seat: [libc::c_char; 256],
    pub udev: *mut udev,
    pub mon: *mut udev_monitor,
    pub udev_event: *mut wl_event_source,
    pub devices: wl_list,
    pub display_destroy: wl_listener,
    pub events: C2RustUnnamed_0,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct C2RustUnnamed_0 {
    pub destroy: wl_signal,
}
pub type khronos_int32_t = int32_t;
pub type EGLint = khronos_int32_t;
pub type EGLDisplay = *mut libc::c_void;
pub type EGLConfig = *mut libc::c_void;
pub type EGLSurface = *mut libc::c_void;
pub type EGLContext = *mut libc::c_void;
pub type EGLenum = libc::c_uint;
/*
 * 32 bit regions
 */
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct pixman_region32_data {
    pub size: libc::c_long,
    pub numRects: libc::c_long,
}
pub type pixman_region32_data_t = pixman_region32_data;
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct pixman_box32 {
    pub x1: int32_t,
    pub y1: int32_t,
    pub x2: int32_t,
    pub y2: int32_t,
}
pub type pixman_box32_t = pixman_box32;
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct pixman_region32 {
    pub extents: pixman_box32_t,
    pub data: *mut pixman_region32_data_t,
}
pub type pixman_region32_t = pixman_region32;
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wlr_dmabuf_attributes {
    pub width: int32_t,
    pub height: int32_t,
    pub format: uint32_t,
    pub flags: uint32_t,
    pub modifier: uint64_t,
    pub n_planes: libc::c_int,
    pub offset: [uint32_t; 4],
    pub stride: [uint32_t; 4],
    pub fd: [libc::c_int; 4],
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wlr_drm_format {
    pub format: uint32_t,
    pub len: size_t,
    pub cap: size_t,
    pub modifiers: [uint64_t; 0],
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wlr_drm_format_set {
    pub len: size_t,
    pub cap: size_t,
    pub formats: *mut *mut wlr_drm_format,
}
/*
 * This an unstable interface of wlroots. No guarantees are made regarding the
 * future consistency of this API.
 */
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wlr_egl {
    pub platform: EGLenum,
    pub display: EGLDisplay,
    pub config: EGLConfig,
    pub context: EGLContext,
    pub exts_str: *const libc::c_char,
    pub exts: C2RustUnnamed_1,
    pub wl_display: *mut wl_display,
    pub dmabuf_formats: wlr_drm_format_set,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct C2RustUnnamed_1 {
    pub bind_wayland_display_wl: bool,
    pub buffer_age_ext: bool,
    pub image_base_khr: bool,
    pub image_dma_buf_export_mesa: bool,
    pub image_dmabuf_import_ext: bool,
    pub image_dmabuf_import_modifiers_ext: bool,
    pub swap_buffers_with_damage_ext: bool,
    pub swap_buffers_with_damage_khr: bool,
}
/*
 * This an unstable interface of wlroots. No guarantees are made regarding the
 * future consistency of this API.
 */
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wlr_backend_impl {
    pub start: Option<unsafe extern "C" fn(_: *mut wlr_backend) -> bool>,
    pub destroy: Option<unsafe extern "C" fn(_: *mut wlr_backend) -> ()>,
    pub get_renderer: Option<unsafe extern "C" fn(_: *mut wlr_backend)
                                 -> *mut wlr_renderer>,
    pub get_session: Option<unsafe extern "C" fn(_: *mut wlr_backend)
                                -> *mut wlr_session>,
    pub get_presentation_clock: Option<unsafe extern "C" fn(_:
                                                                *mut wlr_backend)
                                           -> clockid_t>,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wlr_backend {
    pub impl_0: *const wlr_backend_impl,
    pub events: C2RustUnnamed_2,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct C2RustUnnamed_2 {
    pub destroy: wl_signal,
    pub new_input: wl_signal,
    pub new_output: wl_signal,
}
/*
 * This an unstable interface of wlroots. No guarantees are made regarding the
 * future consistency of this API.
 */
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wlr_renderer {
    pub impl_0: *const wlr_renderer_impl,
    pub events: C2RustUnnamed_3,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct C2RustUnnamed_3 {
    pub destroy: wl_signal,
}
pub type wlr_renderer_create_func_t
    =
    Option<unsafe extern "C" fn(_: *mut wlr_egl, _: EGLenum,
                                _: *mut libc::c_void, _: *mut EGLint,
                                _: EGLint) -> *mut wlr_renderer>;
pub type wlr_input_device_type = libc::c_uint;
pub const WLR_INPUT_DEVICE_SWITCH: wlr_input_device_type = 5;
pub const WLR_INPUT_DEVICE_TABLET_PAD: wlr_input_device_type = 4;
pub const WLR_INPUT_DEVICE_TABLET_TOOL: wlr_input_device_type = 3;
pub const WLR_INPUT_DEVICE_TOUCH: wlr_input_device_type = 2;
pub const WLR_INPUT_DEVICE_POINTER: wlr_input_device_type = 1;
pub const WLR_INPUT_DEVICE_KEYBOARD: wlr_input_device_type = 0;
pub type xkb_mod_index_t = uint32_t;
pub type xkb_mod_mask_t = uint32_t;
pub type xkb_led_index_t = uint32_t;
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wlr_keyboard_modifiers {
    pub depressed: xkb_mod_mask_t,
    pub latched: xkb_mod_mask_t,
    pub locked: xkb_mod_mask_t,
    pub group: xkb_mod_mask_t,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wlr_keyboard {
    pub impl_0: *const wlr_keyboard_impl,
    pub group: *mut wlr_keyboard_group,
    pub keymap_string: *mut libc::c_char,
    pub keymap_size: size_t,
    pub keymap: *mut xkb_keymap,
    pub xkb_state: *mut xkb_state,
    pub led_indexes: [xkb_led_index_t; 3],
    pub mod_indexes: [xkb_mod_index_t; 8],
    pub keycodes: [uint32_t; 32],
    pub num_keycodes: size_t,
    pub modifiers: wlr_keyboard_modifiers,
    pub repeat_info: C2RustUnnamed_5,
    pub events: C2RustUnnamed_4,
    pub data: *mut libc::c_void,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct C2RustUnnamed_4 {
    pub key: wl_signal,
    pub modifiers: wl_signal,
    pub keymap: wl_signal,
    pub repeat_info: wl_signal,
    pub destroy: wl_signal,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct C2RustUnnamed_5 {
    pub rate: int32_t,
    pub delay: int32_t,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wlr_pointer {
    pub impl_0: *const wlr_pointer_impl,
    pub events: C2RustUnnamed_6,
    pub data: *mut libc::c_void,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct C2RustUnnamed_6 {
    pub motion: wl_signal,
    pub motion_absolute: wl_signal,
    pub button: wl_signal,
    pub axis: wl_signal,
    pub frame: wl_signal,
    pub swipe_begin: wl_signal,
    pub swipe_update: wl_signal,
    pub swipe_end: wl_signal,
    pub pinch_begin: wl_signal,
    pub pinch_update: wl_signal,
    pub pinch_end: wl_signal,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wlr_input_device {
    pub impl_0: *const wlr_input_device_impl,
    pub type_0: wlr_input_device_type,
    pub vendor: libc::c_uint,
    pub product: libc::c_uint,
    pub name: *mut libc::c_char,
    pub width_mm: libc::c_double,
    pub height_mm: libc::c_double,
    pub output_name: *mut libc::c_char,
    pub c2rust_unnamed: C2RustUnnamed_8,
    pub events: C2RustUnnamed_7,
    pub data: *mut libc::c_void,
    pub link: wl_list,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct C2RustUnnamed_7 {
    pub destroy: wl_signal,
}
#[derive ( Copy, Clone )]
#[repr ( C )]
pub union C2RustUnnamed_8 {
    pub _device: *mut libc::c_void,
    pub keyboard: *mut wlr_keyboard,
    pub pointer: *mut wlr_pointer,
    pub switch_device: *mut wlr_switch,
    pub touch: *mut wlr_touch,
    pub tablet: *mut wlr_tablet,
    pub tablet_pad: *mut wlr_tablet_pad,
}
/*
 * This an unstable interface of wlroots. No guarantees are made regarding the
 * future consistency of this API.
 */
/*
 * NOTE: the wlr tablet pad implementation does not currently support tablets
 * with more than one mode. I don't own any such hardware so I cannot test it
 * and it is too complicated to make a meaningful implementation of blindly.
 */
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wlr_tablet_pad {
    pub impl_0: *mut wlr_tablet_pad_impl,
    pub events: C2RustUnnamed_9,
    pub button_count: size_t,
    pub ring_count: size_t,
    pub strip_count: size_t,
    pub groups: wl_list,
    pub paths: wlr_list,
    pub data: *mut libc::c_void,
}
/*
 * This an unstable interface of wlroots. No guarantees are made regarding the
 * future consistency of this API.
 */
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wlr_list {
    pub capacity: size_t,
    pub length: size_t,
    pub items: *mut *mut libc::c_void,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct C2RustUnnamed_9 {
    pub button: wl_signal,
    pub ring: wl_signal,
    pub strip: wl_signal,
    pub attach_tablet: wl_signal,
}
/*
 * This an unstable interface of wlroots. No guarantees are made regarding the
 * future consistency of this API.
 */
/*
 * Copy+Paste from libinput, but this should neither use libinput, nor
 * tablet-unstable-v2 headers, so we can't include them
 */
/* * A generic pen */
/* * Eraser */
/* * A paintbrush-like tool */
/* * Physical drawing tool, e.g. Wacom Inking Pen */
/* * An airbrush-like tool */
/* * A mouse bound to the tablet */
/* * A mouse tool with a lens */
/* * A rotary device with positional and rotation data */
// Capabilities
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wlr_tablet {
    pub impl_0: *mut wlr_tablet_impl,
    pub events: C2RustUnnamed_10,
    pub name: *mut libc::c_char,
    pub paths: wlr_list,
    pub data: *mut libc::c_void,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct C2RustUnnamed_10 {
    pub axis: wl_signal,
    pub proximity: wl_signal,
    pub tip: wl_signal,
    pub button: wl_signal,
}
/*
 * This an unstable interface of wlroots. No guarantees are made regarding the
 * future consistency of this API.
 */
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wlr_touch {
    pub impl_0: *const wlr_touch_impl,
    pub events: C2RustUnnamed_11,
    pub data: *mut libc::c_void,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct C2RustUnnamed_11 {
    pub down: wl_signal,
    pub up: wl_signal,
    pub motion: wl_signal,
    pub cancel: wl_signal,
}
/*
 * This an unstable interface of wlroots. No guarantees are made regarding the
 * future consistency of this API.
 */
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wlr_switch {
    pub impl_0: *mut wlr_switch_impl,
    pub events: C2RustUnnamed_12,
    pub data: *mut libc::c_void,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct C2RustUnnamed_12 {
    pub toggle: wl_signal,
}
/* Note: these are circular dependencies */
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wlr_input_device_impl {
    pub destroy: Option<unsafe extern "C" fn(_: *mut wlr_input_device) -> ()>,
}
pub type wlr_axis_source = libc::c_uint;
pub const WLR_AXIS_SOURCE_WHEEL_TILT: wlr_axis_source = 3;
pub const WLR_AXIS_SOURCE_CONTINUOUS: wlr_axis_source = 2;
pub const WLR_AXIS_SOURCE_FINGER: wlr_axis_source = 1;
pub const WLR_AXIS_SOURCE_WHEEL: wlr_axis_source = 0;
pub type wl_shm_format = libc::c_uint;
pub const WL_SHM_FORMAT_YVU444: wl_shm_format = 875714137;
pub const WL_SHM_FORMAT_YUV444: wl_shm_format = 875713881;
pub const WL_SHM_FORMAT_YVU422: wl_shm_format = 909203033;
pub const WL_SHM_FORMAT_YUV422: wl_shm_format = 909202777;
pub const WL_SHM_FORMAT_YVU420: wl_shm_format = 842094169;
pub const WL_SHM_FORMAT_YUV420: wl_shm_format = 842093913;
pub const WL_SHM_FORMAT_YVU411: wl_shm_format = 825316953;
pub const WL_SHM_FORMAT_YUV411: wl_shm_format = 825316697;
pub const WL_SHM_FORMAT_YVU410: wl_shm_format = 961893977;
pub const WL_SHM_FORMAT_YUV410: wl_shm_format = 961959257;
pub const WL_SHM_FORMAT_NV61: wl_shm_format = 825644622;
pub const WL_SHM_FORMAT_NV16: wl_shm_format = 909203022;
pub const WL_SHM_FORMAT_NV21: wl_shm_format = 825382478;
pub const WL_SHM_FORMAT_NV12: wl_shm_format = 842094158;
pub const WL_SHM_FORMAT_AYUV: wl_shm_format = 1448433985;
pub const WL_SHM_FORMAT_VYUY: wl_shm_format = 1498765654;
pub const WL_SHM_FORMAT_UYVY: wl_shm_format = 1498831189;
pub const WL_SHM_FORMAT_YVYU: wl_shm_format = 1431918169;
pub const WL_SHM_FORMAT_YUYV: wl_shm_format = 1448695129;
pub const WL_SHM_FORMAT_BGRA1010102: wl_shm_format = 808665410;
pub const WL_SHM_FORMAT_RGBA1010102: wl_shm_format = 808665426;
pub const WL_SHM_FORMAT_ABGR2101010: wl_shm_format = 808665665;
pub const WL_SHM_FORMAT_ARGB2101010: wl_shm_format = 808669761;
pub const WL_SHM_FORMAT_BGRX1010102: wl_shm_format = 808671298;
pub const WL_SHM_FORMAT_RGBX1010102: wl_shm_format = 808671314;
pub const WL_SHM_FORMAT_XBGR2101010: wl_shm_format = 808665688;
pub const WL_SHM_FORMAT_XRGB2101010: wl_shm_format = 808669784;
pub const WL_SHM_FORMAT_BGRA8888: wl_shm_format = 875708738;
pub const WL_SHM_FORMAT_RGBA8888: wl_shm_format = 875708754;
pub const WL_SHM_FORMAT_ABGR8888: wl_shm_format = 875708993;
pub const WL_SHM_FORMAT_BGRX8888: wl_shm_format = 875714626;
pub const WL_SHM_FORMAT_RGBX8888: wl_shm_format = 875714642;
pub const WL_SHM_FORMAT_XBGR8888: wl_shm_format = 875709016;
pub const WL_SHM_FORMAT_BGR888: wl_shm_format = 875710274;
pub const WL_SHM_FORMAT_RGB888: wl_shm_format = 875710290;
pub const WL_SHM_FORMAT_BGR565: wl_shm_format = 909199170;
pub const WL_SHM_FORMAT_RGB565: wl_shm_format = 909199186;
pub const WL_SHM_FORMAT_BGRA5551: wl_shm_format = 892420418;
pub const WL_SHM_FORMAT_RGBA5551: wl_shm_format = 892420434;
pub const WL_SHM_FORMAT_ABGR1555: wl_shm_format = 892420673;
pub const WL_SHM_FORMAT_ARGB1555: wl_shm_format = 892424769;
pub const WL_SHM_FORMAT_BGRX5551: wl_shm_format = 892426306;
pub const WL_SHM_FORMAT_RGBX5551: wl_shm_format = 892426322;
pub const WL_SHM_FORMAT_XBGR1555: wl_shm_format = 892420696;
pub const WL_SHM_FORMAT_XRGB1555: wl_shm_format = 892424792;
pub const WL_SHM_FORMAT_BGRA4444: wl_shm_format = 842088770;
pub const WL_SHM_FORMAT_RGBA4444: wl_shm_format = 842088786;
pub const WL_SHM_FORMAT_ABGR4444: wl_shm_format = 842089025;
pub const WL_SHM_FORMAT_ARGB4444: wl_shm_format = 842093121;
pub const WL_SHM_FORMAT_BGRX4444: wl_shm_format = 842094658;
pub const WL_SHM_FORMAT_RGBX4444: wl_shm_format = 842094674;
pub const WL_SHM_FORMAT_XBGR4444: wl_shm_format = 842089048;
pub const WL_SHM_FORMAT_XRGB4444: wl_shm_format = 842093144;
pub const WL_SHM_FORMAT_BGR233: wl_shm_format = 944916290;
pub const WL_SHM_FORMAT_RGB332: wl_shm_format = 943867730;
pub const WL_SHM_FORMAT_C8: wl_shm_format = 538982467;
pub const WL_SHM_FORMAT_XRGB8888: wl_shm_format = 1;
pub const WL_SHM_FORMAT_ARGB8888: wl_shm_format = 0;
pub type wl_output_subpixel = libc::c_uint;
pub const WL_OUTPUT_SUBPIXEL_VERTICAL_BGR: wl_output_subpixel = 5;
pub const WL_OUTPUT_SUBPIXEL_VERTICAL_RGB: wl_output_subpixel = 4;
pub const WL_OUTPUT_SUBPIXEL_HORIZONTAL_BGR: wl_output_subpixel = 3;
pub const WL_OUTPUT_SUBPIXEL_HORIZONTAL_RGB: wl_output_subpixel = 2;
pub const WL_OUTPUT_SUBPIXEL_NONE: wl_output_subpixel = 1;
pub const WL_OUTPUT_SUBPIXEL_UNKNOWN: wl_output_subpixel = 0;
pub type wl_output_transform = libc::c_uint;
pub const WL_OUTPUT_TRANSFORM_FLIPPED_270: wl_output_transform = 7;
pub const WL_OUTPUT_TRANSFORM_FLIPPED_180: wl_output_transform = 6;
pub const WL_OUTPUT_TRANSFORM_FLIPPED_90: wl_output_transform = 5;
pub const WL_OUTPUT_TRANSFORM_FLIPPED: wl_output_transform = 4;
pub const WL_OUTPUT_TRANSFORM_270: wl_output_transform = 3;
pub const WL_OUTPUT_TRANSFORM_180: wl_output_transform = 2;
pub const WL_OUTPUT_TRANSFORM_90: wl_output_transform = 1;
pub const WL_OUTPUT_TRANSFORM_NORMAL: wl_output_transform = 0;
/*
 * This an unstable interface of wlroots. No guarantees are made regarding the
 * future consistency of this API.
 */
/* *
 * A client buffer.
 */
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wlr_buffer {
    pub resource: *mut wl_resource,
    pub texture: *mut wlr_texture,
    pub released: bool,
    pub n_refs: size_t,
    pub resource_destroy: wl_listener,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wlr_texture {
    pub impl_0: *const wlr_texture_impl,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wlr_output_mode {
    pub width: int32_t,
    pub height: int32_t,
    pub refresh: int32_t,
    pub preferred: bool,
    pub link: wl_list,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wlr_output_cursor {
    pub output: *mut wlr_output,
    pub x: libc::c_double,
    pub y: libc::c_double,
    pub enabled: bool,
    pub visible: bool,
    pub width: uint32_t,
    pub height: uint32_t,
    pub hotspot_x: int32_t,
    pub hotspot_y: int32_t,
    pub link: wl_list,
    pub texture: *mut wlr_texture,
    pub surface: *mut wlr_surface,
    pub surface_commit: wl_listener,
    pub surface_destroy: wl_listener,
    pub events: C2RustUnnamed_13,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct C2RustUnnamed_13 {
    pub destroy: wl_signal,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wlr_output {
    pub impl_0: *const wlr_output_impl,
    pub backend: *mut wlr_backend,
    pub display: *mut wl_display,
    pub global: *mut wl_global,
    pub resources: wl_list,
    pub name: [libc::c_char; 24],
    pub make: [libc::c_char; 56],
    pub model: [libc::c_char; 16],
    pub serial: [libc::c_char; 16],
    pub phys_width: int32_t,
    pub phys_height: int32_t,
    pub modes: wl_list,
    pub current_mode: *mut wlr_output_mode,
    pub width: int32_t,
    pub height: int32_t,
    pub refresh: int32_t,
    pub enabled: bool,
    pub scale: libc::c_float,
    pub subpixel: wl_output_subpixel,
    pub transform: wl_output_transform,
    pub needs_frame: bool,
    pub damage: pixman_region32_t,
    pub frame_pending: bool,
    pub transform_matrix: [libc::c_float; 9],
    pub pending: wlr_output_state,
    pub commit_seq: uint32_t,
    pub events: C2RustUnnamed_14,
    pub idle_frame: *mut wl_event_source,
    pub idle_done: *mut wl_event_source,
    pub attach_render_locks: libc::c_int,
    pub cursors: wl_list,
    pub hardware_cursor: *mut wlr_output_cursor,
    pub software_cursor_locks: libc::c_int,
    pub display_destroy: wl_listener,
    pub data: *mut libc::c_void,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct C2RustUnnamed_14 {
    pub frame: wl_signal,
    pub needs_frame: wl_signal,
    pub precommit: wl_signal,
    pub commit: wl_signal,
    pub present: wl_signal,
    pub enable: wl_signal,
    pub mode: wl_signal,
    pub scale: wl_signal,
    pub transform: wl_signal,
    pub destroy: wl_signal,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wlr_output_state {
    pub committed: uint32_t,
    pub damage: pixman_region32_t,
    pub buffer_type: wlr_output_state_buffer_type,
    pub buffer: *mut wlr_buffer,
}
pub type wlr_output_state_buffer_type = libc::c_uint;
pub const WLR_OUTPUT_STATE_BUFFER_SCANOUT: wlr_output_state_buffer_type = 1;
pub const WLR_OUTPUT_STATE_BUFFER_RENDER: wlr_output_state_buffer_type = 0;
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wlr_output_impl {
    pub enable: Option<unsafe extern "C" fn(_: *mut wlr_output, _: bool)
                           -> bool>,
    pub set_mode: Option<unsafe extern "C" fn(_: *mut wlr_output,
                                              _: *mut wlr_output_mode)
                             -> bool>,
    pub set_custom_mode: Option<unsafe extern "C" fn(_: *mut wlr_output,
                                                     _: int32_t, _: int32_t,
                                                     _: int32_t) -> bool>,
    pub set_cursor: Option<unsafe extern "C" fn(_: *mut wlr_output,
                                                _: *mut wlr_texture,
                                                _: int32_t,
                                                _: wl_output_transform,
                                                _: int32_t, _: int32_t,
                                                _: bool) -> bool>,
    pub move_cursor: Option<unsafe extern "C" fn(_: *mut wlr_output,
                                                 _: libc::c_int,
                                                 _: libc::c_int) -> bool>,
    pub destroy: Option<unsafe extern "C" fn(_: *mut wlr_output) -> ()>,
    pub attach_render: Option<unsafe extern "C" fn(_: *mut wlr_output,
                                                   _: *mut libc::c_int)
                                  -> bool>,
    pub commit: Option<unsafe extern "C" fn(_: *mut wlr_output) -> bool>,
    pub set_gamma: Option<unsafe extern "C" fn(_: *mut wlr_output, _: size_t,
                                               _: *const uint16_t,
                                               _: *const uint16_t,
                                               _: *const uint16_t) -> bool>,
    pub get_gamma_size: Option<unsafe extern "C" fn(_: *mut wlr_output)
                                   -> size_t>,
    pub export_dmabuf: Option<unsafe extern "C" fn(_: *mut wlr_output,
                                                   _:
                                                       *mut wlr_dmabuf_attributes)
                                  -> bool>,
    pub schedule_frame: Option<unsafe extern "C" fn(_: *mut wlr_output)
                                   -> bool>,
    pub attach_buffer: Option<unsafe extern "C" fn(_: *mut wlr_output,
                                                   _: *mut wlr_buffer)
                                  -> bool>,
}
/*
 * This is a stable interface of wlroots. Future changes will be limited to:
 *
 * - New functions
 * - New struct members
 * - New enum members
 *
 * Note that wlroots does not make an ABI compatibility promise - in the future,
 * the layout and size of structs used by wlroots may change, requiring code
 * depending on this header to be recompiled (but not edited).
 *
 * Breaking changes are announced by email and follow a 1-year deprecation
 * schedule. Send an email to ~sircmpwn/wlroots-announce+subscribe@lists.sr.ht
 * to receive these announcements.
 */
pub type wlr_log_importance = libc::c_uint;
pub const WLR_LOG_IMPORTANCE_LAST: wlr_log_importance = 4;
pub const WLR_DEBUG: wlr_log_importance = 3;
pub const WLR_INFO: wlr_log_importance = 2;
pub const WLR_ERROR: wlr_log_importance = 1;
pub const WLR_SILENT: wlr_log_importance = 0;
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wl_registry_listener {
    pub global: Option<unsafe extern "C" fn(_: *mut libc::c_void,
                                            _: *mut wl_registry, _: uint32_t,
                                            _: *const libc::c_char,
                                            _: uint32_t) -> ()>,
    pub global_remove: Option<unsafe extern "C" fn(_: *mut libc::c_void,
                                                   _: *mut wl_registry,
                                                   _: uint32_t) -> ()>,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wl_seat_listener {
    pub capabilities: Option<unsafe extern "C" fn(_: *mut libc::c_void,
                                                  _: *mut wl_seat,
                                                  _: uint32_t) -> ()>,
    pub name: Option<unsafe extern "C" fn(_: *mut libc::c_void,
                                          _: *mut wl_seat,
                                          _: *const libc::c_char) -> ()>,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wlr_wl_backend {
    pub backend: wlr_backend,
    pub started: bool,
    pub local_display: *mut wl_display,
    pub devices: wl_list,
    pub outputs: wl_list,
    pub egl: wlr_egl,
    pub renderer: *mut wlr_renderer,
    pub requested_outputs: size_t,
    pub last_output_num: size_t,
    pub local_display_destroy: wl_listener,
    pub remote_display: *mut wl_display,
    pub remote_display_src: *mut wl_event_source,
    pub registry: *mut wl_registry,
    pub compositor: *mut wl_compositor,
    pub xdg_wm_base: *mut xdg_wm_base,
    pub zxdg_decoration_manager_v1: *mut zxdg_decoration_manager_v1,
    pub zwp_pointer_gestures_v1: *mut zwp_pointer_gestures_v1,
    pub presentation: *mut wp_presentation,
    pub zwp_linux_dmabuf_v1: *mut zwp_linux_dmabuf_v1,
    pub zwp_relative_pointer_manager_v1: *mut zwp_relative_pointer_manager_v1,
    pub seat: *mut wl_seat,
    pub pointer: *mut wl_pointer,
    pub keyboard: *mut wl_keyboard,
    pub current_pointer: *mut wlr_wl_pointer,
    pub tablet_manager: *mut zwp_tablet_manager_v2,
    pub seat_name: *mut libc::c_char,
    pub linux_dmabuf_v1_formats: wlr_drm_format_set,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wlr_wl_pointer {
    pub wlr_pointer: wlr_pointer,
    pub input_device: *mut wlr_wl_input_device,
    pub wl_pointer: *mut wl_pointer,
    pub gesture_swipe: *mut zwp_pointer_gesture_swipe_v1,
    pub gesture_pinch: *mut zwp_pointer_gesture_pinch_v1,
    pub relative_pointer: *mut zwp_relative_pointer_v1,
    pub axis_source: wlr_axis_source,
    pub axis_discrete: int32_t,
    pub output: *mut wlr_wl_output,
    pub output_destroy: wl_listener,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wlr_wl_output {
    pub wlr_output: wlr_output,
    pub backend: *mut wlr_wl_backend,
    pub link: wl_list,
    pub surface: *mut wl_surface,
    pub frame_callback: *mut wl_callback,
    pub xdg_surface: *mut xdg_surface,
    pub xdg_toplevel: *mut xdg_toplevel,
    pub zxdg_toplevel_decoration_v1: *mut zxdg_toplevel_decoration_v1,
    pub egl_window: *mut wl_egl_window,
    pub egl_surface: EGLSurface,
    pub pending_wl_buffer: *mut wl_buffer,
    pub current_wl_buffer: *mut wl_buffer,
    pub current_buffer: *mut wlr_buffer,
    pub presentation_feedbacks: wl_list,
    pub enter_serial: uint32_t,
    pub cursor: C2RustUnnamed_15,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct C2RustUnnamed_15 {
    pub surface: *mut wl_surface,
    pub egl_window: *mut wl_egl_window,
    pub hotspot_x: int32_t,
    pub hotspot_y: int32_t,
    pub width: int32_t,
    pub height: int32_t,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wlr_wl_input_device {
    pub wlr_input_device: wlr_input_device,
    pub fingers: uint32_t,
    pub backend: *mut wlr_wl_backend,
    pub resource: *mut libc::c_void,
}
/* *
 * @ingroup iface_zwp_linux_dmabuf_v1
 * @struct zwp_linux_dmabuf_v1_listener
 */
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct zwp_linux_dmabuf_v1_listener {
    pub format: Option<unsafe extern "C" fn(_: *mut libc::c_void,
                                            _: *mut zwp_linux_dmabuf_v1,
                                            _: uint32_t) -> ()>,
    pub modifier: Option<unsafe extern "C" fn(_: *mut libc::c_void,
                                              _: *mut zwp_linux_dmabuf_v1,
                                              _: uint32_t, _: uint32_t,
                                              _: uint32_t) -> ()>,
}
/* XDG_WM_BASE_ERROR_ENUM */
/* *
 * @ingroup iface_xdg_wm_base
 * @struct xdg_wm_base_listener
 */
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct xdg_wm_base_listener {
    pub ping: Option<unsafe extern "C" fn(_: *mut libc::c_void,
                                          _: *mut xdg_wm_base, _: uint32_t)
                         -> ()>,
}
#[inline]
unsafe extern "C" fn wl_display_get_registry(mut wl_display: *mut wl_display)
 -> *mut wl_registry {
    let mut registry: *mut wl_proxy = 0 as *mut wl_proxy;
    registry =
        wl_proxy_marshal_constructor(wl_display as *mut wl_proxy,
                                     1i32 as uint32_t,
                                     &wl_registry_interface as
                                         *const wl_interface,
                                     0 as *mut libc::c_void);
    return registry as *mut wl_registry;
}
#[inline]
unsafe extern "C" fn wl_registry_add_listener(mut wl_registry:
                                                  *mut wl_registry,
                                              mut listener:
                                                  *const wl_registry_listener,
                                              mut data: *mut libc::c_void)
 -> libc::c_int {
    return wl_proxy_add_listener(wl_registry as *mut wl_proxy,
                                 listener as
                                     *mut Option<unsafe extern "C" fn()
                                                     -> ()>, data);
}
#[inline]
unsafe extern "C" fn wl_registry_destroy(mut wl_registry: *mut wl_registry) {
    wl_proxy_destroy(wl_registry as *mut wl_proxy);
}
#[inline]
unsafe extern "C" fn wl_registry_bind(mut wl_registry: *mut wl_registry,
                                      mut name: uint32_t,
                                      mut interface: *const wl_interface,
                                      mut version: uint32_t)
 -> *mut libc::c_void {
    let mut id: *mut wl_proxy = 0 as *mut wl_proxy;
    id =
        wl_proxy_marshal_constructor_versioned(wl_registry as *mut wl_proxy,
                                               0i32 as uint32_t, interface,
                                               version, name,
                                               (*interface).name, version,
                                               0 as *mut libc::c_void);
    return id as *mut libc::c_void;
}
#[inline]
unsafe extern "C" fn wl_compositor_destroy(mut wl_compositor:
                                               *mut wl_compositor) {
    wl_proxy_destroy(wl_compositor as *mut wl_proxy);
}
#[inline]
unsafe extern "C" fn wl_seat_add_listener(mut wl_seat: *mut wl_seat,
                                          mut listener:
                                              *const wl_seat_listener,
                                          mut data: *mut libc::c_void)
 -> libc::c_int {
    return wl_proxy_add_listener(wl_seat as *mut wl_proxy,
                                 listener as
                                     *mut Option<unsafe extern "C" fn()
                                                     -> ()>, data);
}
#[inline]
unsafe extern "C" fn wl_seat_destroy(mut wl_seat: *mut wl_seat) {
    wl_proxy_destroy(wl_seat as *mut wl_proxy);
}
#[inline]
unsafe extern "C" fn wl_pointer_destroy(mut wl_pointer: *mut wl_pointer) {
    wl_proxy_destroy(wl_pointer as *mut wl_proxy);
}
/* *
 * @ingroup iface_zwp_linux_dmabuf_v1
 */
#[inline]
unsafe extern "C" fn zwp_linux_dmabuf_v1_add_listener(mut zwp_linux_dmabuf_v1:
                                                          *mut zwp_linux_dmabuf_v1,
                                                      mut listener:
                                                          *const zwp_linux_dmabuf_v1_listener,
                                                      mut data:
                                                          *mut libc::c_void)
 -> libc::c_int {
    return wl_proxy_add_listener(zwp_linux_dmabuf_v1 as *mut wl_proxy,
                                 listener as
                                     *mut Option<unsafe extern "C" fn()
                                                     -> ()>, data);
}
/* *
 * @ingroup iface_zwp_linux_dmabuf_v1
 *
 * Objects created through this interface, especially wl_buffers, will
 * remain valid.
 */
#[inline]
unsafe extern "C" fn zwp_linux_dmabuf_v1_destroy(mut zwp_linux_dmabuf_v1:
                                                     *mut zwp_linux_dmabuf_v1) {
    wl_proxy_marshal(zwp_linux_dmabuf_v1 as *mut wl_proxy, 0i32 as uint32_t);
    wl_proxy_destroy(zwp_linux_dmabuf_v1 as *mut wl_proxy);
}
/* * @ingroup iface_zwp_pointer_gestures_v1 */
#[inline]
unsafe extern "C" fn zwp_pointer_gestures_v1_destroy(mut zwp_pointer_gestures_v1:
                                                         *mut zwp_pointer_gestures_v1) {
    wl_proxy_destroy(zwp_pointer_gestures_v1 as *mut wl_proxy);
}
/* *
 * @ingroup iface_wp_presentation
 *
 * Informs the server that the client will no longer be using
 * this protocol object. Existing objects created by this object
 * are not affected.
 */
#[inline]
unsafe extern "C" fn wp_presentation_destroy(mut wp_presentation:
                                                 *mut wp_presentation) {
    wl_proxy_marshal(wp_presentation as *mut wl_proxy, 0i32 as uint32_t);
    wl_proxy_destroy(wp_presentation as *mut wl_proxy);
}
/* *
 * @ingroup iface_zxdg_decoration_manager_v1
 *
 * Destroy the decoration manager. This doesn't destroy objects created
 * with the manager.
 */
#[inline]
unsafe extern "C" fn zxdg_decoration_manager_v1_destroy(mut zxdg_decoration_manager_v1:
                                                            *mut zxdg_decoration_manager_v1) {
    wl_proxy_marshal(zxdg_decoration_manager_v1 as *mut wl_proxy,
                     0i32 as uint32_t);
    wl_proxy_destroy(zxdg_decoration_manager_v1 as *mut wl_proxy);
}
/* *
 * @ingroup iface_xdg_wm_base
 */
#[inline]
unsafe extern "C" fn xdg_wm_base_add_listener(mut xdg_wm_base:
                                                  *mut xdg_wm_base,
                                              mut listener:
                                                  *const xdg_wm_base_listener,
                                              mut data: *mut libc::c_void)
 -> libc::c_int {
    return wl_proxy_add_listener(xdg_wm_base as *mut wl_proxy,
                                 listener as
                                     *mut Option<unsafe extern "C" fn()
                                                     -> ()>, data);
}
/* *
 * @ingroup iface_xdg_wm_base
 *
 * Destroy this xdg_wm_base object.
 *
 * Destroying a bound xdg_wm_base object while there are surfaces
 * still alive created by this xdg_wm_base object instance is illegal
 * and will result in a protocol error.
 */
#[inline]
unsafe extern "C" fn xdg_wm_base_destroy(mut xdg_wm_base: *mut xdg_wm_base) {
    wl_proxy_marshal(xdg_wm_base as *mut wl_proxy, 0i32 as uint32_t);
    wl_proxy_destroy(xdg_wm_base as *mut wl_proxy);
}
/* *
 * @ingroup iface_xdg_wm_base
 *
 * A client must respond to a ping event with a pong request or
 * the client may be deemed unresponsive. See xdg_wm_base.ping.
 */
#[inline]
unsafe extern "C" fn xdg_wm_base_pong(mut xdg_wm_base: *mut xdg_wm_base,
                                      mut serial: uint32_t) {
    wl_proxy_marshal(xdg_wm_base as *mut wl_proxy, 3i32 as uint32_t, serial);
}
/* *
 * @ingroup iface_zwp_relative_pointer_manager_v1
 *
 * Used by the client to notify the server that it will no longer use this
 * relative pointer manager object.
 */
#[inline]
unsafe extern "C" fn zwp_relative_pointer_manager_v1_destroy(mut zwp_relative_pointer_manager_v1:
                                                                 *mut zwp_relative_pointer_manager_v1) {
    wl_proxy_marshal(zwp_relative_pointer_manager_v1 as *mut wl_proxy,
                     0i32 as uint32_t);
    wl_proxy_destroy(zwp_relative_pointer_manager_v1 as *mut wl_proxy);
}
#[no_mangle]
pub unsafe extern "C" fn get_wl_backend_from_backend(mut backend:
                                                         *mut wlr_backend)
 -> *mut wlr_wl_backend {
    if wlr_backend_is_wl(backend) as libc::c_int != 0 {
    } else {
        __assert_fail(b"wlr_backend_is_wl(backend)\x00" as *const u8 as
                          *const libc::c_char,
                      b"../backend/wayland/backend.c\x00" as *const u8 as
                          *const libc::c_char, 29i32 as libc::c_uint,
                      (*::std::mem::transmute::<&[u8; 73],
                                                &[libc::c_char; 73]>(b"struct wlr_wl_backend *get_wl_backend_from_backend(struct wlr_backend *)\x00")).as_ptr());
    };
    return backend as *mut wlr_wl_backend;
}
unsafe extern "C" fn dispatch_events(mut fd: libc::c_int, mut mask: uint32_t,
                                     mut data: *mut libc::c_void)
 -> libc::c_int {
    let mut wl: *mut wlr_wl_backend = data as *mut wlr_wl_backend;
    if mask & WL_EVENT_HANGUP as libc::c_int as libc::c_uint != 0 ||
           mask & WL_EVENT_ERROR as libc::c_int as libc::c_uint != 0 {
        wl_display_terminate((*wl).local_display);
        return 0i32
    }
    if mask & WL_EVENT_READABLE as libc::c_int as libc::c_uint != 0 {
        return wl_display_dispatch((*wl).remote_display)
    }
    if mask & WL_EVENT_WRITABLE as libc::c_int as libc::c_uint != 0 {
        wl_display_flush((*wl).remote_display);
        return 0i32
    }
    if mask == 0i32 as libc::c_uint {
        let mut count: libc::c_int =
            wl_display_dispatch_pending((*wl).remote_display);
        wl_display_flush((*wl).remote_display);
        return count
    }
    return 0i32;
}
unsafe extern "C" fn xdg_wm_base_handle_ping(mut data: *mut libc::c_void,
                                             mut base: *mut xdg_wm_base,
                                             mut serial: uint32_t) {
    xdg_wm_base_pong(base, serial);
}
static mut xdg_wm_base_listener: xdg_wm_base_listener =
    unsafe {
        {
            let mut init =
                xdg_wm_base_listener{ping:
                                         Some(xdg_wm_base_handle_ping as
                                                  unsafe extern "C" fn(_:
                                                                           *mut libc::c_void,
                                                                       _:
                                                                           *mut xdg_wm_base,
                                                                       _:
                                                                           uint32_t)
                                                      -> ()),};
            init
        }
    };
unsafe extern "C" fn linux_dmabuf_v1_handle_format(mut data:
                                                       *mut libc::c_void,
                                                   mut linux_dmabuf_v1:
                                                       *mut zwp_linux_dmabuf_v1,
                                                   mut format: uint32_t) {
    // Note, this event is deprecated
    let mut wl: *mut wlr_wl_backend = data as *mut wlr_wl_backend;
    wlr_drm_format_set_add(&mut (*wl).linux_dmabuf_v1_formats, format,
                           ((0i32 as __u64) << 56i32 |
                                (1u64 <<
                                     56i32).wrapping_sub(1i32 as
                                                             libc::c_ulonglong)
                                    & 0xffffffffffffffu64) as uint64_t);
}
unsafe extern "C" fn linux_dmabuf_v1_handle_modifier(mut data:
                                                         *mut libc::c_void,
                                                     mut linux_dmabuf_v1:
                                                         *mut zwp_linux_dmabuf_v1,
                                                     mut format: uint32_t,
                                                     mut modifier_hi:
                                                         uint32_t,
                                                     mut modifier_lo:
                                                         uint32_t) {
    let mut wl: *mut wlr_wl_backend = data as *mut wlr_wl_backend;
    let mut modifier: uint64_t =
        (modifier_hi as uint64_t) << 32i32 | modifier_lo as libc::c_ulong;
    wlr_drm_format_set_add(&mut (*wl).linux_dmabuf_v1_formats, format,
                           modifier);
}
static mut linux_dmabuf_v1_listener: zwp_linux_dmabuf_v1_listener =
    unsafe {
        {
            let mut init =
                zwp_linux_dmabuf_v1_listener{format:
                                                 Some(linux_dmabuf_v1_handle_format
                                                          as
                                                          unsafe extern "C" fn(_:
                                                                                   *mut libc::c_void,
                                                                               _:
                                                                                   *mut zwp_linux_dmabuf_v1,
                                                                               _:
                                                                                   uint32_t)
                                                              -> ()),
                                             modifier:
                                                 Some(linux_dmabuf_v1_handle_modifier
                                                          as
                                                          unsafe extern "C" fn(_:
                                                                                   *mut libc::c_void,
                                                                               _:
                                                                                   *mut zwp_linux_dmabuf_v1,
                                                                               _:
                                                                                   uint32_t,
                                                                               _:
                                                                                   uint32_t,
                                                                               _:
                                                                                   uint32_t)
                                                              -> ()),};
            init
        }
    };
unsafe extern "C" fn registry_global(mut data: *mut libc::c_void,
                                     mut registry: *mut wl_registry,
                                     mut name: uint32_t,
                                     mut iface: *const libc::c_char,
                                     mut version: uint32_t) {
    let mut wl: *mut wlr_wl_backend = data as *mut wlr_wl_backend;
    _wlr_log(WLR_DEBUG,
             b"[%s:%d] Remote wayland global: %s v%d\x00" as *const u8 as
                 *const libc::c_char,
             b"../backend/wayland/backend.c\x00" as *const u8 as
                 *const libc::c_char, 93i32, iface, version);
    if strcmp(iface, wl_compositor_interface.name) == 0i32 {
        (*wl).compositor =
            wl_registry_bind(registry, name, &wl_compositor_interface,
                             4i32 as uint32_t) as *mut wl_compositor
    } else if strcmp(iface, wl_seat_interface.name) == 0i32 {
        (*wl).seat =
            wl_registry_bind(registry, name, &wl_seat_interface,
                             5i32 as uint32_t) as *mut wl_seat;
        wl_seat_add_listener((*wl).seat, &seat_listener,
                             wl as *mut libc::c_void);
    } else if strcmp(iface, xdg_wm_base_interface.name) == 0i32 {
        (*wl).xdg_wm_base =
            wl_registry_bind(registry, name, &xdg_wm_base_interface,
                             1i32 as uint32_t) as *mut xdg_wm_base;
        xdg_wm_base_add_listener((*wl).xdg_wm_base, &xdg_wm_base_listener,
                                 0 as *mut libc::c_void);
    } else if strcmp(iface, zxdg_decoration_manager_v1_interface.name) == 0i32
     {
        (*wl).zxdg_decoration_manager_v1 =
            wl_registry_bind(registry, name,
                             &zxdg_decoration_manager_v1_interface,
                             1i32 as uint32_t) as
                *mut zxdg_decoration_manager_v1
    } else if strcmp(iface, zwp_pointer_gestures_v1_interface.name) == 0i32 {
        (*wl).zwp_pointer_gestures_v1 =
            wl_registry_bind(registry, name,
                             &zwp_pointer_gestures_v1_interface,
                             1i32 as uint32_t) as *mut zwp_pointer_gestures_v1
    } else if strcmp(iface, wp_presentation_interface.name) == 0i32 {
        (*wl).presentation =
            wl_registry_bind(registry, name, &wp_presentation_interface,
                             1i32 as uint32_t) as *mut wp_presentation
    } else if strcmp(iface, zwp_tablet_manager_v2_interface.name) == 0i32 {
        (*wl).tablet_manager =
            wl_registry_bind(registry, name, &zwp_tablet_manager_v2_interface,
                             1i32 as uint32_t) as *mut zwp_tablet_manager_v2
    } else if strcmp(iface, zwp_linux_dmabuf_v1_interface.name) == 0i32 &&
                  version >= 3i32 as libc::c_uint {
        (*wl).zwp_linux_dmabuf_v1 =
            wl_registry_bind(registry, name, &zwp_linux_dmabuf_v1_interface,
                             3i32 as uint32_t) as *mut zwp_linux_dmabuf_v1;
        zwp_linux_dmabuf_v1_add_listener((*wl).zwp_linux_dmabuf_v1,
                                         &linux_dmabuf_v1_listener,
                                         wl as *mut libc::c_void);
    } else if strcmp(iface, zwp_relative_pointer_manager_v1_interface.name) ==
                  0i32 {
        (*wl).zwp_relative_pointer_manager_v1 =
            wl_registry_bind(registry, name,
                             &zwp_relative_pointer_manager_v1_interface,
                             1i32 as uint32_t) as
                *mut zwp_relative_pointer_manager_v1
    };
}
unsafe extern "C" fn registry_global_remove(mut data: *mut libc::c_void,
                                            mut registry: *mut wl_registry,
                                            mut name: uint32_t) {
    // TODO
}
static mut registry_listener: wl_registry_listener =
    unsafe {
        {
            let mut init =
                wl_registry_listener{global:
                                         Some(registry_global as
                                                  unsafe extern "C" fn(_:
                                                                           *mut libc::c_void,
                                                                       _:
                                                                           *mut wl_registry,
                                                                       _:
                                                                           uint32_t,
                                                                       _:
                                                                           *const libc::c_char,
                                                                       _:
                                                                           uint32_t)
                                                      -> ()),
                                     global_remove:
                                         Some(registry_global_remove as
                                                  unsafe extern "C" fn(_:
                                                                           *mut libc::c_void,
                                                                       _:
                                                                           *mut wl_registry,
                                                                       _:
                                                                           uint32_t)
                                                      -> ()),};
            init
        }
    };
/*
 * Initializes the wayland backend. Opens a connection to a remote wayland
 * compositor and creates surfaces for each output, then registers globals on
 * the specified display.
 */
unsafe extern "C" fn backend_start(mut backend: *mut wlr_backend) -> bool {
    let mut wl: *mut wlr_wl_backend = get_wl_backend_from_backend(backend);
    _wlr_log(WLR_INFO,
             b"[%s:%d] Initializating wayland backend\x00" as *const u8 as
                 *const libc::c_char,
             b"../backend/wayland/backend.c\x00" as *const u8 as
                 *const libc::c_char, 147i32);
    (*wl).started = 1i32 != 0;
    if !(*wl).keyboard.is_null() { create_wl_keyboard((*wl).keyboard, wl); }
    if !(*wl).tablet_manager.is_null() && !(*wl).seat.is_null() {
        wl_add_tablet_seat((*wl).tablet_manager, (*wl).seat, wl);
    }
    let mut i: size_t = 0i32 as size_t;
    while i < (*wl).requested_outputs {
        wlr_wl_output_create(&mut (*wl).backend);
        i = i.wrapping_add(1)
    }
    return 1i32 != 0;
}
unsafe extern "C" fn backend_destroy(mut backend: *mut wlr_backend) {
    if backend.is_null() { return }
    let mut wl: *mut wlr_wl_backend = get_wl_backend_from_backend(backend);
    let mut output: *mut wlr_wl_output = 0 as *mut wlr_wl_output;
    let mut tmp_output: *mut wlr_wl_output = 0 as *mut wlr_wl_output;
    output =
        ((*wl).outputs.next as *mut libc::c_char).offset(-600) as
            *mut wlr_wl_output;
    tmp_output =
        ((*output).link.next as *mut libc::c_char).offset(-600) as
            *mut wlr_wl_output;
    while &mut (*output).link as *mut wl_list !=
              &mut (*wl).outputs as *mut wl_list {
        wlr_output_destroy(&mut (*output).wlr_output);
        output = tmp_output;
        tmp_output =
            ((*output).link.next as *mut libc::c_char).offset(-600) as
                *mut wlr_wl_output
    }
    let mut input_device: *mut wlr_input_device = 0 as *mut wlr_input_device;
    let mut tmp_input_device: *mut wlr_input_device =
        0 as *mut wlr_input_device;
    input_device =
        ((*wl).devices.next as *mut libc::c_char).offset(-88) as
            *mut wlr_input_device;
    tmp_input_device =
        ((*input_device).link.next as *mut libc::c_char).offset(-88) as
            *mut wlr_input_device;
    while &mut (*input_device).link as *mut wl_list !=
              &mut (*wl).devices as *mut wl_list {
        wlr_input_device_destroy(input_device);
        input_device = tmp_input_device;
        tmp_input_device =
            ((*input_device).link.next as *mut libc::c_char).offset(-88) as
                *mut wlr_input_device
    }
    wlr_signal_emit_safe(&mut (*wl).backend.events.destroy,
                         &mut (*wl).backend as *mut wlr_backend as
                             *mut libc::c_void);
    wl_list_remove(&mut (*wl).local_display_destroy.link);
    free((*wl).seat_name as *mut libc::c_void);
    wl_event_source_remove((*wl).remote_display_src);
    wlr_renderer_destroy((*wl).renderer);
    wlr_egl_finish(&mut (*wl).egl);
    wlr_drm_format_set_finish(&mut (*wl).linux_dmabuf_v1_formats);
    if !(*wl).pointer.is_null() { wl_pointer_destroy((*wl).pointer); }
    if !(*wl).seat.is_null() { wl_seat_destroy((*wl).seat); }
    if !(*wl).zxdg_decoration_manager_v1.is_null() {
        zxdg_decoration_manager_v1_destroy((*wl).zxdg_decoration_manager_v1);
    }
    if !(*wl).zwp_pointer_gestures_v1.is_null() {
        zwp_pointer_gestures_v1_destroy((*wl).zwp_pointer_gestures_v1);
    }
    if !(*wl).presentation.is_null() {
        wp_presentation_destroy((*wl).presentation);
    }
    if !(*wl).zwp_linux_dmabuf_v1.is_null() {
        zwp_linux_dmabuf_v1_destroy((*wl).zwp_linux_dmabuf_v1);
    }
    if !(*wl).zwp_relative_pointer_manager_v1.is_null() {
        zwp_relative_pointer_manager_v1_destroy((*wl).zwp_relative_pointer_manager_v1);
    }
    xdg_wm_base_destroy((*wl).xdg_wm_base);
    wl_compositor_destroy((*wl).compositor);
    wl_registry_destroy((*wl).registry);
    wl_display_disconnect((*wl).remote_display);
    free(wl as *mut libc::c_void);
}
unsafe extern "C" fn backend_get_renderer(mut backend: *mut wlr_backend)
 -> *mut wlr_renderer {
    let mut wl: *mut wlr_wl_backend = get_wl_backend_from_backend(backend);
    return (*wl).renderer;
}
static mut backend_impl: wlr_backend_impl =
    unsafe {
        {
            let mut init =
                wlr_backend_impl{start:
                                     Some(backend_start as
                                              unsafe extern "C" fn(_:
                                                                       *mut wlr_backend)
                                                  -> bool),
                                 destroy:
                                     Some(backend_destroy as
                                              unsafe extern "C" fn(_:
                                                                       *mut wlr_backend)
                                                  -> ()),
                                 get_renderer:
                                     Some(backend_get_renderer as
                                              unsafe extern "C" fn(_:
                                                                       *mut wlr_backend)
                                                  -> *mut wlr_renderer),
                                 get_session: None,
                                 get_presentation_clock: None,};
            init
        }
    };
/* *
 * True if the given backend is a wlr_wl_backend.
 */
#[no_mangle]
pub unsafe extern "C" fn wlr_backend_is_wl(mut b: *mut wlr_backend) -> bool {
    return (*b).impl_0 ==
               &mut backend_impl as *mut wlr_backend_impl as
                   *const wlr_backend_impl;
}
unsafe extern "C" fn handle_display_destroy(mut listener: *mut wl_listener,
                                            mut data: *mut libc::c_void) {
    let mut wl: *mut wlr_wl_backend =
        (listener as *mut libc::c_char).offset(-208) as *mut wlr_wl_backend;
    backend_destroy(&mut (*wl).backend);
}
#[no_mangle]
pub unsafe extern "C" fn wlr_wl_backend_create(mut display: *mut wl_display,
                                               mut remote:
                                                   *const libc::c_char,
                                               mut create_renderer_func:
                                                   wlr_renderer_create_func_t)
 -> *mut wlr_backend {
    let mut loop_0: *mut wl_event_loop = 0 as *mut wl_event_loop;
    let mut fd: libc::c_int = 0;
    let mut events: libc::c_int = 0;
    static mut config_attribs: [EGLint; 11] =
        [0x3033i32, 0x4i32, 0x3024i32, 1i32, 0x3023i32, 1i32, 0x3022i32, 1i32,
         0x3021i32, 1i32, 0x3038i32];
    _wlr_log(WLR_INFO,
             b"[%s:%d] Creating wayland backend\x00" as *const u8 as
                 *const libc::c_char,
             b"../backend/wayland/backend.c\x00" as *const u8 as
                 *const libc::c_char, 248i32);
    let mut wl: *mut wlr_wl_backend =
        calloc(1i32 as libc::c_ulong,
               ::std::mem::size_of::<wlr_wl_backend>() as libc::c_ulong) as
            *mut wlr_wl_backend;
    if wl.is_null() {
        _wlr_log(WLR_ERROR,
                 b"[%s:%d] Allocation failed: %s\x00" as *const u8 as
                     *const libc::c_char,
                 b"../backend/wayland/backend.c\x00" as *const u8 as
                     *const libc::c_char, 252i32,
                 strerror(*__errno_location()));
        return 0 as *mut wlr_backend
    }
    wlr_backend_init(&mut (*wl).backend, &mut backend_impl);
    (*wl).local_display = display;
    wl_list_init(&mut (*wl).devices);
    wl_list_init(&mut (*wl).outputs);
    (*wl).remote_display = wl_display_connect(remote);
    if (*wl).remote_display.is_null() {
        _wlr_log(WLR_ERROR,
                 b"[%s:%d] Could not connect to remote display: %s\x00" as
                     *const u8 as *const libc::c_char,
                 b"../backend/wayland/backend.c\x00" as *const u8 as
                     *const libc::c_char, 264i32,
                 strerror(*__errno_location()));
    } else {
        (*wl).registry = wl_display_get_registry((*wl).remote_display);
        if (*wl).registry.is_null() {
            _wlr_log(WLR_ERROR,
                     b"[%s:%d] Could not obtain reference to remote registry: %s\x00"
                         as *const u8 as *const libc::c_char,
                     b"../backend/wayland/backend.c\x00" as *const u8 as
                         *const libc::c_char, 270i32,
                     strerror(*__errno_location()));
        } else {
            wl_registry_add_listener((*wl).registry, &registry_listener,
                                     wl as *mut libc::c_void);
            wl_display_dispatch((*wl).remote_display);
            wl_display_roundtrip((*wl).remote_display);
            if (*wl).compositor.is_null() {
                _wlr_log(WLR_ERROR,
                         b"[%s:%d] Remote Wayland compositor does not support wl_compositor\x00"
                             as *const u8 as *const libc::c_char,
                         b"../backend/wayland/backend.c\x00" as *const u8 as
                             *const libc::c_char, 280i32);
            } else if (*wl).xdg_wm_base.is_null() {
                _wlr_log(WLR_ERROR,
                         b"[%s:%d] Remote Wayland compositor does not support xdg-shell\x00"
                             as *const u8 as *const libc::c_char,
                         b"../backend/wayland/backend.c\x00" as *const u8 as
                             *const libc::c_char, 285i32);
            } else {
                loop_0 = wl_display_get_event_loop((*wl).local_display);
                fd = wl_display_get_fd((*wl).remote_display);
                events =
                    WL_EVENT_READABLE as libc::c_int |
                        WL_EVENT_ERROR as libc::c_int |
                        WL_EVENT_HANGUP as libc::c_int;
                (*wl).remote_display_src =
                    wl_event_loop_add_fd(loop_0, fd, events as uint32_t,
                                         Some(dispatch_events as
                                                  unsafe extern "C" fn(_:
                                                                           libc::c_int,
                                                                       _:
                                                                           uint32_t,
                                                                       _:
                                                                           *mut libc::c_void)
                                                      -> libc::c_int),
                                         wl as *mut libc::c_void);
                if (*wl).remote_display_src.is_null() {
                    _wlr_log(WLR_ERROR,
                             b"[%s:%d] Failed to create event source\x00" as
                                 *const u8 as *const libc::c_char,
                             b"../backend/wayland/backend.c\x00" as *const u8
                                 as *const libc::c_char, 295i32);
                } else {
                    wl_event_source_check((*wl).remote_display_src);
                    if create_renderer_func.is_none() {
                        create_renderer_func =
                            Some(wlr_renderer_autocreate as
                                     unsafe extern "C" fn(_: *mut wlr_egl,
                                                          _: EGLenum,
                                                          _:
                                                              *mut libc::c_void,
                                                          _: *mut EGLint,
                                                          _: EGLint)
                                         -> *mut wlr_renderer)
                    }
                    (*wl).renderer =
                        create_renderer_func.expect("non-null function pointer")(&mut (*wl).egl,
                                                                                 0x31d8i32
                                                                                     as
                                                                                     EGLenum,
                                                                                 (*wl).remote_display
                                                                                     as
                                                                                     *mut libc::c_void,
                                                                                 config_attribs.as_mut_ptr(),
                                                                                 WL_SHM_FORMAT_ARGB8888
                                                                                     as
                                                                                     libc::c_int);
                    if (*wl).renderer.is_null() {
                        _wlr_log(WLR_ERROR,
                                 b"[%s:%d] Could not create renderer\x00" as
                                     *const u8 as *const libc::c_char,
                                 b"../backend/wayland/backend.c\x00" as
                                     *const u8 as *const libc::c_char,
                                 317i32);
                        wl_event_source_remove((*wl).remote_display_src);
                    } else {
                        (*wl).local_display_destroy.notify =
                            Some(handle_display_destroy as
                                     unsafe extern "C" fn(_: *mut wl_listener,
                                                          _:
                                                              *mut libc::c_void)
                                         -> ());
                        wl_display_add_destroy_listener(display,
                                                        &mut (*wl).local_display_destroy);
                        return &mut (*wl).backend
                    }
                }
            }
            if !(*wl).compositor.is_null() {
                wl_compositor_destroy((*wl).compositor);
            }
            if !(*wl).xdg_wm_base.is_null() {
                xdg_wm_base_destroy((*wl).xdg_wm_base);
            }
            wl_registry_destroy((*wl).registry);
        }
        wl_display_disconnect((*wl).remote_display);
    }
    free(wl as *mut libc::c_void);
    return 0 as *mut wlr_backend;
}
#[no_mangle]
pub unsafe extern "C" fn wlr_wl_backend_get_remote_display(mut backend:
                                                               *mut wlr_backend)
 -> *mut wl_display {
    let mut wl: *mut wlr_wl_backend = get_wl_backend_from_backend(backend);
    return (*wl).remote_display;
}
