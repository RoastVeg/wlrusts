use libc;
extern "C" {
    pub type wl_event_source;
    pub type wl_display;
    /* Generated by wayland-scanner 1.17.0 */
    pub type wl_client;
    pub type wl_global;
    pub type wl_shm_buffer;
    pub type wlr_renderer_impl;
    pub type wlr_texture_impl;
    pub type wlr_surface;
    pub type wlr_backend_impl;
    pub type wlr_output_impl;
    #[no_mangle]
    fn __assert_fail(__assertion: *const libc::c_char,
                     __file: *const libc::c_char, __line: libc::c_uint,
                     __function: *const libc::c_char) -> !;
    #[no_mangle]
    fn calloc(_: libc::c_ulong, _: libc::c_ulong) -> *mut libc::c_void;
    #[no_mangle]
    fn free(__ptr: *mut libc::c_void);
    #[no_mangle]
    fn wlr_renderer_read_pixels(r: *mut wlr_renderer, fmt: wl_shm_format,
                                flags: *mut uint32_t, stride: uint32_t,
                                width: uint32_t, height: uint32_t,
                                src_x: uint32_t, src_y: uint32_t,
                                dst_x: uint32_t, dst_y: uint32_t,
                                data: *mut libc::c_void) -> bool;
    #[no_mangle]
    fn wlr_box_transform(dest: *mut wlr_box, box_0: *const wlr_box,
                         transform: wl_output_transform, width: libc::c_int,
                         height: libc::c_int);
    #[no_mangle]
    fn wl_list_init(list: *mut wl_list);
    #[no_mangle]
    fn wl_list_insert(list: *mut wl_list, elm: *mut wl_list);
    #[no_mangle]
    fn wl_list_remove(elm: *mut wl_list);
    #[no_mangle]
    fn wl_list_empty(list: *const wl_list) -> libc::c_int;
    #[no_mangle]
    fn wl_display_add_destroy_listener(display: *mut wl_display,
                                       listener: *mut wl_listener);
    #[no_mangle]
    fn wl_global_create(display: *mut wl_display,
                        interface: *const wl_interface, version: libc::c_int,
                        data: *mut libc::c_void, bind: wl_global_bind_func_t)
     -> *mut wl_global;
    #[no_mangle]
    fn wl_global_destroy(global: *mut wl_global);
    #[no_mangle]
    fn wl_client_post_no_memory(client: *mut wl_client);
    #[no_mangle]
    fn wl_resource_post_event(resource: *mut wl_resource, opcode: uint32_t,
                              _: ...);
    #[no_mangle]
    fn wl_resource_post_error(resource: *mut wl_resource, code: uint32_t,
                              msg: *const libc::c_char, _: ...);
    #[no_mangle]
    fn wl_resource_create(client: *mut wl_client,
                          interface: *const wl_interface,
                          version: libc::c_int, id: uint32_t)
     -> *mut wl_resource;
    #[no_mangle]
    fn wl_resource_set_implementation(resource: *mut wl_resource,
                                      implementation: *const libc::c_void,
                                      data: *mut libc::c_void,
                                      destroy: wl_resource_destroy_func_t);
    #[no_mangle]
    fn wl_resource_destroy(resource: *mut wl_resource);
    #[no_mangle]
    fn wl_resource_set_user_data(resource: *mut wl_resource,
                                 data: *mut libc::c_void);
    #[no_mangle]
    fn wl_resource_get_user_data(resource: *mut wl_resource)
     -> *mut libc::c_void;
    #[no_mangle]
    fn wl_resource_get_version(resource: *mut wl_resource) -> libc::c_int;
    #[no_mangle]
    fn wl_resource_instance_of(resource: *mut wl_resource,
                               interface: *const wl_interface,
                               implementation: *const libc::c_void)
     -> libc::c_int;
    #[no_mangle]
    fn wl_resource_add_destroy_listener(resource: *mut wl_resource,
                                        listener: *mut wl_listener);
    #[no_mangle]
    fn wl_shm_buffer_get(resource: *mut wl_resource) -> *mut wl_shm_buffer;
    #[no_mangle]
    fn wl_shm_buffer_begin_access(buffer: *mut wl_shm_buffer);
    #[no_mangle]
    fn wl_shm_buffer_end_access(buffer: *mut wl_shm_buffer);
    #[no_mangle]
    fn wl_shm_buffer_get_data(buffer: *mut wl_shm_buffer)
     -> *mut libc::c_void;
    #[no_mangle]
    fn wl_shm_buffer_get_stride(buffer: *mut wl_shm_buffer) -> int32_t;
    #[no_mangle]
    fn wl_shm_buffer_get_format(buffer: *mut wl_shm_buffer) -> uint32_t;
    #[no_mangle]
    fn wl_shm_buffer_get_width(buffer: *mut wl_shm_buffer) -> int32_t;
    #[no_mangle]
    fn wl_shm_buffer_get_height(buffer: *mut wl_shm_buffer) -> int32_t;
    #[no_mangle]
    fn pixman_region32_init_rect(region: *mut pixman_region32_t,
                                 x: libc::c_int, y: libc::c_int,
                                 width: libc::c_uint, height: libc::c_uint);
    #[no_mangle]
    fn pixman_region32_fini(region: *mut pixman_region32_t);
    #[no_mangle]
    fn pixman_region32_union(new_reg: *mut pixman_region32_t,
                             reg1: *mut pixman_region32_t,
                             reg2: *mut pixman_region32_t) -> pixman_bool_t;
    #[no_mangle]
    fn pixman_region32_intersect_rect(dest: *mut pixman_region32_t,
                                      source: *mut pixman_region32_t,
                                      x: libc::c_int, y: libc::c_int,
                                      width: libc::c_uint,
                                      height: libc::c_uint) -> pixman_bool_t;
    #[no_mangle]
    fn pixman_region32_not_empty(region: *mut pixman_region32_t)
     -> pixman_bool_t;
    #[no_mangle]
    fn pixman_region32_extents(region: *mut pixman_region32_t)
     -> *mut pixman_box32_t;
    #[no_mangle]
    fn pixman_region32_clear(region: *mut pixman_region32_t);
    /* *
 * Computes the transformed and scaled output resolution.
 */
    #[no_mangle]
    fn wlr_output_effective_resolution(output: *mut wlr_output,
                                       width: *mut libc::c_int,
                                       height: *mut libc::c_int);
    /* *
 * Get the preferred format for reading pixels.
 * This function might change the current rendering context.
 */
    #[no_mangle]
    fn wlr_output_preferred_read_format(output: *mut wlr_output,
                                        fmt: *mut wl_shm_format) -> bool;
    /* *
 * Manually schedules a `frame` event. If a `frame` event is already pending,
 * it is a no-op.
 */
    #[no_mangle]
    fn wlr_output_schedule_frame(output: *mut wlr_output);
    #[no_mangle]
    fn wlr_output_from_resource(resource: *mut wl_resource)
     -> *mut wlr_output;
    /* *
 * Locks the output to only use rendering instead of direct scan-out. This is
 * useful if direct scan-out needs to be temporarily disabled (e.g. during
 * screen capture). There must be as many unlocks as there have been locks to
 * restore the original state. There should never be an unlock before a lock.
 */
    #[no_mangle]
    fn wlr_output_lock_attach_render(output: *mut wlr_output, lock: bool);
    /* *
 * Locks the output to only use software cursors instead of hardware cursors.
 * This is useful if hardware cursors need to be temporarily disabled (e.g.
 * during screen capture). There must be as many unlocks as there have been
 * locks to restore the original state. There should never be an unlock before
 * a lock.
 */
    #[no_mangle]
    fn wlr_output_lock_software_cursors(output: *mut wlr_output, lock: bool);
    #[no_mangle]
    fn wlr_backend_get_renderer(backend: *mut wlr_backend)
     -> *mut wlr_renderer;
    #[no_mangle]
    fn _wlr_log(verbosity: wlr_log_importance, format: *const libc::c_char,
                _: ...);
    /* *
 * @page page_iface_zwlr_screencopy_manager_v1 zwlr_screencopy_manager_v1
 * @section page_iface_zwlr_screencopy_manager_v1_desc Description
 *
 * This object is a manager which offers requests to start capturing from a
 * source.
 * @section page_iface_zwlr_screencopy_manager_v1_api API
 * See @ref iface_zwlr_screencopy_manager_v1.
 */
/* *
 * @defgroup iface_zwlr_screencopy_manager_v1 The zwlr_screencopy_manager_v1 interface
 *
 * This object is a manager which offers requests to start capturing from a
 * source.
 */
    #[no_mangle]
    static zwlr_screencopy_manager_v1_interface: wl_interface;
    /* *
 * @page page_iface_zwlr_screencopy_frame_v1 zwlr_screencopy_frame_v1
 * @section page_iface_zwlr_screencopy_frame_v1_desc Description
 *
 * This object represents a single frame.
 *
 * When created, a "buffer" event will be sent. The client will then be able
 * to send a "copy" request. If the capture is successful, the compositor
 * will send a "flags" followed by a "ready" event.
 *
 * If the capture failed, the "failed" event is sent. This can happen anytime
 * before the "ready" event.
 *
 * Once either a "ready" or a "failed" event is received, the client should
 * destroy the frame.
 * @section page_iface_zwlr_screencopy_frame_v1_api API
 * See @ref iface_zwlr_screencopy_frame_v1.
 */
/* *
 * @defgroup iface_zwlr_screencopy_frame_v1 The zwlr_screencopy_frame_v1 interface
 *
 * This object represents a single frame.
 *
 * When created, a "buffer" event will be sent. The client will then be able
 * to send a "copy" request. If the capture is successful, the compositor
 * will send a "flags" followed by a "ready" event.
 *
 * If the capture failed, the "failed" event is sent. This can happen anytime
 * before the "ready" event.
 *
 * Once either a "ready" or a "failed" event is received, the client should
 * destroy the frame.
 */
    #[no_mangle]
    static zwlr_screencopy_frame_v1_interface: wl_interface;
    #[no_mangle]
    fn wlr_signal_emit_safe(signal: *mut wl_signal, data: *mut libc::c_void);
}
pub type size_t = libc::c_ulong;
pub type __int32_t = libc::c_int;
pub type __uint32_t = libc::c_uint;
pub type __time_t = libc::c_long;
pub type __syscall_slong_t = libc::c_long;
pub type int32_t = __int32_t;
pub type uint32_t = __uint32_t;
pub type time_t = __time_t;
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wl_object {
    pub interface: *const wl_interface,
    pub implementation: *const libc::c_void,
    pub id: uint32_t,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wl_interface {
    pub name: *const libc::c_char,
    pub version: libc::c_int,
    pub method_count: libc::c_int,
    pub methods: *const wl_message,
    pub event_count: libc::c_int,
    pub events: *const wl_message,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wl_message {
    pub name: *const libc::c_char,
    pub signature: *const libc::c_char,
    pub types: *mut *const wl_interface,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wl_list {
    pub prev: *mut wl_list,
    pub next: *mut wl_list,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wl_listener {
    pub link: wl_list,
    pub notify: wl_notify_func_t,
}
pub type wl_notify_func_t
    =
    Option<unsafe extern "C" fn(_: *mut wl_listener, _: *mut libc::c_void)
               -> ()>;
pub type wl_global_bind_func_t
    =
    Option<unsafe extern "C" fn(_: *mut wl_client, _: *mut libc::c_void,
                                _: uint32_t, _: uint32_t) -> ()>;
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wl_resource {
    pub object: wl_object,
    pub destroy: wl_resource_destroy_func_t,
    pub link: wl_list,
    pub destroy_signal: wl_signal,
    pub client: *mut wl_client,
    pub data: *mut libc::c_void,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wl_signal {
    pub listener_list: wl_list,
}
pub type wl_resource_destroy_func_t
    =
    Option<unsafe extern "C" fn(_: *mut wl_resource) -> ()>;
pub type wl_shm_format = libc::c_uint;
pub const WL_SHM_FORMAT_YVU444: wl_shm_format = 875714137;
pub const WL_SHM_FORMAT_YUV444: wl_shm_format = 875713881;
pub const WL_SHM_FORMAT_YVU422: wl_shm_format = 909203033;
pub const WL_SHM_FORMAT_YUV422: wl_shm_format = 909202777;
pub const WL_SHM_FORMAT_YVU420: wl_shm_format = 842094169;
pub const WL_SHM_FORMAT_YUV420: wl_shm_format = 842093913;
pub const WL_SHM_FORMAT_YVU411: wl_shm_format = 825316953;
pub const WL_SHM_FORMAT_YUV411: wl_shm_format = 825316697;
pub const WL_SHM_FORMAT_YVU410: wl_shm_format = 961893977;
pub const WL_SHM_FORMAT_YUV410: wl_shm_format = 961959257;
pub const WL_SHM_FORMAT_NV61: wl_shm_format = 825644622;
pub const WL_SHM_FORMAT_NV16: wl_shm_format = 909203022;
pub const WL_SHM_FORMAT_NV21: wl_shm_format = 825382478;
pub const WL_SHM_FORMAT_NV12: wl_shm_format = 842094158;
pub const WL_SHM_FORMAT_AYUV: wl_shm_format = 1448433985;
pub const WL_SHM_FORMAT_VYUY: wl_shm_format = 1498765654;
pub const WL_SHM_FORMAT_UYVY: wl_shm_format = 1498831189;
pub const WL_SHM_FORMAT_YVYU: wl_shm_format = 1431918169;
pub const WL_SHM_FORMAT_YUYV: wl_shm_format = 1448695129;
pub const WL_SHM_FORMAT_BGRA1010102: wl_shm_format = 808665410;
pub const WL_SHM_FORMAT_RGBA1010102: wl_shm_format = 808665426;
pub const WL_SHM_FORMAT_ABGR2101010: wl_shm_format = 808665665;
pub const WL_SHM_FORMAT_ARGB2101010: wl_shm_format = 808669761;
pub const WL_SHM_FORMAT_BGRX1010102: wl_shm_format = 808671298;
pub const WL_SHM_FORMAT_RGBX1010102: wl_shm_format = 808671314;
pub const WL_SHM_FORMAT_XBGR2101010: wl_shm_format = 808665688;
pub const WL_SHM_FORMAT_XRGB2101010: wl_shm_format = 808669784;
pub const WL_SHM_FORMAT_BGRA8888: wl_shm_format = 875708738;
pub const WL_SHM_FORMAT_RGBA8888: wl_shm_format = 875708754;
pub const WL_SHM_FORMAT_ABGR8888: wl_shm_format = 875708993;
pub const WL_SHM_FORMAT_BGRX8888: wl_shm_format = 875714626;
pub const WL_SHM_FORMAT_RGBX8888: wl_shm_format = 875714642;
pub const WL_SHM_FORMAT_XBGR8888: wl_shm_format = 875709016;
pub const WL_SHM_FORMAT_BGR888: wl_shm_format = 875710274;
pub const WL_SHM_FORMAT_RGB888: wl_shm_format = 875710290;
pub const WL_SHM_FORMAT_BGR565: wl_shm_format = 909199170;
pub const WL_SHM_FORMAT_RGB565: wl_shm_format = 909199186;
pub const WL_SHM_FORMAT_BGRA5551: wl_shm_format = 892420418;
pub const WL_SHM_FORMAT_RGBA5551: wl_shm_format = 892420434;
pub const WL_SHM_FORMAT_ABGR1555: wl_shm_format = 892420673;
pub const WL_SHM_FORMAT_ARGB1555: wl_shm_format = 892424769;
pub const WL_SHM_FORMAT_BGRX5551: wl_shm_format = 892426306;
pub const WL_SHM_FORMAT_RGBX5551: wl_shm_format = 892426322;
pub const WL_SHM_FORMAT_XBGR1555: wl_shm_format = 892420696;
pub const WL_SHM_FORMAT_XRGB1555: wl_shm_format = 892424792;
pub const WL_SHM_FORMAT_BGRA4444: wl_shm_format = 842088770;
pub const WL_SHM_FORMAT_RGBA4444: wl_shm_format = 842088786;
pub const WL_SHM_FORMAT_ABGR4444: wl_shm_format = 842089025;
pub const WL_SHM_FORMAT_ARGB4444: wl_shm_format = 842093121;
pub const WL_SHM_FORMAT_BGRX4444: wl_shm_format = 842094658;
pub const WL_SHM_FORMAT_RGBX4444: wl_shm_format = 842094674;
pub const WL_SHM_FORMAT_XBGR4444: wl_shm_format = 842089048;
pub const WL_SHM_FORMAT_XRGB4444: wl_shm_format = 842093144;
pub const WL_SHM_FORMAT_BGR233: wl_shm_format = 944916290;
pub const WL_SHM_FORMAT_RGB332: wl_shm_format = 943867730;
pub const WL_SHM_FORMAT_C8: wl_shm_format = 538982467;
pub const WL_SHM_FORMAT_XRGB8888: wl_shm_format = 1;
pub const WL_SHM_FORMAT_ARGB8888: wl_shm_format = 0;
pub type wl_output_subpixel = libc::c_uint;
pub const WL_OUTPUT_SUBPIXEL_VERTICAL_BGR: wl_output_subpixel = 5;
pub const WL_OUTPUT_SUBPIXEL_VERTICAL_RGB: wl_output_subpixel = 4;
pub const WL_OUTPUT_SUBPIXEL_HORIZONTAL_BGR: wl_output_subpixel = 3;
pub const WL_OUTPUT_SUBPIXEL_HORIZONTAL_RGB: wl_output_subpixel = 2;
pub const WL_OUTPUT_SUBPIXEL_NONE: wl_output_subpixel = 1;
pub const WL_OUTPUT_SUBPIXEL_UNKNOWN: wl_output_subpixel = 0;
pub type wl_output_transform = libc::c_uint;
pub const WL_OUTPUT_TRANSFORM_FLIPPED_270: wl_output_transform = 7;
pub const WL_OUTPUT_TRANSFORM_FLIPPED_180: wl_output_transform = 6;
pub const WL_OUTPUT_TRANSFORM_FLIPPED_90: wl_output_transform = 5;
pub const WL_OUTPUT_TRANSFORM_FLIPPED: wl_output_transform = 4;
pub const WL_OUTPUT_TRANSFORM_270: wl_output_transform = 3;
pub const WL_OUTPUT_TRANSFORM_180: wl_output_transform = 2;
pub const WL_OUTPUT_TRANSFORM_90: wl_output_transform = 1;
pub const WL_OUTPUT_TRANSFORM_NORMAL: wl_output_transform = 0;
pub type pixman_bool_t = libc::c_int;
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct pixman_region32_data {
    pub size: libc::c_long,
    pub numRects: libc::c_long,
}
pub type pixman_region32_data_t = pixman_region32_data;
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct pixman_box32 {
    pub x1: int32_t,
    pub y1: int32_t,
    pub x2: int32_t,
    pub y2: int32_t,
}
pub type pixman_box32_t = pixman_box32;
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct pixman_region32 {
    pub extents: pixman_box32_t,
    pub data: *mut pixman_region32_data_t,
}
pub type pixman_region32_t = pixman_region32;
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wlr_renderer {
    pub impl_0: *const wlr_renderer_impl,
    pub events: C2RustUnnamed,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct C2RustUnnamed {
    pub destroy: wl_signal,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wlr_texture {
    pub impl_0: *const wlr_texture_impl,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wlr_box {
    pub x: libc::c_int,
    pub y: libc::c_int,
    pub width: libc::c_int,
    pub height: libc::c_int,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wlr_buffer {
    pub resource: *mut wl_resource,
    pub texture: *mut wlr_texture,
    pub released: bool,
    pub n_refs: size_t,
    pub resource_destroy: wl_listener,
}
/*
 * This an unstable interface of wlroots. No guarantees are made regarding the
 * future consistency of this API.
 */
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wlr_output_mode {
    pub width: int32_t,
    pub height: int32_t,
    pub refresh: int32_t,
    pub preferred: bool,
    pub link: wl_list,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wlr_output_cursor {
    pub output: *mut wlr_output,
    pub x: libc::c_double,
    pub y: libc::c_double,
    pub enabled: bool,
    pub visible: bool,
    pub width: uint32_t,
    pub height: uint32_t,
    pub hotspot_x: int32_t,
    pub hotspot_y: int32_t,
    pub link: wl_list,
    pub texture: *mut wlr_texture,
    pub surface: *mut wlr_surface,
    pub surface_commit: wl_listener,
    pub surface_destroy: wl_listener,
    pub events: C2RustUnnamed_0,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct C2RustUnnamed_0 {
    pub destroy: wl_signal,
}
/* *
 * A compositor output region. This typically corresponds to a monitor that
 * displays part of the compositor space.
 *
 * The `frame` event will be emitted when it is a good time for the compositor
 * to submit a new frame.
 *
 * To render a new frame, compositors should call `wlr_output_attach_render`,
 * render and call `wlr_output_commit`. No rendering should happen outside a
 * `frame` event handler or before `wlr_output_attach_render`.
 */
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wlr_output {
    pub impl_0: *const wlr_output_impl,
    pub backend: *mut wlr_backend,
    pub display: *mut wl_display,
    pub global: *mut wl_global,
    pub resources: wl_list,
    pub name: [libc::c_char; 24],
    pub make: [libc::c_char; 56],
    pub model: [libc::c_char; 16],
    pub serial: [libc::c_char; 16],
    pub phys_width: int32_t,
    pub phys_height: int32_t,
    pub modes: wl_list,
    pub current_mode: *mut wlr_output_mode,
    pub width: int32_t,
    pub height: int32_t,
    pub refresh: int32_t,
    pub enabled: bool,
    pub scale: libc::c_float,
    pub subpixel: wl_output_subpixel,
    pub transform: wl_output_transform,
    pub needs_frame: bool,
    pub damage: pixman_region32_t,
    pub frame_pending: bool,
    pub transform_matrix: [libc::c_float; 9],
    pub pending: wlr_output_state,
    pub commit_seq: uint32_t,
    pub events: C2RustUnnamed_1,
    pub idle_frame: *mut wl_event_source,
    pub idle_done: *mut wl_event_source,
    pub attach_render_locks: libc::c_int,
    pub cursors: wl_list,
    pub hardware_cursor: *mut wlr_output_cursor,
    pub software_cursor_locks: libc::c_int,
    pub display_destroy: wl_listener,
    pub data: *mut libc::c_void,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct C2RustUnnamed_1 {
    pub frame: wl_signal,
    pub needs_frame: wl_signal,
    pub precommit: wl_signal,
    pub commit: wl_signal,
    pub present: wl_signal,
    pub enable: wl_signal,
    pub mode: wl_signal,
    pub scale: wl_signal,
    pub transform: wl_signal,
    pub destroy: wl_signal,
}
/* *
 * Holds the double-buffered output state.
 */
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wlr_output_state {
    pub committed: uint32_t,
    pub damage: pixman_region32_t,
    pub buffer_type: wlr_output_state_buffer_type,
    pub buffer: *mut wlr_buffer,
    // if WLR_OUTPUT_STATE_BUFFER_SCANOUT
}
pub type wlr_output_state_buffer_type = libc::c_uint;
pub const WLR_OUTPUT_STATE_BUFFER_SCANOUT: wlr_output_state_buffer_type = 1;
pub const WLR_OUTPUT_STATE_BUFFER_RENDER: wlr_output_state_buffer_type = 0;
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wlr_backend {
    pub impl_0: *const wlr_backend_impl,
    pub events: C2RustUnnamed_2,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct C2RustUnnamed_2 {
    pub destroy: wl_signal,
    pub new_input: wl_signal,
    pub new_output: wl_signal,
}
pub type wlr_output_state_field = libc::c_uint;
pub const WLR_OUTPUT_STATE_DAMAGE: wlr_output_state_field = 2;
pub const WLR_OUTPUT_STATE_BUFFER: wlr_output_state_field = 1;
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wlr_output_event_precommit {
    pub output: *mut wlr_output,
    pub when: *mut timespec,
}
/*
 * This an unstable interface of wlroots. No guarantees are made regarding the
 * future consistency of this API.
 */
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wlr_screencopy_manager_v1 {
    pub global: *mut wl_global,
    pub frames: wl_list,
    pub display_destroy: wl_listener,
    pub events: C2RustUnnamed_3,
    pub data: *mut libc::c_void,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct C2RustUnnamed_3 {
    pub destroy: wl_signal,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wlr_screencopy_v1_client {
    pub ref_0: libc::c_int,
    pub manager: *mut wlr_screencopy_manager_v1,
    pub damages: wl_list,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct wlr_screencopy_frame_v1 {
    pub resource: *mut wl_resource,
    pub client: *mut wlr_screencopy_v1_client,
    pub link: wl_list,
    pub format: wl_shm_format,
    pub box_0: wlr_box,
    pub stride: libc::c_int,
    pub overlay_cursor: bool,
    pub cursor_locked: bool,
    pub with_damage: bool,
    pub buffer: *mut wl_shm_buffer,
    pub buffer_destroy: wl_listener,
    pub output: *mut wlr_output,
    pub output_precommit: wl_listener,
    pub output_destroy: wl_listener,
    pub output_enable: wl_listener,
    pub data: *mut libc::c_void,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct screencopy_damage {
    pub link: wl_list,
    pub output: *mut wlr_output,
    pub damage: pixman_region32,
    pub output_precommit: wl_listener,
    pub output_destroy: wl_listener,
    pub last_commit_seq: uint32_t,
}
/* *
 * @ingroup iface_zwlr_screencopy_manager_v1
 * @struct zwlr_screencopy_manager_v1_interface
 */
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct zwlr_screencopy_manager_v1_interface {
    pub capture_output: Option<unsafe extern "C" fn(_: *mut wl_client,
                                                    _: *mut wl_resource,
                                                    _: uint32_t, _: int32_t,
                                                    _: *mut wl_resource)
                                   -> ()>,
    pub capture_output_region: Option<unsafe extern "C" fn(_: *mut wl_client,
                                                           _:
                                                               *mut wl_resource,
                                                           _: uint32_t,
                                                           _: int32_t,
                                                           _:
                                                               *mut wl_resource,
                                                           _: int32_t,
                                                           _: int32_t,
                                                           _: int32_t,
                                                           _: int32_t) -> ()>,
    pub destroy: Option<unsafe extern "C" fn(_: *mut wl_client,
                                             _: *mut wl_resource) -> ()>,
}
pub type wlr_log_importance = libc::c_uint;
pub const WLR_LOG_IMPORTANCE_LAST: wlr_log_importance = 4;
pub const WLR_DEBUG: wlr_log_importance = 3;
pub const WLR_INFO: wlr_log_importance = 2;
pub const WLR_ERROR: wlr_log_importance = 1;
pub const WLR_SILENT: wlr_log_importance = 0;
/* ZWLR_SCREENCOPY_FRAME_V1_FLAGS_ENUM */
/* *
 * @ingroup iface_zwlr_screencopy_frame_v1
 * @struct zwlr_screencopy_frame_v1_interface
 */
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct zwlr_screencopy_frame_v1_interface {
    pub copy: Option<unsafe extern "C" fn(_: *mut wl_client,
                                          _: *mut wl_resource,
                                          _: *mut wl_resource) -> ()>,
    pub destroy: Option<unsafe extern "C" fn(_: *mut wl_client,
                                             _: *mut wl_resource) -> ()>,
    pub copy_with_damage: Option<unsafe extern "C" fn(_: *mut wl_client,
                                                      _: *mut wl_resource,
                                                      _: *mut wl_resource)
                                     -> ()>,
}
/* *
	 * the object has already been used to copy a wl_buffer
	 */
pub const ZWLR_SCREENCOPY_FRAME_V1_ERROR_ALREADY_USED:
          zwlr_screencopy_frame_v1_error =
    0;
/* *
	 * buffer attributes are invalid
	 */
pub const ZWLR_SCREENCOPY_FRAME_V1_ERROR_INVALID_BUFFER:
          zwlr_screencopy_frame_v1_error =
    1;
/* *
 * @ingroup iface_zwlr_screencopy_manager_v1
 */
/* *
 * @ingroup iface_zwlr_screencopy_manager_v1
 */
/* *
 * @ingroup iface_zwlr_screencopy_manager_v1
 */
pub type zwlr_screencopy_frame_v1_error = libc::c_uint;
#[inline]
unsafe extern "C" fn wl_signal_init(mut signal: *mut wl_signal) {
    wl_list_init(&mut (*signal).listener_list);
}
#[inline]
unsafe extern "C" fn wl_signal_add(mut signal: *mut wl_signal,
                                   mut listener: *mut wl_listener) {
    wl_list_insert((*signal).listener_list.prev, &mut (*listener).link);
}
/* *
 * @ingroup iface_zwlr_screencopy_frame_v1
 */
/* *
 * @ingroup iface_zwlr_screencopy_frame_v1
 */
/* *
 * @ingroup iface_zwlr_screencopy_frame_v1
 */
/* *
 * @ingroup iface_zwlr_screencopy_frame_v1
 */
/* *
 * @ingroup iface_zwlr_screencopy_frame_v1
 */
/* *
 * @ingroup iface_zwlr_screencopy_frame_v1
 */
/* *
 * @ingroup iface_zwlr_screencopy_frame_v1
 */
/* *
 * @ingroup iface_zwlr_screencopy_frame_v1
 */
/* *
 * @ingroup iface_zwlr_screencopy_frame_v1
 * Sends an buffer event to the client owning the resource.
 * @param resource_ The client's resource
 * @param format buffer format
 * @param width buffer width
 * @param height buffer height
 * @param stride buffer stride
 */
#[inline]
unsafe extern "C" fn zwlr_screencopy_frame_v1_send_buffer(mut resource_:
                                                              *mut wl_resource,
                                                          mut format:
                                                              uint32_t,
                                                          mut width: uint32_t,
                                                          mut height:
                                                              uint32_t,
                                                          mut stride:
                                                              uint32_t) {
    wl_resource_post_event(resource_, 0i32 as uint32_t, format, width, height,
                           stride);
}
/* *
 * @ingroup iface_zwlr_screencopy_frame_v1
 * Sends an flags event to the client owning the resource.
 * @param resource_ The client's resource
 * @param flags frame flags
 */
#[inline]
unsafe extern "C" fn zwlr_screencopy_frame_v1_send_flags(mut resource_:
                                                             *mut wl_resource,
                                                         mut flags:
                                                             uint32_t) {
    wl_resource_post_event(resource_, 1i32 as uint32_t, flags);
}
/* *
 * @ingroup iface_zwlr_screencopy_frame_v1
 * Sends an ready event to the client owning the resource.
 * @param resource_ The client's resource
 * @param tv_sec_hi high 32 bits of the seconds part of the timestamp
 * @param tv_sec_lo low 32 bits of the seconds part of the timestamp
 * @param tv_nsec nanoseconds part of the timestamp
 */
#[inline]
unsafe extern "C" fn zwlr_screencopy_frame_v1_send_ready(mut resource_:
                                                             *mut wl_resource,
                                                         mut tv_sec_hi:
                                                             uint32_t,
                                                         mut tv_sec_lo:
                                                             uint32_t,
                                                         mut tv_nsec:
                                                             uint32_t) {
    wl_resource_post_event(resource_, 2i32 as uint32_t, tv_sec_hi, tv_sec_lo,
                           tv_nsec);
}
/* *
 * @ingroup iface_zwlr_screencopy_frame_v1
 * Sends an failed event to the client owning the resource.
 * @param resource_ The client's resource
 */
#[inline]
unsafe extern "C" fn zwlr_screencopy_frame_v1_send_failed(mut resource_:
                                                              *mut wl_resource) {
    wl_resource_post_event(resource_, 3i32 as uint32_t);
}
/* *
 * @ingroup iface_zwlr_screencopy_frame_v1
 * Sends an damage event to the client owning the resource.
 * @param resource_ The client's resource
 * @param x damaged x coordinates
 * @param y damaged y coordinates
 * @param width current width
 * @param height current height
 */
#[inline]
unsafe extern "C" fn zwlr_screencopy_frame_v1_send_damage(mut resource_:
                                                              *mut wl_resource,
                                                          mut x: uint32_t,
                                                          mut y: uint32_t,
                                                          mut width: uint32_t,
                                                          mut height:
                                                              uint32_t) {
    wl_resource_post_event(resource_, 4i32 as uint32_t, x, y, width, height);
}
unsafe extern "C" fn screencopy_damage_find(mut client:
                                                *mut wlr_screencopy_v1_client,
                                            mut output: *mut wlr_output)
 -> *mut screencopy_damage {
    let mut damage: *mut screencopy_damage = 0 as *mut screencopy_damage;
    damage =
        ((*client).damages.next as *mut libc::c_char).offset(-0) as
            *mut screencopy_damage;
    while &mut (*damage).link as *mut wl_list !=
              &mut (*client).damages as *mut wl_list {
        if (*damage).output == output { return damage }
        damage =
            ((*damage).link.next as *mut libc::c_char).offset(-0) as
                *mut screencopy_damage
    }
    return 0 as *mut screencopy_damage;
}
unsafe extern "C" fn screencopy_damage_accumulate(mut damage:
                                                      *mut screencopy_damage) {
    let mut region: *mut pixman_region32 = &mut (*damage).damage;
    let mut output: *mut wlr_output = (*damage).output;
    /* This check is done so damage that has been added and cleared in the
	 * frame precommit handler is not added again after it has been handled.
	 */
    if (*damage).last_commit_seq == (*output).commit_seq { return }
    pixman_region32_union(region, region, &mut (*output).pending.damage);
    pixman_region32_intersect_rect(region, region, 0i32, 0i32,
                                   (*output).width as libc::c_uint,
                                   (*output).height as libc::c_uint);
    (*damage).last_commit_seq = (*output).commit_seq;
}
unsafe extern "C" fn screencopy_damage_handle_output_precommit(mut listener:
                                                                   *mut wl_listener,
                                                               mut data:
                                                                   *mut libc::c_void) {
    let mut damage: *mut screencopy_damage =
        (listener as *mut libc::c_char).offset(-48) as *mut screencopy_damage;
    screencopy_damage_accumulate(damage);
}
unsafe extern "C" fn screencopy_damage_destroy(mut damage:
                                                   *mut screencopy_damage) {
    wl_list_remove(&mut (*damage).output_destroy.link);
    wl_list_remove(&mut (*damage).output_precommit.link);
    wl_list_remove(&mut (*damage).link);
    pixman_region32_fini(&mut (*damage).damage);
    free(damage as *mut libc::c_void);
}
unsafe extern "C" fn screencopy_damage_handle_output_destroy(mut listener:
                                                                 *mut wl_listener,
                                                             mut data:
                                                                 *mut libc::c_void) {
    let mut damage: *mut screencopy_damage =
        (listener as *mut libc::c_char).offset(-72) as *mut screencopy_damage;
    screencopy_damage_destroy(damage);
}
unsafe extern "C" fn screencopy_damage_create(mut client:
                                                  *mut wlr_screencopy_v1_client,
                                              mut output: *mut wlr_output)
 -> *mut screencopy_damage {
    let mut damage: *mut screencopy_damage =
        calloc(1i32 as libc::c_ulong,
               ::std::mem::size_of::<screencopy_damage>() as libc::c_ulong) as
            *mut screencopy_damage;
    if damage.is_null() { return 0 as *mut screencopy_damage }
    (*damage).output = output;
    (*damage).last_commit_seq =
        (*output).commit_seq.wrapping_sub(1i32 as libc::c_uint);
    pixman_region32_init_rect(&mut (*damage).damage, 0i32, 0i32,
                              (*output).width as libc::c_uint,
                              (*output).height as libc::c_uint);
    wl_list_insert(&mut (*client).damages, &mut (*damage).link);
    wl_signal_add(&mut (*output).events.precommit,
                  &mut (*damage).output_precommit);
    (*damage).output_precommit.notify =
        Some(screencopy_damage_handle_output_precommit as
                 unsafe extern "C" fn(_: *mut wl_listener,
                                      _: *mut libc::c_void) -> ());
    wl_signal_add(&mut (*output).events.destroy,
                  &mut (*damage).output_destroy);
    (*damage).output_destroy.notify =
        Some(screencopy_damage_handle_output_destroy as
                 unsafe extern "C" fn(_: *mut wl_listener,
                                      _: *mut libc::c_void) -> ());
    return damage;
}
unsafe extern "C" fn screencopy_damage_get_or_create(mut client:
                                                         *mut wlr_screencopy_v1_client,
                                                     mut output:
                                                         *mut wlr_output)
 -> *mut screencopy_damage {
    let mut damage: *mut screencopy_damage =
        screencopy_damage_find(client, output);
    return if !damage.is_null() {
               damage
           } else { screencopy_damage_create(client, output) };
}
unsafe extern "C" fn client_unref(mut client: *mut wlr_screencopy_v1_client) {
    if (*client).ref_0 > 0i32 {
    } else {
        __assert_fail(b"client->ref > 0\x00" as *const u8 as
                          *const libc::c_char,
                      b"../types/wlr_screencopy_v1.c\x00" as *const u8 as
                          *const libc::c_char, 110i32 as libc::c_uint,
                      (*::std::mem::transmute::<&[u8; 53],
                                                &[libc::c_char; 53]>(b"void client_unref(struct wlr_screencopy_v1_client *)\x00")).as_ptr());
    };
    (*client).ref_0 -= 1;
    if (*client).ref_0 != 0i32 { return }
    let mut damage: *mut screencopy_damage = 0 as *mut screencopy_damage;
    let mut tmp_damage: *mut screencopy_damage = 0 as *mut screencopy_damage;
    damage =
        ((*client).damages.next as *mut libc::c_char).offset(-0) as
            *mut screencopy_damage;
    tmp_damage =
        ((*damage).link.next as *mut libc::c_char).offset(-0) as
            *mut screencopy_damage;
    while &mut (*damage).link as *mut wl_list !=
              &mut (*client).damages as *mut wl_list {
        screencopy_damage_destroy(damage);
        damage = tmp_damage;
        tmp_damage =
            ((*damage).link.next as *mut libc::c_char).offset(-0) as
                *mut screencopy_damage
    }
    free(client as *mut libc::c_void);
}
unsafe extern "C" fn frame_from_resource(mut resource: *mut wl_resource)
 -> *mut wlr_screencopy_frame_v1 {
    if wl_resource_instance_of(resource, &zwlr_screencopy_frame_v1_interface,
                               &frame_impl as
                                   *const zwlr_screencopy_frame_v1_interface
                                   as *const libc::c_void) != 0 {
    } else {
        __assert_fail(b"wl_resource_instance_of(resource, &zwlr_screencopy_frame_v1_interface, &frame_impl)\x00"
                          as *const u8 as *const libc::c_char,
                      b"../types/wlr_screencopy_v1.c\x00" as *const u8 as
                          *const libc::c_char, 127i32 as libc::c_uint,
                      (*::std::mem::transmute::<&[u8; 74],
                                                &[libc::c_char; 74]>(b"struct wlr_screencopy_frame_v1 *frame_from_resource(struct wl_resource *)\x00")).as_ptr());
    };
    return wl_resource_get_user_data(resource) as
               *mut wlr_screencopy_frame_v1;
}
unsafe extern "C" fn frame_destroy(mut frame: *mut wlr_screencopy_frame_v1) {
    if frame.is_null() { return }
    if !(*frame).output.is_null() && !(*frame).buffer.is_null() {
        wlr_output_lock_attach_render((*frame).output, 0i32 != 0);
        if (*frame).cursor_locked {
            wlr_output_lock_software_cursors((*frame).output, 0i32 != 0);
        }
    }
    wl_list_remove(&mut (*frame).link);
    wl_list_remove(&mut (*frame).output_precommit.link);
    wl_list_remove(&mut (*frame).output_destroy.link);
    wl_list_remove(&mut (*frame).output_enable.link);
    wl_list_remove(&mut (*frame).buffer_destroy.link);
    // Make the frame resource inert
    wl_resource_set_user_data((*frame).resource, 0 as *mut libc::c_void);
    client_unref((*frame).client);
    free(frame as *mut libc::c_void);
}
unsafe extern "C" fn frame_handle_output_precommit(mut listener:
                                                       *mut wl_listener,
                                                   mut _data:
                                                       *mut libc::c_void) {
    let mut frame: *mut wlr_screencopy_frame_v1 =
        (listener as *mut libc::c_char).offset(-104) as
            *mut wlr_screencopy_frame_v1;
    let mut event: *mut wlr_output_event_precommit =
        _data as *mut wlr_output_event_precommit;
    let mut output: *mut wlr_output = (*frame).output;
    let mut renderer: *mut wlr_renderer =
        wlr_backend_get_renderer((*output).backend);
    if !renderer.is_null() {
    } else {
        __assert_fail(b"renderer\x00" as *const u8 as *const libc::c_char,
                      b"../types/wlr_screencopy_v1.c\x00" as *const u8 as
                          *const libc::c_char, 159i32 as libc::c_uint,
                      (*::std::mem::transmute::<&[u8; 65],
                                                &[libc::c_char; 65]>(b"void frame_handle_output_precommit(struct wl_listener *, void *)\x00")).as_ptr());
    };
    if (*output).pending.committed &
           WLR_OUTPUT_STATE_BUFFER as libc::c_int as libc::c_uint == 0 {
        return
    }
    let mut damage: *mut screencopy_damage = 0 as *mut screencopy_damage;
    if (*frame).with_damage {
        damage = screencopy_damage_get_or_create((*frame).client, output);
        if !damage.is_null() {
            screencopy_damage_accumulate(damage);
            if pixman_region32_not_empty(&mut (*damage).damage) == 0 {
                return
            }
        }
    }
    wl_list_remove(&mut (*frame).output_precommit.link);
    wl_list_init(&mut (*frame).output_precommit.link);
    let mut x: libc::c_int = (*frame).box_0.x;
    let mut y: libc::c_int = (*frame).box_0.y;
    let mut buffer: *mut wl_shm_buffer = (*frame).buffer;
    if !buffer.is_null() {
    } else {
        __assert_fail(b"buffer != NULL\x00" as *const u8 as
                          *const libc::c_char,
                      b"../types/wlr_screencopy_v1.c\x00" as *const u8 as
                          *const libc::c_char, 183i32 as libc::c_uint,
                      (*::std::mem::transmute::<&[u8; 65],
                                                &[libc::c_char; 65]>(b"void frame_handle_output_precommit(struct wl_listener *, void *)\x00")).as_ptr());
    };
    let mut fmt: wl_shm_format =
        wl_shm_buffer_get_format(buffer) as wl_shm_format;
    let mut width: int32_t = wl_shm_buffer_get_width(buffer);
    let mut height: int32_t = wl_shm_buffer_get_height(buffer);
    let mut stride: int32_t = wl_shm_buffer_get_stride(buffer);
    wl_shm_buffer_begin_access(buffer);
    let mut data: *mut libc::c_void = wl_shm_buffer_get_data(buffer);
    let mut flags: uint32_t = 0i32 as uint32_t;
    let mut ok: bool =
        wlr_renderer_read_pixels(renderer, fmt, &mut flags,
                                 stride as uint32_t, width as uint32_t,
                                 height as uint32_t, x as uint32_t,
                                 y as uint32_t, 0i32 as uint32_t,
                                 0i32 as uint32_t, data);
    wl_shm_buffer_end_access(buffer);
    if !ok {
        zwlr_screencopy_frame_v1_send_failed((*frame).resource);
        frame_destroy(frame);
        return
    }
    zwlr_screencopy_frame_v1_send_flags((*frame).resource, flags);
    // TODO: send fine-grained damage events
    if !damage.is_null() {
        let mut damage_box: *mut pixman_box32 =
            pixman_region32_extents(&mut (*damage).damage);
        let mut damage_x: libc::c_int = (*damage_box).x1;
        let mut damage_y: libc::c_int = (*damage_box).y1;
        let mut damage_width: libc::c_int =
            (*damage_box).x2 - (*damage_box).x1;
        let mut damage_height: libc::c_int =
            (*damage_box).y2 - (*damage_box).y1;
        zwlr_screencopy_frame_v1_send_damage((*frame).resource,
                                             damage_x as uint32_t,
                                             damage_y as uint32_t,
                                             damage_width as uint32_t,
                                             damage_height as uint32_t);
        pixman_region32_clear(&mut (*damage).damage);
    }
    let mut tv_sec: time_t = (*(*event).when).tv_sec;
    let mut tv_sec_hi: uint32_t =
        if ::std::mem::size_of::<time_t>() as libc::c_ulong >
               4i32 as libc::c_ulong {
            (tv_sec) >> 32i32
        } else { 0i32 as libc::c_long } as uint32_t;
    let mut tv_sec_lo: uint32_t =
        (tv_sec & 0xffffffffu32 as libc::c_long) as uint32_t;
    zwlr_screencopy_frame_v1_send_ready((*frame).resource, tv_sec_hi,
                                        tv_sec_lo,
                                        (*(*event).when).tv_nsec as uint32_t);
    frame_destroy(frame);
}
unsafe extern "C" fn frame_handle_output_enable(mut listener:
                                                    *mut wl_listener,
                                                mut data: *mut libc::c_void) {
    let mut frame: *mut wlr_screencopy_frame_v1 =
        (listener as *mut libc::c_char).offset(-152) as
            *mut wlr_screencopy_frame_v1;
    if !(*(*frame).output).enabled {
        zwlr_screencopy_frame_v1_send_failed((*frame).resource);
        frame_destroy(frame);
    };
}
unsafe extern "C" fn frame_handle_output_destroy(mut listener:
                                                     *mut wl_listener,
                                                 mut data:
                                                     *mut libc::c_void) {
    let mut frame: *mut wlr_screencopy_frame_v1 =
        (listener as *mut libc::c_char).offset(-128) as
            *mut wlr_screencopy_frame_v1;
    zwlr_screencopy_frame_v1_send_failed((*frame).resource);
    frame_destroy(frame);
}
unsafe extern "C" fn frame_handle_buffer_destroy(mut listener:
                                                     *mut wl_listener,
                                                 mut data:
                                                     *mut libc::c_void) {
    let mut frame: *mut wlr_screencopy_frame_v1 =
        (listener as *mut libc::c_char).offset(-72) as
            *mut wlr_screencopy_frame_v1;
    zwlr_screencopy_frame_v1_send_failed((*frame).resource);
    frame_destroy(frame);
}
unsafe extern "C" fn frame_handle_copy(mut wl_client: *mut wl_client,
                                       mut frame_resource: *mut wl_resource,
                                       mut buffer_resource:
                                           *mut wl_resource) {
    let mut frame: *mut wlr_screencopy_frame_v1 =
        frame_from_resource(frame_resource);
    if frame.is_null() { return }
    let mut output: *mut wlr_output = (*frame).output;
    if !(*output).enabled {
        zwlr_screencopy_frame_v1_send_failed((*frame).resource);
        frame_destroy(frame);
        return
    }
    let mut buffer: *mut wl_shm_buffer = wl_shm_buffer_get(buffer_resource);
    if buffer.is_null() {
        wl_resource_post_error((*frame).resource,
                               ZWLR_SCREENCOPY_FRAME_V1_ERROR_INVALID_BUFFER
                                   as libc::c_int as uint32_t,
                               b"unsupported buffer type\x00" as *const u8 as
                                   *const libc::c_char);
        return
    }
    let mut fmt: wl_shm_format =
        wl_shm_buffer_get_format(buffer) as wl_shm_format;
    let mut width: int32_t = wl_shm_buffer_get_width(buffer);
    let mut height: int32_t = wl_shm_buffer_get_height(buffer);
    let mut stride: int32_t = wl_shm_buffer_get_stride(buffer);
    if fmt as libc::c_uint != (*frame).format as libc::c_uint ||
           width != (*frame).box_0.width || height != (*frame).box_0.height ||
           stride != (*frame).stride {
        wl_resource_post_error((*frame).resource,
                               ZWLR_SCREENCOPY_FRAME_V1_ERROR_INVALID_BUFFER
                                   as libc::c_int as uint32_t,
                               b"invalid buffer attributes\x00" as *const u8
                                   as *const libc::c_char);
        return
    }
    if wl_list_empty(&mut (*frame).output_precommit.link) == 0 ||
           !(*frame).buffer.is_null() {
        wl_resource_post_error((*frame).resource,
                               ZWLR_SCREENCOPY_FRAME_V1_ERROR_ALREADY_USED as
                                   libc::c_int as uint32_t,
                               b"frame already used\x00" as *const u8 as
                                   *const libc::c_char);
        return
    }
    (*frame).buffer = buffer;
    wl_signal_add(&mut (*output).events.precommit,
                  &mut (*frame).output_precommit);
    (*frame).output_precommit.notify =
        Some(frame_handle_output_precommit as
                 unsafe extern "C" fn(_: *mut wl_listener,
                                      _: *mut libc::c_void) -> ());
    wl_signal_add(&mut (*output).events.destroy, &mut (*frame).output_enable);
    (*frame).output_enable.notify =
        Some(frame_handle_output_enable as
                 unsafe extern "C" fn(_: *mut wl_listener,
                                      _: *mut libc::c_void) -> ());
    wl_signal_add(&mut (*output).events.destroy,
                  &mut (*frame).output_destroy);
    (*frame).output_destroy.notify =
        Some(frame_handle_output_destroy as
                 unsafe extern "C" fn(_: *mut wl_listener,
                                      _: *mut libc::c_void) -> ());
    wl_resource_add_destroy_listener(buffer_resource,
                                     &mut (*frame).buffer_destroy);
    (*frame).buffer_destroy.notify =
        Some(frame_handle_buffer_destroy as
                 unsafe extern "C" fn(_: *mut wl_listener,
                                      _: *mut libc::c_void) -> ());
    // Schedule a buffer commit
    (*output).needs_frame = 1i32 != 0; // TODO: depends on read format
    wlr_output_schedule_frame(output);
    wlr_output_lock_attach_render(output, 1i32 != 0);
    if (*frame).overlay_cursor {
        wlr_output_lock_software_cursors(output, 1i32 != 0);
        (*frame).cursor_locked = 1i32 != 0
    };
}
unsafe extern "C" fn frame_handle_copy_with_damage(mut wl_client:
                                                       *mut wl_client,
                                                   mut frame_resource:
                                                       *mut wl_resource,
                                                   mut buffer_resource:
                                                       *mut wl_resource) {
    let mut frame: *mut wlr_screencopy_frame_v1 =
        frame_from_resource(frame_resource);
    if frame.is_null() { return }
    (*frame).with_damage = 1i32 != 0;
    frame_handle_copy(wl_client, frame_resource, buffer_resource);
}
unsafe extern "C" fn frame_handle_destroy(mut wl_client: *mut wl_client,
                                          mut frame_resource:
                                              *mut wl_resource) {
    wl_resource_destroy(frame_resource);
}
static mut frame_impl: zwlr_screencopy_frame_v1_interface =
    unsafe {
        {
            let mut init =
                zwlr_screencopy_frame_v1_interface{copy:
                                                       Some(frame_handle_copy
                                                                as
                                                                unsafe extern "C" fn(_:
                                                                                         *mut wl_client,
                                                                                     _:
                                                                                         *mut wl_resource,
                                                                                     _:
                                                                                         *mut wl_resource)
                                                                    -> ()),
                                                   destroy:
                                                       Some(frame_handle_destroy
                                                                as
                                                                unsafe extern "C" fn(_:
                                                                                         *mut wl_client,
                                                                                     _:
                                                                                         *mut wl_resource)
                                                                    -> ()),
                                                   copy_with_damage:
                                                       Some(frame_handle_copy_with_damage
                                                                as
                                                                unsafe extern "C" fn(_:
                                                                                         *mut wl_client,
                                                                                     _:
                                                                                         *mut wl_resource,
                                                                                     _:
                                                                                         *mut wl_resource)
                                                                    -> ()),};
            init
        }
    };
unsafe extern "C" fn frame_handle_resource_destroy(mut frame_resource:
                                                       *mut wl_resource) {
    let mut frame: *mut wlr_screencopy_frame_v1 =
        frame_from_resource(frame_resource);
    frame_destroy(frame);
}
unsafe extern "C" fn client_from_resource(mut resource: *mut wl_resource)
 -> *mut wlr_screencopy_v1_client {
    if wl_resource_instance_of(resource,
                               &zwlr_screencopy_manager_v1_interface,
                               &manager_impl as
                                   *const zwlr_screencopy_manager_v1_interface
                                   as *const libc::c_void) != 0 {
    } else {
        __assert_fail(b"wl_resource_instance_of(resource, &zwlr_screencopy_manager_v1_interface, &manager_impl)\x00"
                          as *const u8 as *const libc::c_char,
                      b"../types/wlr_screencopy_v1.c\x00" as *const u8 as
                          *const libc::c_char, 358i32 as libc::c_uint,
                      (*::std::mem::transmute::<&[u8; 76],
                                                &[libc::c_char; 76]>(b"struct wlr_screencopy_v1_client *client_from_resource(struct wl_resource *)\x00")).as_ptr());
    };
    return wl_resource_get_user_data(resource) as
               *mut wlr_screencopy_v1_client;
}
unsafe extern "C" fn capture_output(mut wl_client: *mut wl_client,
                                    mut client: *mut wlr_screencopy_v1_client,
                                    mut version: uint32_t, mut id: uint32_t,
                                    mut overlay_cursor: int32_t,
                                    mut output: *mut wlr_output,
                                    mut box_0: *const wlr_box) {
    let mut renderer: *mut wlr_renderer = 0 as *mut wlr_renderer;
    let mut buffer_box: wlr_box = wlr_box{x: 0, y: 0, width: 0, height: 0,};
    let mut frame: *mut wlr_screencopy_frame_v1 =
        calloc(1i32 as libc::c_ulong,
               ::std::mem::size_of::<wlr_screencopy_frame_v1>() as
                   libc::c_ulong) as *mut wlr_screencopy_frame_v1;
    if frame.is_null() { wl_client_post_no_memory(wl_client); return }
    (*frame).output = output;
    (*frame).overlay_cursor = overlay_cursor != 0;
    (*frame).resource =
        wl_resource_create(wl_client, &zwlr_screencopy_frame_v1_interface,
                           version as libc::c_int, id);
    if (*frame).resource.is_null() {
        free(frame as *mut libc::c_void);
        wl_client_post_no_memory(wl_client);
        return
    }
    (*frame).client = client;
    (*client).ref_0 += 1;
    wl_resource_set_implementation((*frame).resource,
                                   &frame_impl as
                                       *const zwlr_screencopy_frame_v1_interface
                                       as *const libc::c_void,
                                   frame as *mut libc::c_void,
                                   Some(frame_handle_resource_destroy as
                                            unsafe extern "C" fn(_:
                                                                     *mut wl_resource)
                                                -> ()));
    wl_list_insert(&mut (*(*client).manager).frames, &mut (*frame).link);
    wl_list_init(&mut (*frame).output_precommit.link);
    wl_list_init(&mut (*frame).output_enable.link);
    wl_list_init(&mut (*frame).output_destroy.link);
    wl_list_init(&mut (*frame).buffer_destroy.link);
    if !(output.is_null() || !(*output).enabled) {
        renderer = wlr_backend_get_renderer((*output).backend);
        if !renderer.is_null() {
        } else {
            __assert_fail(b"renderer\x00" as *const u8 as *const libc::c_char,
                          b"../types/wlr_screencopy_v1.c\x00" as *const u8 as
                              *const libc::c_char, 401i32 as libc::c_uint,
                          (*::std::mem::transmute::<&[u8; 149],
                                                    &[libc::c_char; 149]>(b"void capture_output(struct wl_client *, struct wlr_screencopy_v1_client *, uint32_t, uint32_t, int32_t, struct wlr_output *, const struct wlr_box *)\x00")).as_ptr());
        };
        if !wlr_output_preferred_read_format((*frame).output,
                                             &mut (*frame).format) {
            _wlr_log(WLR_ERROR,
                     b"[%s:%d] Failed to capture output: no read format supported by renderer\x00"
                         as *const u8 as *const libc::c_char,
                     b"../types/wlr_screencopy_v1.c\x00" as *const u8 as
                         *const libc::c_char, 405i32);
        } else {
            buffer_box =
                {
                    let mut init =
                        wlr_box{x: 0i32, y: 0, width: 0, height: 0,};
                    init
                };
            if box_0.is_null() {
                buffer_box.width = (*output).width;
                buffer_box.height = (*output).height
            } else {
                let mut ow: libc::c_int = 0;
                let mut oh: libc::c_int = 0;
                wlr_output_effective_resolution(output, &mut ow, &mut oh);
                buffer_box = *box_0;
                wlr_box_transform(&mut buffer_box, &mut buffer_box,
                                  (*output).transform, ow, oh);
                buffer_box.x =
                    (buffer_box.x as libc::c_float * (*output).scale) as
                        libc::c_int;
                buffer_box.y =
                    (buffer_box.y as libc::c_float * (*output).scale) as
                        libc::c_int;
                buffer_box.width =
                    (buffer_box.width as libc::c_float * (*output).scale) as
                        libc::c_int;
                buffer_box.height =
                    (buffer_box.height as libc::c_float * (*output).scale) as
                        libc::c_int
            }
            (*frame).box_0 = buffer_box;
            (*frame).stride = 4i32 * buffer_box.width;
            zwlr_screencopy_frame_v1_send_buffer((*frame).resource,
                                                 (*frame).format as uint32_t,
                                                 buffer_box.width as uint32_t,
                                                 buffer_box.height as
                                                     uint32_t,
                                                 (*frame).stride as uint32_t);
            return
        }
    }
    zwlr_screencopy_frame_v1_send_failed((*frame).resource);
    frame_destroy(frame);
}
unsafe extern "C" fn manager_handle_capture_output(mut wl_client:
                                                       *mut wl_client,
                                                   mut manager_resource:
                                                       *mut wl_resource,
                                                   mut id: uint32_t,
                                                   mut overlay_cursor:
                                                       int32_t,
                                                   mut output_resource:
                                                       *mut wl_resource) {
    let mut client: *mut wlr_screencopy_v1_client =
        client_from_resource(manager_resource);
    let mut version: uint32_t =
        wl_resource_get_version(manager_resource) as uint32_t;
    let mut output: *mut wlr_output =
        wlr_output_from_resource(output_resource);
    capture_output(wl_client, client, version, id, overlay_cursor, output,
                   0 as *const wlr_box);
}
unsafe extern "C" fn manager_handle_capture_output_region(mut wl_client:
                                                              *mut wl_client,
                                                          mut manager_resource:
                                                              *mut wl_resource,
                                                          mut id: uint32_t,
                                                          mut overlay_cursor:
                                                              int32_t,
                                                          mut output_resource:
                                                              *mut wl_resource,
                                                          mut x: int32_t,
                                                          mut y: int32_t,
                                                          mut width: int32_t,
                                                          mut height:
                                                              int32_t) {
    let mut client: *mut wlr_screencopy_v1_client =
        client_from_resource(manager_resource);
    let mut version: uint32_t =
        wl_resource_get_version(manager_resource) as uint32_t;
    let mut output: *mut wlr_output =
        wlr_output_from_resource(output_resource);
    let mut box_0: wlr_box =
        {
            let mut init = wlr_box{x: x, y: y, width: width, height: height,};
            init
        };
    capture_output(wl_client, client, version, id, overlay_cursor, output,
                   &mut box_0);
}
unsafe extern "C" fn manager_handle_destroy(mut wl_client: *mut wl_client,
                                            mut manager_resource:
                                                *mut wl_resource) {
    wl_resource_destroy(manager_resource);
}
static mut manager_impl: zwlr_screencopy_manager_v1_interface =
    unsafe {
        {
            let mut init =
                zwlr_screencopy_manager_v1_interface{capture_output:
                                                         Some(manager_handle_capture_output
                                                                  as
                                                                  unsafe extern "C" fn(_:
                                                                                           *mut wl_client,
                                                                                       _:
                                                                                           *mut wl_resource,
                                                                                       _:
                                                                                           uint32_t,
                                                                                       _:
                                                                                           int32_t,
                                                                                       _:
                                                                                           *mut wl_resource)
                                                                      -> ()),
                                                     capture_output_region:
                                                         Some(manager_handle_capture_output_region
                                                                  as
                                                                  unsafe extern "C" fn(_:
                                                                                           *mut wl_client,
                                                                                       _:
                                                                                           *mut wl_resource,
                                                                                       _:
                                                                                           uint32_t,
                                                                                       _:
                                                                                           int32_t,
                                                                                       _:
                                                                                           *mut wl_resource,
                                                                                       _:
                                                                                           int32_t,
                                                                                       _:
                                                                                           int32_t,
                                                                                       _:
                                                                                           int32_t,
                                                                                       _:
                                                                                           int32_t)
                                                                      -> ()),
                                                     destroy:
                                                         Some(manager_handle_destroy
                                                                  as
                                                                  unsafe extern "C" fn(_:
                                                                                           *mut wl_client,
                                                                                       _:
                                                                                           *mut wl_resource)
                                                                      ->
                                                                          ()),};
            init
        }
    };
unsafe extern "C" fn manager_handle_resource_destroy(mut resource:
                                                         *mut wl_resource) {
    let mut client: *mut wlr_screencopy_v1_client =
        client_from_resource(resource);
    client_unref(client);
}
unsafe extern "C" fn manager_bind(mut wl_client: *mut wl_client,
                                  mut data: *mut libc::c_void,
                                  mut version: uint32_t, mut id: uint32_t) {
    let mut resource: *mut wl_resource = 0 as *mut wl_resource;
    let mut manager: *mut wlr_screencopy_manager_v1 =
        data as *mut wlr_screencopy_manager_v1;
    let mut client: *mut wlr_screencopy_v1_client =
        calloc(1i32 as libc::c_ulong,
               ::std::mem::size_of::<wlr_screencopy_v1_client>() as
                   libc::c_ulong) as *mut wlr_screencopy_v1_client;
    if !client.is_null() {
        resource =
            wl_resource_create(wl_client,
                               &zwlr_screencopy_manager_v1_interface,
                               version as libc::c_int, id);
        if !resource.is_null() {
            (*client).ref_0 = 1i32;
            (*client).manager = manager;
            wl_list_init(&mut (*client).damages);
            wl_resource_set_implementation(resource,
                                           &manager_impl as
                                               *const zwlr_screencopy_manager_v1_interface
                                               as *const libc::c_void,
                                           client as *mut libc::c_void,
                                           Some(manager_handle_resource_destroy
                                                    as
                                                    unsafe extern "C" fn(_:
                                                                             *mut wl_resource)
                                                        -> ()));
            return
        }
    }
    free(client as *mut libc::c_void);
    wl_client_post_no_memory(wl_client);
}
unsafe extern "C" fn handle_display_destroy(mut listener: *mut wl_listener,
                                            mut data: *mut libc::c_void) {
    let mut manager: *mut wlr_screencopy_manager_v1 =
        (listener as *mut libc::c_char).offset(-24) as
            *mut wlr_screencopy_manager_v1;
    wlr_signal_emit_safe(&mut (*manager).events.destroy,
                         manager as *mut libc::c_void);
    wl_list_remove(&mut (*manager).display_destroy.link);
    wl_global_destroy((*manager).global);
    free(manager as *mut libc::c_void);
}
#[no_mangle]
pub unsafe extern "C" fn wlr_screencopy_manager_v1_create(mut display:
                                                              *mut wl_display)
 -> *mut wlr_screencopy_manager_v1 {
    let mut manager: *mut wlr_screencopy_manager_v1 =
        calloc(1i32 as libc::c_ulong,
               ::std::mem::size_of::<wlr_screencopy_manager_v1>() as
                   libc::c_ulong) as *mut wlr_screencopy_manager_v1;
    if manager.is_null() { return 0 as *mut wlr_screencopy_manager_v1 }
    (*manager).global =
        wl_global_create(display, &zwlr_screencopy_manager_v1_interface, 2i32,
                         manager as *mut libc::c_void,
                         Some(manager_bind as
                                  unsafe extern "C" fn(_: *mut wl_client,
                                                       _: *mut libc::c_void,
                                                       _: uint32_t,
                                                       _: uint32_t) -> ()));
    if (*manager).global.is_null() {
        free(manager as *mut libc::c_void);
        return 0 as *mut wlr_screencopy_manager_v1
    }
    wl_list_init(&mut (*manager).frames);
    wl_signal_init(&mut (*manager).events.destroy);
    (*manager).display_destroy.notify =
        Some(handle_display_destroy as
                 unsafe extern "C" fn(_: *mut wl_listener,
                                      _: *mut libc::c_void) -> ());
    wl_display_add_destroy_listener(display, &mut (*manager).display_destroy);
    return manager;
}
